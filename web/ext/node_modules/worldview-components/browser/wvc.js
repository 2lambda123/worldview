(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WVC = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null), (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDraggable"] = factory((typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null), (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null));
	else
		root["ReactDraggable"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(1).default;
	module.exports.DraggableCore = __webpack_require__(9).default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _classnames = __webpack_require__(4);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _domFns = __webpack_require__(5);
	
	var _positionFns = __webpack_require__(8);
	
	var _shims = __webpack_require__(6);
	
	var _DraggableCore = __webpack_require__(9);
	
	var _DraggableCore2 = _interopRequireDefault(_DraggableCore);
	
	var _log = __webpack_require__(11);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// $FlowIgnore
	
	
	/*:: import type {DraggableEventHandler} from './utils/types';*/
	/*:: type DraggableState = {
	  dragging: boolean,
	  dragged: boolean,
	  x: number, y: number,
	  slackX: number, slackY: number,
	  isElementSVG: boolean
	};*/
	
	
	//
	// Define <Draggable>
	//
	
	/*:: type ConstructorProps = {
	  position: { x: number, y: number },
	  defaultPosition: { x: number, y: number }
	};*/
	
	var Draggable = function (_React$Component) {
	  _inherits(Draggable, _React$Component);
	
	  function Draggable(props /*: ConstructorProps*/) {
	    _classCallCheck(this, Draggable);
	
	    var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));
	
	    _this.onDragStart = function (e, coreData) {
	      (0, _log2.default)('Draggable: onDragStart: %j', coreData);
	
	      // Short-circuit if user's callback killed it.
	      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      // Kills start event on core as well, so move handlers are never bound.
	      if (shouldStart === false) return false;
	
	      _this.setState({ dragging: true, dragged: true });
	    };
	
	    _this.onDrag = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	      (0, _log2.default)('Draggable: onDrag: %j', coreData);
	
	      var uiData = (0, _positionFns.createDraggableData)(_this, coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        x: uiData.x,
	        y: uiData.y
	      };
	
	      // Keep within bounds.
	      if (_this.props.bounds) {
	        // Save original x and y.
	        var _x = newState.x,
	            _y = newState.y;
	
	        // Add slack to the values used to calculate bound position. This will ensure that if
	        // we start removing slack, the element won't react to it right away until it's been
	        // completely removed.
	
	        newState.x += _this.state.slackX;
	        newState.y += _this.state.slackY;
	
	        // Get bound position. This will ceil/floor the x and y within the boundaries.
	        // $FlowBug
	
	        // Recalculate slack by noting how much was shaved by the boundPosition handler.
	        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);
	
	        var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);
	
	        newState.x = _getBoundPosition2[0];
	        newState.y = _getBoundPosition2[1];
	        newState.slackX = _this.state.slackX + (_x - newState.x);
	        newState.slackY = _this.state.slackY + (_y - newState.y);
	
	        // Update the event we fire to reflect what really happened after bounds took effect.
	        uiData.x = _x;
	        uiData.y = _y;
	        uiData.deltaX = newState.x - _this.state.x;
	        uiData.deltaY = newState.y - _this.state.y;
	      }
	
	      // Short-circuit if user's callback killed it.
	      var shouldUpdate = _this.props.onDrag(e, uiData);
	      if (shouldUpdate === false) return false;
	
	      _this.setState(newState);
	    };
	
	    _this.onDragStop = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	
	      // Short-circuit if user's callback killed it.
	      var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      if (shouldStop === false) return false;
	
	      (0, _log2.default)('Draggable: onDragStop: %j', coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        dragging: false,
	        slackX: 0,
	        slackY: 0
	      };
	
	      // If this is a controlled component, the result of this operation will be to
	      // revert back to the old position. We expect a handler on `onDragStop`, at the least.
	      var controlled = Boolean(_this.props.position);
	      if (controlled) {
	        var _this$props$position = _this.props.position,
	            _x2 = _this$props$position.x,
	            _y2 = _this$props$position.y;
	
	        newState.x = _x2;
	        newState.y = _y2;
	      }
	
	      _this.setState(newState);
	    };
	
	    _this.state = {
	      // Whether or not we are currently dragging.
	      dragging: false,
	
	      // Whether or not we have been dragged before.
	      dragged: false,
	
	      // Current transform x and y.
	      x: props.position ? props.position.x : props.defaultPosition.x,
	      y: props.position ? props.position.y : props.defaultPosition.y,
	
	      // Used for compensating for out-of-bounds drags
	      slackX: 0, slackY: 0,
	
	      // Can only determine if SVG after mounting
	      isElementSVG: false
	    };
	    return _this;
	  }
	
	  _createClass(Draggable, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
	        // eslint-disable-next-line
	        console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      // Check to see if the element passed is an instanceof SVGElement
	      if (typeof SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof SVGElement) {
	        this.setState({ isElementSVG: true });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps /*: Object*/) {
	      // Set x/y if position has changed
	      if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
	        this.setState({ x: nextProps.position.x, y: nextProps.position.y });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
	    }
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      var _classNames;
	
	      var style = {},
	          svgTransform = null;
	
	      // If this is controlled, we don't want to move it - unless it's dragging.
	      var controlled = Boolean(this.props.position);
	      var draggable = !controlled || this.state.dragging;
	
	      var position = this.props.position || this.props.defaultPosition;
	      var transformOpts = {
	        // Set left if horizontal drag is enabled
	        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,
	
	        // Set top if vertical drag is enabled
	        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
	      };
	
	      // If this element was SVG, we use the `transform` attribute.
	      if (this.state.isElementSVG) {
	        svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
	      } else {
	        // Add a CSS transform to move the element around. This allows us to move the element around
	        // without worrying about whether or not it is relatively or absolutely positioned.
	        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
	        // has a clean slate.
	        style = (0, _domFns.createCSSTransform)(transformOpts);
	      }
	
	      var _props = this.props,
	          defaultClassName = _props.defaultClassName,
	          defaultClassNameDragging = _props.defaultClassNameDragging,
	          defaultClassNameDragged = _props.defaultClassNameDragged;
	
	      // Mark with class while dragging
	
	      var className = (0, _classnames2.default)(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));
	
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.createElement(
	        _DraggableCore2.default,
	        _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
	        _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	          className: className,
	          style: _extends({}, this.props.children.props.style, style),
	          transform: svgTransform
	        })
	      );
	    }
	  }]);
	
	  return Draggable;
	}(_react2.default.Component);
	
	Draggable.displayName = 'Draggable';
	Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {
	
	  /**
	   * `axis` determines which axis the draggable can move.
	   *
	   *  Note that all callbacks will still return data as normal. This only
	   *  controls flushing to the DOM.
	   *
	   * 'both' allows movement horizontally and vertically.
	   * 'x' limits movement to horizontal axis.
	   * 'y' limits movement to vertical axis.
	   * 'none' limits all movement.
	   *
	   * Defaults to 'both'.
	   */
	  axis: _react.PropTypes.oneOf(['both', 'x', 'y', 'none']),
	
	  /**
	   * `bounds` determines the range of movement available to the element.
	   * Available values are:
	   *
	   * 'parent' restricts movement within the Draggable's parent node.
	   *
	   * Alternatively, pass an object with the following properties, all of which are optional:
	   *
	   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
	   *
	   * All values are in px.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable bounds={{right: 300, bottom: 300}}>
	   *              <div>Content</div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  bounds: _react.PropTypes.oneOfType([_react.PropTypes.shape({
	    left: _react.PropTypes.number,
	    right: _react.PropTypes.number,
	    top: _react.PropTypes.number,
	    bottom: _react.PropTypes.number
	  }), _react.PropTypes.string, _react.PropTypes.oneOf([false])]),
	
	  defaultClassName: _react.PropTypes.string,
	  defaultClassNameDragging: _react.PropTypes.string,
	  defaultClassNameDragged: _react.PropTypes.string,
	
	  /**
	   * `defaultPosition` specifies the x and y that the dragged item should start at
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  defaultPosition: _react.PropTypes.shape({
	    x: _react.PropTypes.number,
	    y: _react.PropTypes.number
	  }),
	
	  /**
	   * `position`, if present, defines the current position of the element.
	   *
	   *  This is similar to how form elements in React work - if no `position` is supplied, the component
	   *  is uncontrolled.
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable position={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  position: _react.PropTypes.shape({
	    x: _react.PropTypes.number,
	    y: _react.PropTypes.number
	  }),
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	});
	Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {
	  axis: 'both',
	  bounds: false,
	  defaultClassName: 'react-draggable',
	  defaultClassNameDragging: 'react-draggable-dragging',
	  defaultClassNameDragged: 'react-draggable-dragged',
	  defaultPosition: { x: 0, y: 0 },
	  position: null
	});
	exports.default = Draggable;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.matchesSelector = matchesSelector;
	exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
	exports.addEvent = addEvent;
	exports.removeEvent = removeEvent;
	exports.outerHeight = outerHeight;
	exports.outerWidth = outerWidth;
	exports.innerHeight = innerHeight;
	exports.innerWidth = innerWidth;
	exports.offsetXYFromParent = offsetXYFromParent;
	exports.createCSSTransform = createCSSTransform;
	exports.createSVGTransform = createSVGTransform;
	exports.getTouch = getTouch;
	exports.getTouchIdentifier = getTouchIdentifier;
	exports.addUserSelectStyles = addUserSelectStyles;
	exports.removeUserSelectStyles = removeUserSelectStyles;
	exports.styleHacks = styleHacks;
	
	var _shims = __webpack_require__(6);
	
	var _getPrefix = __webpack_require__(7);
	
	var _getPrefix2 = _interopRequireDefault(_getPrefix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	/*:: import type {ControlPosition} from './types';*/
	
	
	var matchesSelectorFunc = '';
	function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
	  if (!matchesSelectorFunc) {
	    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
	      // $FlowIgnore: Doesn't think elements are indexable
	      return (0, _shims.isFunction)(el[method]);
	    });
	  }
	
	  // $FlowIgnore: Doesn't think elements are indexable
	  return el[matchesSelectorFunc].call(el, selector);
	}
	
	// Works up the tree to the draggable itself attempting to match selector.
	function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
	  var node = el;
	  do {
	    if (matchesSelector(node, selector)) return true;
	    if (node === baseNode) return false;
	    node = node.parentNode;
	  } while (node);
	
	  return false;
	}
	
	function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.attachEvent) {
	    el.attachEvent('on' + event, handler);
	  } else if (el.addEventListener) {
	    el.addEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = handler;
	  }
	}
	
	function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.detachEvent) {
	    el.detachEvent('on' + event, handler);
	  } else if (el.removeEventListener) {
	    el.removeEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = null;
	  }
	}
	
	function outerHeight(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetTop which is including margin. See getBoundPosition
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height += (0, _shims.int)(computedStyle.borderTopWidth);
	  height += (0, _shims.int)(computedStyle.borderBottomWidth);
	  return height;
	}
	
	function outerWidth(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetLeft which is including margin. See getBoundPosition
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width += (0, _shims.int)(computedStyle.borderLeftWidth);
	  width += (0, _shims.int)(computedStyle.borderRightWidth);
	  return width;
	}
	function innerHeight(node /*: HTMLElement*/) /*: number*/ {
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height -= (0, _shims.int)(computedStyle.paddingTop);
	  height -= (0, _shims.int)(computedStyle.paddingBottom);
	  return height;
	}
	
	function innerWidth(node /*: HTMLElement*/) /*: number*/ {
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width -= (0, _shims.int)(computedStyle.paddingLeft);
	  width -= (0, _shims.int)(computedStyle.paddingRight);
	  return width;
	}
	
	// Get from offsetParent
	function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
	  var isBody = offsetParent === offsetParent.ownerDocument.body;
	  var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();
	
	  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
	  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
	
	  return { x: x, y: y };
	}
	
	function createCSSTransform(_ref) /*: Object*/ {
	  var x = _ref.x,
	      y = _ref.y;
	
	  // Replace unitless items with px
	  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
	}
	
	function createSVGTransform(_ref3) /*: string*/ {
	  var x = _ref3.x,
	      y = _ref3.y;
	
	  return 'translate(' + x + ',' + y + ')';
	}
	
	function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
	  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
	    return identifier === t.identifier;
	  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
	    return identifier === t.identifier;
	  });
	}
	
	function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
	  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
	  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
	}
	
	// User-select Hacks:
	//
	// Useful for preventing blue highlights all over everything when dragging.
	var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');
	var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);
	var userSelectStyle = ';' + userSelect + ': none;';
	var userSelectReplaceRegExp = new RegExp(';?' + userSelect + ': none;'); // leading ; not present on IE
	
	// Note we're passing `document` b/c we could be iframed
	function addUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  body.setAttribute('style', style + userSelectStyle);
	}
	
	function removeUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  body.setAttribute('style', style.replace(userSelectReplaceRegExp, ''));
	}
	
	function styleHacks() /*: Object*/ {
	  var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  // Workaround IE pointer events; see #51
	  // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
	  return _extends({
	    touchAction: 'none'
	  }, childStyle);
	}

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findInArray = findInArray;
	exports.isFunction = isFunction;
	exports.isNum = isNum;
	exports.int = int;
	exports.dontSetMe = dontSetMe;
	
	// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
	function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
	  for (var i = 0, length = array.length; i < length; i++) {
	    if (callback.apply(callback, [array[i], i, array])) return array[i];
	  }
	}
	
	function isFunction(func /*: any*/) /*: boolean*/ {
	  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
	}
	
	function isNum(num /*: any*/) /*: boolean*/ {
	  return typeof num === 'number' && !isNaN(num);
	}
	
	function int(a /*: string*/) /*: number*/ {
	  return parseInt(a, 10);
	}
	
	function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
	  if (props[propName]) {
	    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
	  }
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrefix = getPrefix;
	exports.browserPrefixToKey = browserPrefixToKey;
	exports.browserPrefixToStyle = browserPrefixToStyle;
	var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	function getPrefix() /*: string*/ {
	  var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
	
	  // Checking specifically for 'window.document' is for pseudo-browser server-side
	  // environments that define 'window' as the global context.
	  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
	  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';
	
	  var style = window.document.documentElement.style;
	
	  if (prop in style) return '';
	
	  for (var i = 0; i < prefixes.length; i++) {
	    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
	  }
	
	  return '';
	}
	
	function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
	}
	
	function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
	}
	
	function kebabToTitleCase(str /*: string*/) /*: string*/ {
	  var out = '';
	  var shouldCapitalize = true;
	  for (var i = 0; i < str.length; i++) {
	    if (shouldCapitalize) {
	      out += str[i].toUpperCase();
	      shouldCapitalize = false;
	    } else if (str[i] === '-') {
	      shouldCapitalize = true;
	    } else {
	      out += str[i];
	    }
	  }
	  return out;
	}
	
	// Default export is the prefix itself, like 'Moz', 'Webkit', etc
	// Note that you may have to re-test for certain things; for instance, Chrome 50
	// can handle unprefixed `transform`, but not unprefixed `user-select`
	exports.default = getPrefix();

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getBoundPosition = getBoundPosition;
	exports.snapToGrid = snapToGrid;
	exports.canDragX = canDragX;
	exports.canDragY = canDragY;
	exports.getControlPosition = getControlPosition;
	exports.createCoreData = createCoreData;
	exports.createDraggableData = createDraggableData;
	
	var _shims = __webpack_require__(6);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*:: import type Draggable from '../Draggable';*/
	/*:: import type {Bounds, ControlPosition, DraggableData} from './types';*/
	/*:: import type DraggableCore from '../DraggableCore';*/
	function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
	  // If no bounds, short-circuit and move on
	  if (!draggable.props.bounds) return [x, y];
	
	  // Clone new bounds
	  var bounds = draggable.props.bounds;
	
	  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
	  var node = _reactDom2.default.findDOMNode(draggable);
	
	  if (typeof bounds === 'string') {
	    var ownerDocument = node.ownerDocument;
	
	    var ownerWindow = ownerDocument.defaultView;
	    var boundNode = void 0;
	    if (bounds === 'parent') {
	      boundNode = node.parentNode;
	    } else {
	      boundNode = ownerDocument.querySelector(bounds);
	      if (!boundNode) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
	    }
	    var nodeStyle = ownerWindow.getComputedStyle(node);
	    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
	    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
	    bounds = {
	      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.borderLeftWidth) + (0, _shims.int)(nodeStyle.marginLeft),
	      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.borderTopWidth) + (0, _shims.int)(nodeStyle.marginTop),
	      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft,
	      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop
	    };
	  }
	
	  // Keep x and y below right and bottom limits...
	  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
	  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
	
	  // But above left and top limits.
	  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
	  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
	
	  return [x, y];
	}
	
	function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
	  var x = Math.round(pendingX / grid[0]) * grid[0];
	  var y = Math.round(pendingY / grid[1]) * grid[1];
	  return [x, y];
	}
	
	function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
	}
	
	function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
	}
	
	// Get {x, y} positions from event.
	function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
	  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
	  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
	  var node = _reactDom2.default.findDOMNode(draggableCore);
	  // User can provide an offsetParent if desired.
	  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
	  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
	}
	
	// Create an data object exposed by <DraggableCore>'s events
	function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
	  var state = draggable.state;
	  var isStart = !(0, _shims.isNum)(state.lastX);
	
	  if (isStart) {
	    // If this is our first move, use the x and y as last coords.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: 0, deltaY: 0,
	      lastX: x, lastY: y,
	      x: x, y: y
	    };
	  } else {
	    // Otherwise calculate proper values.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: x - state.lastX, deltaY: y - state.lastY,
	      lastX: state.lastX, lastY: state.lastY,
	      x: x, y: y
	    };
	  }
	}
	
	// Create an data exposed by <Draggable>'s events
	function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
	  return {
	    node: coreData.node,
	    x: draggable.state.x + coreData.deltaX,
	    y: draggable.state.y + coreData.deltaY,
	    deltaX: coreData.deltaX,
	    deltaY: coreData.deltaY,
	    lastX: draggable.state.x,
	    lastY: draggable.state.y
	  };
	}
	
	// A lot faster than stringify/parse
	function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
	  return {
	    left: bounds.left,
	    top: bounds.top,
	    right: bounds.right,
	    bottom: bounds.bottom
	  };
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(5);
	
	var _positionFns = __webpack_require__(8);
	
	var _shims = __webpack_require__(6);
	
	var _log = __webpack_require__(11);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Simple abstraction for dragging events names.
	/*:: import type {EventHandler} from './utils/types';*/
	var eventsFor = {
	  touch: {
	    start: 'touchstart',
	    move: 'touchmove',
	    stop: 'touchend'
	  },
	  mouse: {
	    start: 'mousedown',
	    move: 'mousemove',
	    stop: 'mouseup'
	  }
	};
	
	// Default to mouse events.
	var dragEventFor = eventsFor.mouse;
	
	//
	// Define <DraggableCore>.
	//
	// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
	// work well with libraries that require more control over the element.
	//
	
	/*:: type CoreState = {
	  dragging: boolean,
	  lastX: number,
	  lastY: number,
	  touchIdentifier: ?number
	};*/
	
	var DraggableCore = function (_React$Component) {
	  _inherits(DraggableCore, _React$Component);
	
	  function DraggableCore() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, DraggableCore);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      dragging: false,
	      // Used while dragging to determine deltas.
	      lastX: NaN, lastY: NaN,
	      touchIdentifier: null
	    }, _this.handleDragStart = function (e) {
	      // Make it possible to attach event handlers on top of this one.
	      _this.props.onMouseDown(e);
	
	      // Only accept left-clicks.
	      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;
	
	      // Get nodes. Be sure to grab relative document (could be iframed)
	      var domNode = _reactDom2.default.findDOMNode(_this);
	      var ownerDocument = domNode.ownerDocument;
	
	      // Short circuit if handle or cancel prop was provided and selector doesn't match.
	
	      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, domNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, domNode)) {
	        return;
	      }
	
	      // Set touch identifier in component state if this is a touch event. This allows us to
	      // distinguish between individual touches on multitouch screens by identifying which
	      // touchpoint was set to this element.
	      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
	      _this.setState({ touchIdentifier: touchIdentifier });
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
	      if (position == null) return; // not possible but satisfies flow
	      var x = position.x,
	          y = position.y;
	
	      // Create an event object with all the data parents need to make a decision here.
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, cancel.
	      (0, _log2.default)('calling', _this.props.onStart);
	      var shouldUpdate = _this.props.onStart(e, coreEvent);
	      if (shouldUpdate === false) return;
	
	      // Add a style to the body to disable user-select. This prevents text from
	      // being selected all over the page.
	      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument.body);
	
	      // Initiate dragging. Set the current x and y as offsets
	      // so we know how much we've moved during the drag. This allows us
	      // to drag elements around even if they have been moved, without issue.
	      _this.setState({
	        dragging: true,
	
	        lastX: x,
	        lastY: y
	      });
	
	      // Add events to the document directly so we catch when the user's mouse/touch moves outside of
	      // this element. We use different events depending on whether or not we have detected that this
	      // is a touch-capable device.
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.handleDrag = function (e) {
	
	      // Prevent scrolling on mobile devices, like ipad/iphone.
	      if (e.type === 'touchmove') e.preventDefault();
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      // Snap to grid if prop has been provided
	
	      if (x !== x) debugger;
	
	      if (Array.isArray(_this.props.grid)) {
	        var deltaX = x - _this.state.lastX,
	            deltaY = y - _this.state.lastY;
	
	        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
	
	        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
	
	        deltaX = _snapToGrid2[0];
	        deltaY = _snapToGrid2[1];
	
	        if (!deltaX && !deltaY) return; // skip useless drag
	        x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
	      }
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, trigger end.
	      var shouldUpdate = _this.props.onDrag(e, coreEvent);
	      if (shouldUpdate === false) {
	        try {
	          // $FlowIgnore
	          _this.handleDragStop(new MouseEvent('mouseup'));
	        } catch (err) {
	          // Old browsers
	          var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
	          // I see why this insanity was deprecated
	          // $FlowIgnore
	          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	          _this.handleDragStop(event);
	        }
	        return;
	      }
	
	      _this.setState({
	        lastX: x,
	        lastY: y
	      });
	    }, _this.handleDragStop = function (e) {
	      if (!_this.state.dragging) return;
	
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      var _ReactDOM$findDOMNode = _reactDom2.default.findDOMNode(_this),
	          ownerDocument = _ReactDOM$findDOMNode.ownerDocument;
	
	      // Remove user-select hack
	
	
	      if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	
	      (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);
	
	      // Reset the el.
	      _this.setState({
	        dragging: false,
	        lastX: NaN,
	        lastY: NaN
	      });
	
	      // Call event handler
	      _this.props.onStop(e, coreEvent);
	
	      // Remove event handlers
	      (0, _log2.default)('DraggableCore: Removing handlers');
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.onMouseDown = function (e) {
	      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse
	
	      return _this.handleDragStart(e);
	    }, _this.onMouseUp = function (e) {
	      dragEventFor = eventsFor.mouse;
	
	      return _this.handleDragStop(e);
	    }, _this.onTouchStart = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStart(e);
	    }, _this.onTouchEnd = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStop(e);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(DraggableCore, [{
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      // Remove any leftover event handlers. Remove both touch and mouse handlers in case
	      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
	      var _ReactDOM$findDOMNode2 = _reactDom2.default.findDOMNode(this),
	          ownerDocument = _ReactDOM$findDOMNode2.ownerDocument;
	
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
	      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	    }
	
	    // Same as onMouseDown (start drag), but now consider this a touch device.
	
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	        style: (0, _domFns.styleHacks)(this.props.children.props.style),
	
	        // Note: mouseMove handler is attached to document so it will still function
	        // when the user drags quickly and leaves the bounds of the element.
	        onMouseDown: this.onMouseDown,
	        onTouchStart: this.onTouchStart,
	        onMouseUp: this.onMouseUp,
	        onTouchEnd: this.onTouchEnd
	      });
	    }
	  }]);
	
	  return DraggableCore;
	}(_react2.default.Component);
	
	DraggableCore.displayName = 'DraggableCore';
	DraggableCore.propTypes = {
	  /**
	   * `allowAnyClick` allows dragging using any mouse button.
	   * By default, we only accept the left button.
	   *
	   * Defaults to `false`.
	   */
	  allowAnyClick: _react.PropTypes.bool,
	
	  /**
	   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
	   * with the exception of `onMouseDown`, will not fire.
	   */
	  disabled: _react.PropTypes.bool,
	
	  /**
	   * By default, we add 'user-select:none' attributes to the document body
	   * to prevent ugly text selection during drag. If this is causing problems
	   * for your app, set this to `false`.
	   */
	  enableUserSelectHack: _react.PropTypes.bool,
	
	  /**
	   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
	   * instead of using the parent node.
	   */
	  offsetParent: function offsetParent(props, propName) {
	    if (process.browser && props[propName] && props[propName].nodeType !== 1) {
	      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
	    }
	  },
	
	  /**
	   * `grid` specifies the x and y that dragging should snap to.
	   */
	  grid: _react.PropTypes.arrayOf(_react.PropTypes.number),
	
	  /**
	   * `handle` specifies a selector to be used as the handle that initiates drag.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable handle=".handle">
	   *              <div>
	   *                  <div className="handle">Click me to drag</div>
	   *                  <div>This is some other content</div>
	   *              </div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  handle: _react.PropTypes.string,
	
	  /**
	   * `cancel` specifies a selector to be used to prevent drag initialization.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *           return(
	   *               <Draggable cancel=".cancel">
	   *                   <div>
	   *                     <div className="cancel">You can't drag from here</div>
	   *                     <div>Dragging here works fine</div>
	   *                   </div>
	   *               </Draggable>
	   *           );
	   *       }
	   *   });
	   * ```
	   */
	  cancel: _react.PropTypes.string,
	
	  /**
	   * Called when dragging starts.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onStart: _react.PropTypes.func,
	
	  /**
	   * Called while dragging.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onDrag: _react.PropTypes.func,
	
	  /**
	   * Called when dragging stops.
	   * If this function returns the boolean false, the drag will remain active.
	   */
	  onStop: _react.PropTypes.func,
	
	  /**
	   * A workaround option which can be passed if onMouseDown needs to be accessed,
	   * since it'll always be blocked (as there is internal use of onMouseDown)
	   */
	  onMouseDown: _react.PropTypes.func,
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	};
	DraggableCore.defaultProps = {
	  allowAnyClick: false, // by default only accept left click
	  cancel: null,
	  disabled: false,
	  enableUserSelectHack: true,
	  offsetParent: null,
	  handle: null,
	  grid: null,
	  transform: null,
	  onStart: function onStart() {},
	  onDrag: function onDrag() {},
	  onStop: function onStop() {},
	  onMouseDown: function onMouseDown() {}
	};
	exports.default = DraggableCore;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = log;
	
	/*eslint no-console:0*/
	function log() {
	  var _console;
	
	  if ((undefined)) (_console = console).log.apply(_console, arguments);
	}

/***/ }
/******/ ])
});
;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
(function (global){
/**
 * @module InputRange
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _Slider = require('./Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Label = require('./Label');

var _Label2 = _interopRequireDefault(_Label);

var _defaultClassNames = require('./defaultClassNames');

var _defaultClassNames2 = _interopRequireDefault(_defaultClassNames);

var _valueTransformer = require('./valueTransformer');

var _valueTransformer2 = _interopRequireDefault(_valueTransformer);

var _util = require('./util');

var _propTypes = require('./propTypes');

/**
 * A map for storing internal members
 * @const {WeakMap}
 */
var internals = new WeakMap();

/**
 * An object storing keyboard key codes
 * @const {Object.<string, number>}
 */
var KeyCode = {
  DOWN_ARROW: 40,
  LEFT_ARROW: 37,
  RIGHT_ARROW: 39,
  UP_ARROW: 38
};

/**
 * Check if values are within the max and min range of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if within range
 */
function isWithinRange(inputRange, values) {
  var props = inputRange.props;

  if (inputRange.isMultiValue) {
    return values.min >= props.minValue && values.max <= props.maxValue && values.min < values.max;
  }

  return values.max >= props.minValue && values.max <= props.maxValue;
}

/**
 * Check if the difference between values and the current values of inputRange
 * is greater or equal to its step amount
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if difference is greater or equal to step amount
 */
function hasStepDifference(inputRange, values) {
  var props = inputRange.props;

  var currentValues = _valueTransformer2['default'].valuesFromProps(inputRange);

  return (0, _util.length)(values.min, currentValues.min) >= props.step || (0, _util.length)(values.max, currentValues.max) >= props.step;
}

/**
 * Check if inputRange should update with new values
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if inputRange should update
 */
function shouldUpdate(inputRange, values) {
  return isWithinRange(inputRange, values) && hasStepDifference(inputRange, values);
}

/**
 * Get the owner document of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Document} Document
 */
function getDocument(inputRange) {
  var ownerDocument = inputRange.refs.inputRange.ownerDocument;

  return ownerDocument;
}

/**
 * Get the class name(s) of inputRange based on its props
 * @private
 * @param {InputRange} inputRange - React component
 * @return {string} A list of class names delimited with spaces
 */
function getComponentClassName(inputRange) {
  var props = inputRange.props;

  if (!props.disabled) {
    return props.classNames.component;
  }

  return props.classNames.component + ' is-disabled';
}

/**
 * Get the key name of a slider
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Slider} slider - React component
 * @return {string} Key name
 */
function getKeyFromSlider(inputRange, slider) {
  if (slider === inputRange.refs.sliderMin) {
    return 'min';
  }

  return 'max';
}

/**
 * Get all slider keys of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Key names
 */
function getKeys(inputRange) {
  if (inputRange.isMultiValue) {
    return ['min', 'max'];
  }

  return ['max'];
}

/**
 * Get the key name of a slider that's the closest to a point
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Point} position - x/y
 * @return {string} Key name
 */
function getKeyByPosition(inputRange, position) {
  var values = _valueTransformer2['default'].valuesFromProps(inputRange);
  var positions = _valueTransformer2['default'].positionsFromValues(inputRange, values);

  if (inputRange.isMultiValue) {
    var distanceToMin = (0, _util.distanceTo)(position, positions.min);
    var distanceToMax = (0, _util.distanceTo)(position, positions.max);

    if (distanceToMin < distanceToMax) {
      return 'min';
    }
  }

  return 'max';
}

/**
 * Get an array of slider HTML for rendering
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Array of HTML
 */
function renderSliders(inputRange) {
  var classNames = inputRange.props.classNames;

  var sliders = [];
  var keys = getKeys(inputRange);
  var values = _valueTransformer2['default'].valuesFromProps(inputRange);
  var percentages = _valueTransformer2['default'].percentagesFromValues(inputRange, values);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var value = values[key];
      var percentage = percentages[key];
      var ref = 'slider' + (0, _util.captialize)(key);

      var _inputRange$props = inputRange.props;
      var maxValue = _inputRange$props.maxValue;
      var minValue = _inputRange$props.minValue;

      if (key === 'min') {
        maxValue = values.max;
      } else {
        minValue = values.min;
      }

      var slider = _react2['default'].createElement(_Slider2['default'], {
        ariaLabelledby: inputRange.props.ariaLabelledby,
        ariaControls: inputRange.props.ariaControls,
        classNames: classNames,
        formatLabel: inputRange.formatLabel,
        key: key,
        maxValue: maxValue,
        minValue: minValue,
        onSliderKeyDown: inputRange.handleSliderKeyDown,
        onSliderMouseMove: inputRange.handleSliderMouseMove,
        percentage: percentage,
        ref: ref,
        type: key,
        value: value });

      sliders.push(slider);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return sliders;
}

/**
 * Get an array of hidden input HTML for rendering
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Array of HTML
 */
function renderHiddenInputs(inputRange) {
  var inputs = [];
  var keys = getKeys(inputRange);

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var key = _step2.value;

      var _name = inputRange.isMultiValue ? '' + inputRange.props.name + (0, _util.captialize)(key) : inputRange.props.name;

      var input = _react2['default'].createElement('input', { type: 'hidden', name: _name });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return inputs;
}

/**
 * InputRange React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var InputRange = (function (_React$Component) {
  _inherits(InputRange, _React$Component);

  function InputRange(props) {
    _classCallCheck(this, InputRange);

    _get(Object.getPrototypeOf(InputRange.prototype), 'constructor', this).call(this, props);

    // Private
    internals.set(this, {});

    // Auto-bind
    (0, _util.autobind)(['formatLabel', 'handleInteractionEnd', 'handleInteractionStart', 'handleKeyDown', 'handleKeyUp', 'handleMouseDown', 'handleMouseUp', 'handleSliderKeyDown', 'handleSliderMouseMove', 'handleTouchStart', 'handleTouchEnd', 'handleTrackMouseDown'], this);
  }

  /**
   * Accepted propTypes of InputRange
   * @static {Object}
   * @property {Function} ariaLabelledby
   * @property {Function} ariaControls
   * @property {Function} classNames
   * @property {Function} defaultValue
   * @property {Function} disabled
   * @property {Function} formatLabel
   * @property {Function} labelPrefix
   * @property {Function} labelSuffix
   * @property {Function} maxValue
   * @property {Function} minValue
   * @property {Function} name
   * @property {Function} onChange
   * @property {Function} onChangeComplete
   * @property {Function} step
   * @property {Function} value
   */

  /**
   * Return the clientRect of the component's track
   * @member {ClientRect}
   */

  _createClass(InputRange, [{
    key: 'updatePosition',

    /**
     * Update the position of a slider by key
     * @param {string} key - min/max
     * @param {Point} position x/y
     */
    value: function updatePosition(key, position) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var positions = _valueTransformer2['default'].positionsFromValues(this, values);

      positions[key] = position;

      this.updatePositions(positions);
    }

    /**
     * Update the position of sliders
     * @param {Object} positions
     * @param {Point} positions.min
     * @param {Point} positions.max
     */
  }, {
    key: 'updatePositions',
    value: function updatePositions(positions) {
      var values = {
        min: _valueTransformer2['default'].valueFromPosition(this, positions.min),
        max: _valueTransformer2['default'].valueFromPosition(this, positions.max)
      };

      var transformedValues = {
        min: _valueTransformer2['default'].stepValueFromValue(this, values.min),
        max: _valueTransformer2['default'].stepValueFromValue(this, values.max)
      };

      this.updateValues(transformedValues);
    }

    /**
     * Update the value of a slider by key
     * @param {string} key - max/min
     * @param {number} value - New value
     */
  }, {
    key: 'updateValue',
    value: function updateValue(key, value) {
      var values = _valueTransformer2['default'].valuesFromProps(this);

      values[key] = value;

      this.updateValues(values);
    }

    /**
     * Update the values of all sliders
     * @param {Object|number} values - Object if multi-value, number if single-value
     */
  }, {
    key: 'updateValues',
    value: function updateValues(values) {
      if (!shouldUpdate(this, values)) {
        return;
      }

      if (this.isMultiValue) {
        this.props.onChange(this, values);
      } else {
        this.props.onChange(this, values.max);
      }
    }

    /**
     * Increment the value of a slider by key name
     * @param {string} key - max/min
     */
  }, {
    key: 'incrementValue',
    value: function incrementValue(key) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var value = values[key] + this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Decrement the value of a slider by key name
     * @param {string} key - max/min
     */
  }, {
    key: 'decrementValue',
    value: function decrementValue(key) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var value = values[key] - this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Format label
     * @param {number} labelValue - Label value
     * @return {string} Formatted label value
     */
  }, {
    key: 'formatLabel',
    value: function formatLabel(labelValue) {
      var _props = this.props;
      var formatLabel = _props.formatLabel;
      var labelPrefix = _props.labelPrefix;
      var labelSuffix = _props.labelSuffix;

      if (formatLabel) {
        return formatLabel(labelValue, { labelPrefix: labelPrefix, labelSuffix: labelSuffix });
      }

      return '' + labelPrefix + labelValue + labelSuffix;
    }

    /**
     * Handle any mousemove event received by the slider
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     */
  }, {
    key: 'handleSliderMouseMove',
    value: function handleSliderMouseMove(event, slider) {
      if (this.props.disabled) {
        return;
      }

      var key = getKeyFromSlider(this, slider);
      var position = _valueTransformer2['default'].positionFromEvent(this, event);

      this.updatePosition(key, position);
    }

    /**
     * Handle any keydown event received by the slider
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     */
  }, {
    key: 'handleSliderKeyDown',
    value: function handleSliderKeyDown(event, slider) {
      if (this.props.disabled) {
        return;
      }

      var key = getKeyFromSlider(this, slider);

      switch (event.keyCode) {
        case KeyCode.LEFT_ARROW:
        case KeyCode.DOWN_ARROW:
          event.preventDefault();
          this.decrementValue(key);
          break;

        case KeyCode.RIGHT_ARROW:
        case KeyCode.UP_ARROW:
          event.preventDefault();
          this.incrementValue(key);
          break;

        default:
          break;
      }
    }

    /**
     * Handle any mousedown event received by the track
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     * @param {Point} position - Mousedown position
     */
  }, {
    key: 'handleTrackMouseDown',
    value: function handleTrackMouseDown(event, track, position) {
      if (this.props.disabled) {
        return;
      }

      event.preventDefault();

      var key = getKeyByPosition(this, position);

      this.updatePosition(key, position);
    }

    /**
     * Handle the start of any user-triggered event
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleInteractionStart',
    value: function handleInteractionStart() {
      var _this = internals.get(this);

      if (!this.props.onChangeComplete || (0, _util.isDefined)(_this.startValue)) {
        return;
      }

      _this.startValue = this.props.value || this.props.defaultValue;
    }

    /**
     * Handle the end of any user-triggered event
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleInteractionEnd',
    value: function handleInteractionEnd() {
      var _this = internals.get(this);

      if (!this.props.onChangeComplete || !(0, _util.isDefined)(_this.startValue)) {
        return;
      }

      if (_this.startValue !== this.props.value) {
        this.props.onChangeComplete(this, this.props.value);
      }

      _this.startValue = null;
    }

    /**
     * Handle any keydown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.handleInteractionStart(event);
    }

    /**
     * Handle any keyup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyUp',
    value: function handleKeyUp(event) {
      this.handleInteractionEnd(event);
    }

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      var document = getDocument(this);

      this.handleInteractionStart(event);

      document.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mouseup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      var document = getDocument(this);

      this.handleInteractionEnd(event);

      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      var document = getDocument(this);

      this.handleInteractionStart(event);

      document.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any touchend event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      var document = getDocument(this);

      this.handleInteractionEnd(event);

      document.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var classNames = this.props.classNames;

      var componentClassName = getComponentClassName(this);
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var percentages = _valueTransformer2['default'].percentagesFromValues(this, values);

      return _react2['default'].createElement(
        'div',
        {
          'aria-disabled': this.props.disabled,
          ref: 'inputRange',
          className: componentClassName,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart },
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelMin,
            containerClassName: classNames.labelContainer,
            formatLabel: this.formatLabel },
          this.props.minValue
        ),
        _react2['default'].createElement(
          _Track2['default'],
          {
            classNames: classNames,
            ref: 'track',
            percentages: percentages,
            onTrackMouseDown: this.handleTrackMouseDown },
          renderSliders(this)
        ),
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelMax,
            containerClassName: classNames.labelContainer,
            formatLabel: this.formatLabel },
          this.props.maxValue
        ),
        renderHiddenInputs(this)
      );
    }
  }, {
    key: 'trackClientRect',
    get: function get() {
      var track = this.refs.track;

      if (track) {
        return track.clientRect;
      }

      return {
        height: 0,
        left: 0,
        top: 0,
        width: 0
      };
    }

    /**
     * Return true if the component accepts a range of values
     * @member {boolean}
     */
  }, {
    key: 'isMultiValue',
    get: function get() {
      return (0, _util.isObject)(this.props.value) || (0, _util.isObject)(this.props.defaultValue);
    }
  }]);

  return InputRange;
})(_react2['default'].Component);

exports['default'] = InputRange;
InputRange.propTypes = {
  ariaLabelledby: _react2['default'].PropTypes.string,
  ariaControls: _react2['default'].PropTypes.string,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  defaultValue: _propTypes.maxMinValuePropType,
  disabled: _react2['default'].PropTypes.bool,
  formatLabel: _react2['default'].PropTypes.func,
  labelPrefix: _react2['default'].PropTypes.string,
  labelSuffix: _react2['default'].PropTypes.string,
  maxValue: _propTypes.maxMinValuePropType,
  minValue: _propTypes.maxMinValuePropType,
  name: _react2['default'].PropTypes.string,
  onChange: _react2['default'].PropTypes.func.isRequired,
  onChangeComplete: _react2['default'].PropTypes.func,
  step: _react2['default'].PropTypes.number,
  value: _propTypes.maxMinValuePropType
};

/**
 * Default props of InputRange
 * @static {Object}
 * @property {Object.<string, string>} defaultClassNames
 * @property {Range|number} defaultValue
 * @property {boolean} disabled
 * @property {string} labelPrefix
 * @property {string} labelSuffix
 * @property {number} maxValue
 * @property {number} minValue
 * @property {number} step
 * @property {Range|number} value
 */
InputRange.defaultProps = {
  classNames: _defaultClassNames2['default'],
  defaultValue: 0,
  disabled: false,
  labelPrefix: '',
  labelSuffix: '',
  maxValue: 10,
  minValue: 0,
  step: 1,
  value: null
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Label":3,"./Slider":4,"./Track":5,"./defaultClassNames":6,"./propTypes":8,"./util":9,"./valueTransformer":10}],3:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Label
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

/**
 * Label React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Label = (function (_React$Component) {
  _inherits(Label, _React$Component);

  function Label() {
    _classCallCheck(this, Label);

    _get(Object.getPrototypeOf(Label.prototype), 'constructor', this).apply(this, arguments);
  }

  /**
   * Accepted propTypes of Label
   * @static {Object}
   * @property {Function} children
   * @property {Function} className
   * @property {Function} containerClassName
   * @property {Function} formatLabel
   */

  _createClass(Label, [{
    key: 'render',

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
    value: function render() {
      var _props = this.props;
      var className = _props.className;
      var containerClassName = _props.containerClassName;

      var labelValue = this.props.formatLabel ? this.props.formatLabel(this.props.children) : this.props.children;

      return _react2['default'].createElement(
        'span',
        { className: className },
        _react2['default'].createElement(
          'span',
          { className: containerClassName },
          labelValue
        )
      );
    }
  }]);

  return Label;
})(_react2['default'].Component);

exports['default'] = Label;
Label.propTypes = {
  children: _react2['default'].PropTypes.node,
  className: _react2['default'].PropTypes.string,
  containerClassName: _react2['default'].PropTypes.string,
  formatLabel: _react2['default'].PropTypes.func
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Slider
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _Label = require('./Label');

var _Label2 = _interopRequireDefault(_Label);

var _util = require('./util');

/**
 * Get the owner document of slider
 * @private
 * @param {Slider} slider - React component
 * @return {Document} Document
 */
function getDocument(slider) {
  var ownerDocument = slider.refs.slider.ownerDocument;

  return ownerDocument;
}

/**
 * Get the style of slider based on its props
 * @private
 * @param {Slider} slider - React component
 * @return {Object} CSS styles
 */
function getStyle(slider) {
  var perc = (slider.props.percentage || 0) * 100;
  var style = {
    position: 'absolute',
    left: perc + '%'
  };

  return style;
}

/**
 * Slider React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    // Auto-bind
    (0, _util.autobind)(['handleClick', 'handleMouseDown', 'handleMouseUp', 'handleMouseMove', 'handleTouchStart', 'handleTouchEnd', 'handleTouchMove', 'handleKeyDown'], this);
  }

  /**
   * Accepted propTypes of Slider
   * @static {Object}
   * @property {Function} ariaLabelledby
   * @property {Function} ariaControls
   * @property {Function} className
   * @property {Function} formatLabel
   * @property {Function} maxValue
   * @property {Function} minValue
   * @property {Function} onSliderKeyDown
   * @property {Function} onSliderMouseMove
   * @property {Function} percentage
   * @property {Function} type
   * @property {Function} value
   */

  /**
   * Handle any click event received by the component
   * @param {SyntheticEvent} event - User event
   */

  _createClass(Slider, [{
    key: 'handleClick',
    value: function handleClick(event) {
      event.preventDefault();
    }

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown() {
      var document = getDocument(this);

      // Event
      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mouseup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      var document = getDocument(this);

      // Event
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mousemove event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      this.props.onSliderMouseMove(event, this);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      var document = getDocument(this);

      event.preventDefault();

      document.addEventListener('touchmove', this.handleTouchMove);
      document.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any touchmove event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchMove',
    value: function handleTouchMove(event) {
      this.props.onSliderMouseMove(event, this);
    }

    /**
     * Handle any touchend event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      var document = getDocument(this);

      event.preventDefault();

      document.removeEventListener('touchmove', this.handleTouchMove);
      document.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any keydown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.props.onSliderKeyDown(event, this);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var classNames = this.props.classNames;
      var style = getStyle(this);

      return _react2['default'].createElement(
        'span',
        {
          className: classNames.sliderContainer,
          ref: 'slider',
          style: style },
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelValue,
            containerClassName: classNames.labelContainer,
            formatLabel: this.props.formatLabel },
          this.props.value
        ),
        _react2['default'].createElement('a', {
          'aria-labelledby': this.props.ariaLabelledby,
          'aria-controls': this.props.ariaControls,
          'aria-valuemax': this.props.maxValue,
          'aria-valuemin': this.props.minValue,
          'aria-valuenow': this.props.formatLabel ? this.props.formatLabel(this.props.value) : this.props.value,
          className: classNames.slider,
          draggable: 'false',
          href: '#',
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          role: 'slider' })
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

exports['default'] = Slider;
Slider.propTypes = {
  ariaLabelledby: _react2['default'].PropTypes.string,
  ariaControls: _react2['default'].PropTypes.string,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  formatLabel: _react2['default'].PropTypes.func,
  maxValue: _react2['default'].PropTypes.number,
  minValue: _react2['default'].PropTypes.number,
  onSliderKeyDown: _react2['default'].PropTypes.func.isRequired,
  onSliderMouseMove: _react2['default'].PropTypes.func.isRequired,
  percentage: _react2['default'].PropTypes.number.isRequired,
  type: _react2['default'].PropTypes.string.isRequired,
  value: _react2['default'].PropTypes.number.isRequired
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Label":3,"./util":9}],5:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Track
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _util = require('./util');

/**
 * Get the CSS styles for an active track
 * @private
 * @param {Track} track React component
 * @return {Object} CSS styles
 */
function getActiveTrackStyle(track) {
  var props = track.props;

  var width = (props.percentages.max - props.percentages.min) * 100 + '%';
  var left = props.percentages.min * 100 + '%';

  var activeTrackStyle = {
    left: left,
    width: width
  };

  return activeTrackStyle;
}

/**
 * Track React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Track = (function (_React$Component) {
  _inherits(Track, _React$Component);

  function Track(props) {
    _classCallCheck(this, Track);

    _get(Object.getPrototypeOf(Track.prototype), 'constructor', this).call(this, props);

    // Auto-bind
    (0, _util.autobind)(['handleMouseDown', 'handleTouchStart'], this);
  }

  /**
   * Accepted propTypes of Track
   * @static {Object}
   * @property {Function} children
   * @property {Function} classNames
   * @property {Function} onTrackMouseDown
   * @property {Function} percentages
   */

  /**
   * Return the clientRect of the component
   * @member {ClientRect}
   */

  _createClass(Track, [{
    key: 'handleMouseDown',

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
    value: function handleMouseDown(event) {
      var trackClientRect = this.clientRect;

      var _ref = event.touches ? event.touches[0] : event;

      var clientX = _ref.clientX;

      var position = {
        x: clientX - trackClientRect.left,
        y: 0
      };

      this.props.onTrackMouseDown(event, this, position);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      event.preventDefault();

      this.handleMouseDown(event);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var activeTrackStyle = getActiveTrackStyle(this);
      var classNames = this.props.classNames;

      return _react2['default'].createElement(
        'div',
        {
          className: classNames.trackContainer,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          ref: 'track' },
        _react2['default'].createElement('div', {
          style: activeTrackStyle,
          className: classNames.trackActive }),
        this.props.children
      );
    }
  }, {
    key: 'clientRect',
    get: function get() {
      var track = this.refs.track;

      var clientRect = track.getBoundingClientRect();

      return clientRect;
    }
  }]);

  return Track;
})(_react2['default'].Component);

exports['default'] = Track;
Track.propTypes = {
  children: _react2['default'].PropTypes.node,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  onTrackMouseDown: _react2['default'].PropTypes.func.isRequired,
  percentages: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.number).isRequired
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./util":9}],6:[function(require,module,exports){
/**
 * @module InputRange/defaultClassNames
 */

/**
* An object containing class names
* @const {Object}
* @property {string} component
* @property {string} labelContainer
* @property {string} labelMax
* @property {string} labelMin
* @property {string} labelValue
* @property {string} slider
* @property {string} sliderContainer
* @property {string} trackActive
* @property {string} trackContainer
*/
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  component: 'InputRange',
  labelContainer: 'InputRange-labelContainer',
  labelMax: 'InputRange-label InputRange-label--max',
  labelMin: 'InputRange-label InputRange-label--min',
  labelValue: 'InputRange-label InputRange-label--value',
  slider: 'InputRange-slider',
  sliderContainer: 'InputRange-sliderContainer',
  trackActive: 'InputRange-track InputRange-track--active',
  trackContainer: 'InputRange-track InputRange-track--container'
};
module.exports = exports['default'];
},{}],7:[function(require,module,exports){
/**
 * @module InputRange
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _InputRange = require('./InputRange');

var _InputRange2 = _interopRequireDefault(_InputRange);

/**
 * An object describing the position of a point
 * @typedef {Object} Point
 * @property {number} x - x value
 * @property {number} y - y value
 */

/**
 * An object describing a range of values
 * @typedef {Object} Range
 * @property {number} min - Min value
 * @property {number} max - Max value
 */

exports['default'] = _InputRange2['default'];
module.exports = exports['default'];
},{"./InputRange":2}],8:[function(require,module,exports){
/**
 * @module InputRange/maxMinValuePropType
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.maxMinValuePropType = maxMinValuePropType;

var _util = require('./util');

/**
 * A prop type accepting a range of numeric values or a single numeric value
 * @param {Object} props - React component props
 * @return {?Error} Return Error if validation fails
 */

function maxMinValuePropType(props) {
  var maxValue = props.maxValue;
  var minValue = props.minValue;
  var value = props.value;
  var defaultValue = props.defaultValue;
  var isValueNumber = (0, _util.isNumber)(value);
  var isDefaultValueNumber = (0, _util.isNumber)(defaultValue);
  var isValueNumberObject = (0, _util.objectOf)(value, _util.isNumber);
  var isDefaultValueNumberObject = (0, _util.objectOf)(defaultValue, _util.isNumber);

  if (value === undefined) {
    return new Error('`value` must be defined');
  }

  if (!isValueNumber && !isDefaultValueNumber && !isValueNumberObject && !isDefaultValueNumberObject) {
    return new Error('`value` or `defaultValue` must be a number or an array');
  }

  if (minValue >= maxValue) {
    return new Error('`minValue` must be smaller than `maxValue`');
  }

  if (maxValue <= minValue) {
    return new Error('`maxValue` must be larger than `minValue`');
  }

  if (value < minValue || value > maxValue) {
    return new Error('`value` must be within `minValue` and `maxValue`');
  }
}
},{"./util":9}],9:[function(require,module,exports){
/**
 * @module InputRange/util
 */

/**
 * @callback predicateFn
 * @param {*} value
 * @return {boolean}
 */

/**
 * Clamp a value between a min and max value
 * @static
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.clamp = clamp;
exports.extend = extend;
exports.includes = includes;
exports.omit = omit;
exports.captialize = captialize;
exports.distanceTo = distanceTo;
exports.length = length;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isDefined = isDefined;
exports.isEmpty = isEmpty;
exports.arrayOf = arrayOf;
exports.objectOf = objectOf;
exports.autobind = autobind;

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Extend an Object
 * @static
 * @param {Object} object - Destination object
 * @param {...Object} sources - Source objects
 * @return {Object} Destination object, extended with members from sources
 */

function extend() {
  return Object.assign.apply(Object, arguments);
}

/**
 * Check if a value is included in an array
 * @static
 * @param {Array} array
 * @param {number} value
 * @return {boolean}
 */

function includes(array, value) {
  return array.indexOf(value) > -1;
}

/**
 * Return a new object without the specified keys
 * @static
 * @param {Object} obj
 * @param {Array.<string>} omitKeys
 * @return {Object}
 */

function omit(obj, omitKeys) {
  var keys = Object.keys(obj);
  var outputObj = {};

  keys.forEach(function (key) {
    if (!includes(omitKeys, key)) {
      outputObj[key] = obj[key];
    }
  });

  return outputObj;
}

/**
 * Captialize a string
 * @static
 * @param {string} string
 * @return {string}
 */

function captialize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Calculate the distance between pointA and pointB
 * @static
 * @param {Point} pointA
 * @param {Point} pointB
 * @return {number} Distance
 */

function distanceTo(pointA, pointB) {
  return Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2));
}

/**
 * Calculate the absolute difference between two numbers
 * @static
 * @param {number} numA
 * @param {number} numB
 * @return {number}
 */

function length(numA, numB) {
  return Math.abs(numA - numB);
}

/**
 * Check if a value is a number
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isNumber(value) {
  return typeof value === 'number';
}

/**
 * Check if a value is an object
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isObject(value) {
  return value !== null && typeof value === 'object';
}

/**
 * Check if a value is defined
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isDefined(value) {
  return value !== undefined && value !== null;
}

/**
 * Check if an object is empty
 * @static
 * @param {Object|Array} obj
 * @return {Boolean}
 */

function isEmpty(obj) {
  if (!obj) {
    return true;
  }

  if (Array.isArray(obj)) {
    return obj.length === 0;
  }

  return Object.keys(obj).length === 0;
}

/**
 * Check if all items in an array match a predicate
 * @static
 * @param {Array} array
 * @param {predicateFn} predicate
 * @return {Boolean}
 */

function arrayOf(array, predicate) {
  if (!Array.isArray(array)) {
    return false;
  }

  for (var i = 0, len = array.length; i < len; i++) {
    if (!predicate(array[i])) {
      return false;
    }
  }

  return true;
}

/**
 * Check if all items in an object match a predicate
 * @static
 * @param {Object} object
 * @param {predicateFn} predicate
 * @param {Array.<string>} keys
 * @return {Boolean}
 */

function objectOf(object, predicate, keys) {
  if (!isObject(object)) {
    return false;
  }

  var props = keys || Object.keys(object);

  for (var i = 0, len = props.length; i < len; i++) {
    var prop = props[i];

    if (!predicate(object[prop])) {
      return false;
    }
  }

  return true;
}

/**
 * Bind all methods of an object to itself
 * @static
 * @param {Array.<Function>} methodNames
 * @param {Object} instance
 */

function autobind(methodNames, instance) {
  methodNames.forEach(function (methodName) {
    instance[methodName] = instance[methodName].bind(instance);
  });
}
},{}],10:[function(require,module,exports){
/**
 * @module InputRange/valueTransformer
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _util = require('./util');

/**
 * Convert position into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Percentage value
 */
function percentageFromPosition(inputRange, position) {
  var length = inputRange.trackClientRect.width;
  var sizePerc = position.x / length;

  return sizePerc || 0;
}

/**
 * Convert position into model value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Model value
 */
function valueFromPosition(inputRange, position) {
  var sizePerc = percentageFromPosition(inputRange, position);
  var valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  var value = inputRange.props.minValue + valueDiff * sizePerc;

  return value;
}

/**
 * Extract values from props
 * @static
 * @param {InputRange} inputRange
 * @param {Point} [props=inputRange.props]
 * @return {Range} Range values
 */
function valuesFromProps(inputRange) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? inputRange : arguments[1];

  var props = _ref.props;
  return (function () {
    if (inputRange.isMultiValue) {
      var values = props.value;

      if ((0, _util.isEmpty)(values) || !(0, _util.objectOf)(values, _util.isNumber)) {
        values = props.defaultValue;
      }

      return Object.create(values);
    }

    var value = (0, _util.isNumber)(props.value) ? props.value : props.defaultValue;

    return {
      min: props.minValue,
      max: value
    };
  })();
}

/**
 * Convert value into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Percentage value
 */
function percentageFromValue(inputRange, value) {
  var validValue = (0, _util.clamp)(value, inputRange.props.minValue, inputRange.props.maxValue);
  var valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  var valuePerc = (validValue - inputRange.props.minValue) / valueDiff;

  return valuePerc || 0;
}

/**
 * Convert values into percentage values
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Range} Percentage values
 */
function percentagesFromValues(inputRange, values) {
  var percentages = {
    min: percentageFromValue(inputRange, values.min),
    max: percentageFromValue(inputRange, values.max)
  };

  return percentages;
}

/**
 * Convert value into position
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {Point} Position
 */
function positionFromValue(inputRange, value) {
  var length = inputRange.trackClientRect.width;
  var valuePerc = percentageFromValue(inputRange, value);
  var positionValue = valuePerc * length;

  return {
    x: positionValue,
    y: 0
  };
}

/**
 * Convert a range of values into positions
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Object.<string, Point>}
 */
function positionsFromValues(inputRange, values) {
  var positions = {
    min: positionFromValue(inputRange, values.min),
    max: positionFromValue(inputRange, values.max)
  };

  return positions;
}

/**
 * Extract a position from an event
 * @static
 * @param {InputRange} inputRange
 * @param {Event} event
 * @return {Point}
 */
function positionFromEvent(inputRange, event) {
  var trackClientRect = inputRange.trackClientRect;
  var length = trackClientRect.width;

  var _ref2 = event.touches ? event.touches[0] : event;

  var clientX = _ref2.clientX;

  var position = {
    x: (0, _util.clamp)(clientX - trackClientRect.left, 0, length),
    y: 0
  };

  return position;
}

/**
 * Convert a value into a step value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Step value
 */
function stepValueFromValue(inputRange, value) {
  return Math.round(value / inputRange.props.step) * inputRange.props.step;
}

exports['default'] = {
  percentageFromPosition: percentageFromPosition,
  percentageFromValue: percentageFromValue,
  percentagesFromValues: percentagesFromValues,
  positionFromEvent: positionFromEvent,
  positionFromValue: positionFromValue,
  positionsFromValues: positionsFromValues,
  stepValueFromValue: stepValueFromValue,
  valueFromPosition: valueFromPosition,
  valuesFromProps: valuesFromProps
};
module.exports = exports['default'];
},{"./util":9}],11:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wv = require('../tooltip/wv.tooltip');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var animWidgetHeader = function (_React$Component) {
  _inherits(animWidgetHeader, _React$Component);

  function animWidgetHeader(props) {
    _classCallCheck(this, animWidgetHeader);

    return _possibleConstructorReturn(this, (animWidgetHeader.__proto__ || Object.getPrototypeOf(animWidgetHeader)).call(this, props));
  }

  _createClass(animWidgetHeader, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-animation-widget-header' },
        'Animate Map in ',
        _react2.default.createElement(_wv2.default, { text: this.props.text, onClick: this.props.onClick, dataArray: this.props.toolTipTextArray }),
        ' Increments'
      );
    }
  }]);

  return animWidgetHeader;
}(_react2.default.Component);

exports.default = animWidgetHeader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tooltip/wv.tooltip":22}],12:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactInputRange = require('react-input-range');

var _reactInputRange2 = _interopRequireDefault(_reactInputRange);

var _wv = require('../dateselector/wv.dateselector');

var _wv2 = _interopRequireDefault(_wv);

var _wv3 = require('./wv.loopbutton');

var _wv4 = _interopRequireDefault(_wv3);

var _wv5 = require('./wv.playbutton');

var _wv6 = _interopRequireDefault(_wv5);

var _wvAnimationWidget = require('./wv.animation.widget.header');

var _wvAnimationWidget2 = _interopRequireDefault(_wvAnimationWidget);

var _wv7 = require('../util/wv.googleAnalytics');

var _wv8 = _interopRequireDefault(_wv7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var AnimationWidget = function (_React$Component) {
  _inherits(AnimationWidget, _React$Component);

  function AnimationWidget(props) {
    _classCallCheck(this, AnimationWidget);

    var _this = _possibleConstructorReturn(this, (AnimationWidget.__proto__ || Object.getPrototypeOf(AnimationWidget)).call(this, props));

    _this.state = {
      value: props.sliderSpeed,
      looping: props.looping,
      startDate: props.startDate,
      endDate: props.endDate,
      header: props.header,
      incrementArray: props.incrementArray,
      increment: props.increment

    };
    return _this;
  }

  /*
   * Sets a new state value when a
   * when the slider is adjusted
   *
   * @method onSlide
   *
   * @param {Object} component - slider react
   *  component
   * @param {number} value - Value of the slider
   *  selection
   *
   * @return {void}
   */


  _createClass(AnimationWidget, [{
    key: 'onSlide',
    value: function onSlide(component, value) {
      this.props.onSlide(value);
      this.setState({
        value: value
      });
    }

    /*
     * calls the callback, passing the
     * current state elements as parameters
     *
     * @method play
     *
     * @return {void}
     */

  }, {
    key: 'play',
    value: function play() {
      this.props.onPushPlay();
      this.setState({
        playing: true
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.props.onPushPause();
      this.setState({
        playing: false
      });
    }
    /*
     * Sets a new state to say whether or not
     * the animation should loop
     *
     * @method onLoop
     *
     * @param {Object} component - slider react
     *  component
     * @param {number} value - Value of the slider
     *  selection
     *
     * @return {void}
     */

  }, {
    key: 'onLoop',
    value: function onLoop() {
      var loop = true;
      if (this.state.looping) {
        loop = false;
      }
      this.setState({
        looping: loop
      });
      this.props.onPushLoop(loop);
    }
  }, {
    key: 'onDateChange',
    value: function onDateChange(id, date) {
      if (id === 'start') {
        this.setState({
          startDate: date
        });
        this.props.onDateChange(date, this.state.endDate);
      } else {
        this.setState({
          endDate: date
        });
        this.props.onDateChange(this.state.startDate, date);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { id: 'wv-animation-widget', className: 'wv-animation-widget' },
        _react2.default.createElement(_wvAnimationWidget2.default, {
          text: this.state.increment,
          toolTipTextArray: this.state.incrementArray,
          onClick: this.props.onZoomSelect }),
        _react2.default.createElement(_wv6.default, { playing: this.state.playing, play: this.play.bind(this), pause: this.pause.bind(this) }),
        _react2.default.createElement(_wv4.default, { looping: this.state.looping, onLoop: this.onLoop.bind(this) }),
        _react2.default.createElement(
          'div',
          { className: 'wv-slider-case' },
          _react2.default.createElement(_reactInputRange2.default, { maxValue: 10, minValue: 1, value: this.state.value, onChange: this.onSlide.bind(this) }),
          _react2.default.createElement(
            'span',
            { className: 'wv-slider-label' },
            this.props.sliderLabel
          )
        ),
        _react2.default.createElement(
          'a',
          { href: 'javascript:void(null)',
            title: 'Create Animated GIF',
            className: 'wv-icon-case',
            onClick: this.props.onPushGIF
          },
          _react2.default.createElement('i', { className: 'fa fa-file-video-o wv-animation-widget-icon' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'wv-anim-dates-case' },
          _react2.default.createElement(_wv2.default, {
            width: '120',
            height: '30',
            date: this.state.startDate,
            id: 'start',
            onDateChange: this.onDateChange.bind(this),
            maxDate: this.state.endDate,
            minDate: this.props.minDate
          }),
          _react2.default.createElement(
            'div',
            { className: 'thru-label' },
            'To'
          ),
          _react2.default.createElement(_wv2.default, {
            width: '120',
            height: '30',
            date: this.state.endDate,
            id: 'end',
            onDateChange: this.onDateChange.bind(this),
            maxDate: this.props.maxDate,
            minDate: this.state.startDate
          })
        ),
        _react2.default.createElement('i', {
          className: 'fa fa-close wv-close',
          onClick: this.props.onClose
        })
      );
    }
  }]);

  return AnimationWidget;
}(_react2.default.Component);

exports.default = AnimationWidget;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../dateselector/wv.dateselector":18,"../util/wv.googleAnalytics":23,"./wv.animation.widget.header":11,"./wv.loopbutton":13,"./wv.playbutton":14,"react-input-range":7}],13:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var LoopButton = function (_React$Component) {
  _inherits(LoopButton, _React$Component);

  function LoopButton(props) {
    _classCallCheck(this, LoopButton);

    return _possibleConstructorReturn(this, (LoopButton.__proto__ || Object.getPrototypeOf(LoopButton)).call(this, props));
  }

  _createClass(LoopButton, [{
    key: "render",
    value: function render() {
      return _react2.default.createElement(
        "a",
        { href: "javascript:void(null)",
          title: this.props.looping ? "Stop Loop" : "Loop video",
          className: this.props.looping ? 'wv-loop-icon-case wv-icon-case active' : 'wv-loop-icon-case wv-icon-case',
          onClick: this.props.onLoop
        },
        _react2.default.createElement("i", { className: "fa fa-retweet wv-animation-widget-icon" })
      );
    }
  }]);

  return LoopButton;
}(_react2.default.Component);

exports.default = LoopButton;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var PlayButton = function (_React$Component) {
  _inherits(PlayButton, _React$Component);

  function PlayButton(props) {
    _classCallCheck(this, PlayButton);

    return _possibleConstructorReturn(this, (PlayButton.__proto__ || Object.getPrototypeOf(PlayButton)).call(this, props));
  }

  _createClass(PlayButton, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'a',
        { href: 'javascript:void(null)', title: this.props.playing ? 'Pause video' : 'Play video',
          className: 'wv-anim-play-case wv-icon-case',
          onClick: this.props.playing ? this.props.pause : this.props.play
        },
        _react2.default.createElement('i', { className: this.props.playing ? 'fa fa-pause wv-animation-widget-icon' : 'fa fa-play wv-animation-widget-icon' })
      );
    }
  }]);

  return PlayButton;
}(_react2.default.Component);

exports.default = PlayButton;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvDateselector = require('./wv.dateselector.input');

var _wvDateselector2 = _interopRequireDefault(_wvDateselector);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var dateSelector = function (_React$Component) {
  _inherits(dateSelector, _React$Component);

  /*
   * @constructor
   */
  function dateSelector(props) {
    _classCallCheck(this, dateSelector);

    var _this = _possibleConstructorReturn(this, (dateSelector.__proto__ || Object.getPrototypeOf(dateSelector)).call(this, props));

    _this.state = {
      date: props.date,
      maxDate: props.maxDate,
      minDate: props.minDate,
      tab: null
    };
    return _this;
  }

  _createClass(dateSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        date: props.date,
        maxDate: props.maxDate,
        minDate: props.minDate
      });
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({ tab: null });
    }
  }, {
    key: 'nextTab',
    value: function nextTab(index) {
      var nextTab;
      if (index < 3) {
        nextTab = index + 1;
      } else {
        nextTab = 1;
      }
      this.setState({
        tab: nextTab
      });
    }
  }, {
    key: 'updateDate',
    value: function updateDate(date) {
      this.setState({
        date: date
      });
      this.props.onDateChange(this.props.id, date);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-date-selector-widget' },
        _react2.default.createElement(_wvDateselector2.default, { startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          value: this.state.date.getUTCFullYear(),
          type: 'year',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          tabIndex: 1,
          focused: this.state.tab == 1,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(), date: this.state.date,
          type: 'month', height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.monthStringArray[this.state.date.getUTCMonth()],
          tabIndex: 2,
          focused: this.state.tab == 2,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          type: 'day',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.pad(this.state.date.getUTCDate(), 2, '0'),
          tabIndex: 3,
          focused: this.state.tab == 3,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        })
      );
    }
  }]);

  return dateSelector;
}(_react2.default.Component);

exports.default = dateSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24,"./wv.dateselector.input":16}],16:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var DateInputColumn = function (_React$Component) {
  _inherits(DateInputColumn, _React$Component);

  /*
   * @constructor
   */
  function DateInputColumn(props) {
    _classCallCheck(this, DateInputColumn);

    var _this = _possibleConstructorReturn(this, (DateInputColumn.__proto__ || Object.getPrototypeOf(DateInputColumn)).call(this, props));

    _this.state = {
      value: _this.props.value,
      valid: true
    };
    return _this;
  }

  _createClass(DateInputColumn, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.focused) {
        _reactDom2.default.findDOMNode(this.refs['input-' + this.props.tabIndex]).focus();
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      var size;
      var type;
      type = this.props.type;
      if (type === 'year') {
        size = '4';
      } else if (type === 'day') {
        size = 2;
      } else {
        size = 3;
      }
      this.size = size;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({ value: props.value });
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      var kc = e.keyCode;
      if (kc === 9 || // tab
      kc === 13) {
        //enter
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: 'onKeyUp',
    value: function onKeyUp(e) {
      var keyCode = e.keyCode;
      var value = e.target.value;
      var newDate;
      var entered = keyCode == 13 || keyCode == 9;
      if (keyCode === 38) {
        //up
        e.preventDefault();
        this.onClickUp();
        return;
      }
      if (keyCode === 40) {
        // down
        e.preventDefault();
        this.onClickDown();
        return;
      }
      if (e.type == 'focusout' || entered) {
        if (this.props.type == 'year' || this.props.type == 'day') {
          if (!(keyCode >= 48 && keyCode <= 57 || entered || keyCode == 8)) {
            return;
          }
        }
        switch (this.props.type) {
          case 'year':
            newDate = this.yearValidation(value);
            break;
          case 'day':
            newDate = this.dayValidation(value);
            break;
          case 'month':
            newDate = this.monthValidation(value);
            break;
        }
        if (newDate) {
          this.props.updateDate(newDate);
          if (entered) {
            //if enetered or tabbed
            this.nextTab();
          }
        } else if (entered) {
          this.setState({
            valid: false
          });
        }
      }
    }
  }, {
    key: 'onClickUp',
    value: function onClickUp() {
      this.rollDate(1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'onClickDown',
    value: function onClickDown() {
      this.rollDate(-1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'yearValidation',
    value: function yearValidation(input) {
      var newDate;
      if (input > 1000 && input < 9999) {
        newDate = new Date(new Date(this.props.date).setUTCFullYear(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'dayValidation',
    value: function dayValidation(input) {
      var newDate;
      var maxDate;
      var currentDate = this.props.date;

      maxDate = new Date(currentDate.getYear(), currentDate.getMonth() + 1, 0).getDate();

      if (input > 0 && input <= maxDate) {
        newDate = new Date(new Date(currentDate).setUTCDate(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'rollDate',
    value: function rollDate(amt) {
      var newDate = util.rollDate(this.props.date, this.props.type, amt, this.props.minDate, this.props.maxDate);
      this.props.updateDate(newDate);
    }
  }, {
    key: 'monthValidation',
    value: function monthValidation(input) {
      var newDate;
      if (!isNaN(input) && input < 13 && input > 0) {
        newDate = new Date(new Date(this.props.date).setUTCMonth(input - 1));
        if (newDate) {
          this.setState({
            value: util.monthStringArray[input - 1]
          });
          return this.validateDate(newDate);
        }
      } else {
        var realMonth = void 0;
        realMonth = util.stringInArray(util.monthStringArray, input);
        if (realMonth !== false) {
          newDate = new Date(new Date(this.props.date).setUTCMonth(realMonth));
          return this.validateDate(newDate);
        } else {
          return false;
        }
      }
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({
        value: this.props.value,
        valid: true
      });

      this.props.blur();
    }
  }, {
    key: 'onChange',
    value: function onChange(e) {
      this.setState({
        value: e.target.value.toUpperCase()
      });
    }
  }, {
    key: 'nextTab',
    value: function nextTab() {
      this.props.nextTab(this.props.tabIndex);
    }
  }, {
    key: 'validateDate',
    value: function validateDate(date) {
      if (date > this.props.minDate && date <= this.props.maxDate) {
        this.setState({
          valid: true
        });
        return date;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'input-wrapper', style: this.state.valid ? {} : { borderColor: '#ff0000' } },
        _react2.default.createElement(
          'div',
          { onClick: this.onClickUp.bind(this), className: 'date-arrows date-arrow-up', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'uparrow' })
          )
        ),
        _react2.default.createElement('input', {
          type: 'text',
          ref: 'input-' + this.props.tabIndex,
          size: this.size,
          maxLength: this.size,
          className: 'button-input-group',
          id: this.props.type + '-input-group',
          value: this.state.value,
          tabIndex: this.props.tabIndex,
          onKeyUp: this.onKeyUp.bind(this),
          onKeyDown: this.onKeyPress.bind(this) //currently not working
          , onChange: this.onChange.bind(this),
          style: { fontSize: this.props.height / 2 + 'px' },
          onBlur: this.blur.bind(this)
        }),
        _react2.default.createElement(
          'div',
          { onClick: this.onClickDown.bind(this), className: 'date-arrows date-arrow-down', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'downarrow' })
          )
        )
      );
    }
  }]);

  return DateInputColumn;
}(_react2.default.Component);

exports.default = DateInputColumn;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24}],17:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var DateInputColumn = function (_React$Component) {
  _inherits(DateInputColumn, _React$Component);

  /*
   * @constructor
   */
  function DateInputColumn(props) {
    _classCallCheck(this, DateInputColumn);

    var _this = _possibleConstructorReturn(this, (DateInputColumn.__proto__ || Object.getPrototypeOf(DateInputColumn)).call(this, props));

    _this.state = {
      value: _this.props.value,
      valid: true
    };
    return _this;
  }

  _createClass(DateInputColumn, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.focused) {
        _reactDom2.default.findDOMNode(this.refs['input-' + this.props.tabIndex]).focus();
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      var size;
      var type;
      type = this.props.type;
      if (type === 'year') {
        size = '4';
      } else if (type === 'day') {
        size = 2;
      } else {
        size = 3;
      }
      this.size = size;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({ value: props.value });
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      var kc = e.keyCode;
      if (kc === 9 || // tab
      kc === 13) {
        //enter
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: 'onKeyUp',
    value: function onKeyUp(e) {
      var keyCode = e.keyCode;
      var value = e.target.value;
      var newDate;
      var entered = keyCode == 13 || keyCode == 9;
      if (keyCode === 38) {
        //up
        e.preventDefault();
        this.onClickUp();
        return;
      }
      if (keyCode === 40) {
        // down
        e.preventDefault();
        this.onClickDown();
        return;
      }
      if (e.type == 'focusout' || entered) {
        if (this.props.type == 'year' || this.props.type == 'day') {
          if (!(keyCode >= 48 && keyCode <= 57 || entered || keyCode == 8)) {
            return;
          }
        }
        switch (this.props.type) {
          case 'year':
            newDate = this.yearValidation(value);
            break;
          case 'day':
            newDate = this.dayValidation(value);
            break;
          case 'month':
            newDate = this.monthValidation(value);
            break;
        }
        if (newDate) {
          this.props.updateDate(newDate);
          if (entered) {
            //if enetered or tabbed
            this.nextTab();
          }
        } else if (entered) {
          this.setState({
            valid: false
          });
        }
      }
    }
  }, {
    key: 'onClickUp',
    value: function onClickUp() {
      this.rollDate(1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'onClickDown',
    value: function onClickDown() {
      this.rollDate(-1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'yearValidation',
    value: function yearValidation(input) {
      var newDate;
      if (input > 1000 && input < 9999) {
        newDate = new Date(new Date(this.props.date).setUTCFullYear(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'dayValidation',
    value: function dayValidation(input) {
      var newDate;
      var maxDate;
      var currentDate = this.props.date;

      maxDate = new Date(currentDate.getYear(), currentDate.getMonth() + 1, 0).getDate();

      if (input > 0 && input <= maxDate) {
        newDate = new Date(new Date(currentDate).setUTCDate(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'rollDate',
    value: function rollDate(amt) {
      var newDate = util.rollDate(this.props.date, this.props.type, amt, this.props.minDate, this.props.maxDate);
      this.props.updateDate(newDate);
    }
  }, {
    key: 'monthValidation',
    value: function monthValidation(input) {
      var newDate;
      if (!isNaN(input) && input < 13 && input > 0) {
        newDate = new Date(new Date(this.props.date).setUTCMonth(input - 1));
        if (newDate) {
          this.setState({
            value: util.monthStringArray[input - 1]
          });
          return this.validateDate(newDate);
        }
      } else {
        var realMonth = void 0;
        realMonth = util.stringInArray(util.monthStringArray, input);
        if (realMonth !== false) {
          newDate = new Date(new Date(this.props.date).setUTCMonth(realMonth));
          return this.validateDate(newDate);
        } else {
          return false;
        }
      }
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({
        value: this.props.value,
        valid: true
      });

      this.props.blur();
    }
  }, {
    key: 'onChange',
    value: function onChange(e) {
      this.setState({
        value: e.target.value.toUpperCase()
      });
    }
  }, {
    key: 'nextTab',
    value: function nextTab() {
      this.props.nextTab(this.props.tabIndex);
    }
  }, {
    key: 'validateDate',
    value: function validateDate(date) {
      if (date > this.props.minDate && date <= this.props.maxDate) {
        this.setState({
          valid: true
        });
        return date;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'input-wrapper', style: this.state.valid ? {} : { borderColor: '#ff0000' } },
        _react2.default.createElement(
          'div',
          { onClick: this.onClickUp.bind(this), className: 'date-arrows date-arrow-up', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'uparrow' })
          )
        ),
        _react2.default.createElement('input', {
          type: 'text',
          ref: 'input-' + this.props.tabIndex,
          size: this.size,
          maxLength: this.size,
          className: 'button-input-group',
          id: this.props.type + '-input-group',
          value: this.state.value,
          tabIndex: this.props.tabIndex,
          onKeyUp: this.onKeyUp.bind(this),
          onKeyDown: this.onKeyPress.bind(this) //currently not working
          , onChange: this.onChange.bind(this),
          style: { fontSize: this.props.height / 2 + 'px' },
          onBlur: this.blur.bind(this)
        }),
        _react2.default.createElement(
          'div',
          { onClick: this.onClickDown.bind(this), className: 'date-arrows date-arrow-down', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'downarrow' })
          )
        )
      );
    }
  }]);

  return DateInputColumn;
}(_react2.default.Component);

exports.default = DateInputColumn;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24}],18:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvDateselector = require('./wv.dateselector.input');

var _wvDateselector2 = _interopRequireDefault(_wvDateselector);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var dateSelector = function (_React$Component) {
  _inherits(dateSelector, _React$Component);

  /*
   * @constructor
   */
  function dateSelector(props) {
    _classCallCheck(this, dateSelector);

    var _this = _possibleConstructorReturn(this, (dateSelector.__proto__ || Object.getPrototypeOf(dateSelector)).call(this, props));

    _this.state = {
      date: props.date,
      maxDate: props.maxDate,
      minDate: props.minDate,
      tab: null
    };
    return _this;
  }

  _createClass(dateSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        date: props.date,
        maxDate: props.maxDate,
        minDate: props.minDate
      });
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({ tab: null });
    }
  }, {
    key: 'nextTab',
    value: function nextTab(index) {
      var nextTab;
      if (index < 3) {
        nextTab = index + 1;
      } else {
        nextTab = 1;
      }
      this.setState({
        tab: nextTab
      });
    }
  }, {
    key: 'updateDate',
    value: function updateDate(date) {
      this.setState({
        date: date
      });
      this.props.onDateChange(this.props.id, date);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-date-selector-widget' },
        _react2.default.createElement(_wvDateselector2.default, { startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          value: this.state.date.getUTCFullYear(),
          type: 'year',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          tabIndex: 1,
          focused: this.state.tab == 1,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(), date: this.state.date,
          type: 'month', height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.monthStringArray[this.state.date.getUTCMonth()],
          tabIndex: 2,
          focused: this.state.tab == 2,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          type: 'day',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.pad(this.state.date.getUTCDate(), 2, '0'),
          tabIndex: 3,
          focused: this.state.tab == 3,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        })
      );
    }
  }]);

  return dateSelector;
}(_react2.default.Component);

exports.default = dateSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24,"./wv.dateselector.input":17}],19:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDraggable = require('react-draggable');

var _reactDraggable2 = _interopRequireDefault(_reactDraggable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * group
 *
 * @class TimelineDragger
 * @extends React.Component
 */
var TimelineDragger = function (_React$Component) {
  _inherits(TimelineDragger, _React$Component);

  /*
   * @constructor
   */
  function TimelineDragger(props) {
    _classCallCheck(this, TimelineDragger);

    return _possibleConstructorReturn(this, (TimelineDragger.__proto__ || Object.getPrototypeOf(TimelineDragger)).call(this, props));
  }

  _createClass(TimelineDragger, [{
    key: 'checkVisibility',
    value: function checkVisibility() {
      var visibility = 'visible';
      if (this.props.position < 0 || this.props.position > this.props.max) {
        visibility = 'hidden';
      }
      this.state = {
        visibility: visibility
      };
    }
    /*
     * When the component is dragged,
     * this function passes the id
     * and change-in-x of the drag
     * to onDrag callback
     *
     * @method handleDrag
     *
     * @return {void}
     */

  }, {
    key: 'handleDrag',
    value: function handleDrag(e, d) {
      e.stopPropagation();
      this.props.onDrag(d.deltaX, this.props.id);
    }

    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      this.checkVisibility();
      return _react2.default.createElement(
        _reactDraggable2.default,
        {
          onDrag: this.handleDrag.bind(this),
          position: { x: this.props.position, y: 0 },
          onStop: this.props.onStop,
          axis: 'x'
        },
        _react2.default.createElement(
          'g',
          null,
          _react2.default.createElement('rect', {
            width: this.props.width,
            height: this.props.height,
            style: {
              fill: this.props.color,
              visibility: this.state.visibility
            }
          }),
          _react2.default.createElement('polygon', {
            points: '0,0,' + this.props.height / 1.5 + ',0 ' + this.props.height / 3 + ', ' + this.props.height / 1.5,
            transform: 'translate(' + -(this.props.width * 2.45) + ', ' + -(this.props.height / 2) + ')',
            style: {
              fill: this.props.triangleColor,
              visibility: this.state.visibility,
              stroke: '#000',
              cursor: 'pointer'
            }
          })
        )
      );
    }
  }]);

  return TimelineDragger;
}(_react2.default.Component);

exports.default = TimelineDragger;

TimelineDragger.defaultProps = {
  visible: true
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"react-draggable":1}],20:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * rect element
 *
 * @class TimelineDraggerRange
 */
var TimelineDraggerRange = function (_React$Component) {
  _inherits(TimelineDraggerRange, _React$Component);

  /*
   * @constructor
   */
  function TimelineDraggerRange(props) {
    _classCallCheck(this, TimelineDraggerRange);

    var _this = _possibleConstructorReturn(this, (TimelineDraggerRange.__proto__ || Object.getPrototypeOf(TimelineDraggerRange)).call(this, props));

    _this.opacity = {
      fillOpacity: _this.props.opacity
    };
    return _this;
  }

  _createClass(TimelineDraggerRange, [{
    key: 'checkWidth',
    value: function checkWidth() {
      var start = this.props.startLocation;
      var end = this.props.endLocation;
      var max = this.props.max;
      var width;

      if (start < 0) {
        start = 0;
      }
      if (end > max) {
        end = max;
      }
      width = end - start;
      if (width < 0) {
        width = 0;
      }
      this.state = {
        width: width,
        startLocation: start
      };
    }
    /*
     * When the component is dragged,
     * this function passes the id
     * and change in x of the drag
     * to onDrag property
     *
     * @method handleDrag
     *
     * @return {void}
     */

  }, {
    key: 'handleDrag',
    value: function handleDrag(e, d) {
      e.stopPropagation();
      this.props.onDrag(d.deltaX);
    }

    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      this.checkWidth();
      return _react2.default.createElement('rect', {
        x: this.state.startLocation,
        fill: this.props.color,
        width: this.state.width,
        style: this.opacity,
        height: this.props.height,
        className: 'dragger-range',
        onClick: this.props.onClick
      });
    }
  }]);

  return TimelineDraggerRange;
}(_react2.default.Component);

exports.default = TimelineDraggerRange;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],21:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvTimelineDragger = require('./wv.timeline.dragger.js');

var _wvTimelineDragger2 = _interopRequireDefault(_wvTimelineDragger);

var _wvTimelineDraggerrange = require('./wv.timeline.draggerrange.js');

var _wvTimelineDraggerrange2 = _interopRequireDefault(_wvTimelineDraggerrange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */
var TimelineRangeSelector = function (_React$Component) {
  _inherits(TimelineRangeSelector, _React$Component);

  /*
   * @constructor
   */
  function TimelineRangeSelector(props) {
    _classCallCheck(this, TimelineRangeSelector);

    var _this = _possibleConstructorReturn(this, (TimelineRangeSelector.__proto__ || Object.getPrototypeOf(TimelineRangeSelector)).call(this, props));

    _this.state = {
      startLocation: props.startLocation,
      endLocation: props.endLocation,
      max: props.max
    };
    return _this;
  }

  _createClass(TimelineRangeSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        startLocation: props.startLocation,
        endLocation: props.endLocation,
        max: props.max
      });
    }
    /*
     * When a child component is dragged,
     * this function is called to determine
     * the correct location for each of the
     * child elements after the drag
     *
     * @method handleDrag
     *
     * @param {number} deltaX - change in x
     * @param {string} id - Identifier used to
     *  distinguish between the child elements
     *
     * @return {void}
     */

  }, {
    key: 'onItemDrag',
    value: function onItemDrag(deltaX, id) {
      var startX;
      var endX;

      if (id === 'start') {
        startX = deltaX + this.state.startLocation;
        endX = this.state.endLocation;
        if (startX < 0 || startX > endX) {
          return;
        }
        if (startX + 2 * this.props.pinWidth >= endX) {
          endX = startX + this.props.pinWidth;
        }
      } else if (id === 'end') {
        startX = this.state.startLocation;
        endX = deltaX + this.state.endLocation;
        if (endX > this.state.max || startX > endX) {
          return;
        }
        if (startX + 2 * this.props.pinWidth >= endX) {
          startX = endX - this.props.pinWidth;
        }
      } else {
        startX = deltaX + this.state.startLocation;
        endX = deltaX + this.state.endLocation;
        if (endX >= this.state.max || startX < 0) {
          return;
        }
      }
      this.props.onDrag(startX, endX);

      this.setState({
        startLocation: startX,
        endLocation: endX
      });
    }

    /*
     * Send callback with new locations on
     * Drag Stop
     *
     * @method onDragStop
     *
     * @return {void}
     */

  }, {
    key: 'onDragStop',
    value: function onDragStop() {
      this.props.onDrag(this.state.startLocation, this.state.endLocation);
    }
  }, {
    key: 'onRangeClick',
    value: function onRangeClick(d) {
      this.props.onRangeClick(d.nativeEvent);
    }
    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'svg',
        { id: 'wv-timeline-range-selector', className: 'wv-timeline-range-selector' },
        _react2.default.createElement(_wvTimelineDraggerrange2.default, {
          width: this.props.pinWidth,
          endLocation: this.state.endLocation,
          opacity: this.props.rangeOpacity,
          color: this.props.rangeColor,
          height: this.props.height,
          startLocation: this.state.startLocation + this.props.pinWidth,
          onClick: this.onRangeClick.bind(this),
          max: this.state.max,
          id: 'range' }),
        _react2.default.createElement(_wvTimelineDragger2.default, {
          position: this.state.startLocation,
          color: this.props.startColor,
          width: this.props.pinWidth,
          height: this.props.height,
          onDrag: this.onItemDrag.bind(this),
          onStop: this.onDragStop.bind(this),
          max: this.state.max,
          triangleColor: this.props.startTriangleColor,
          first: true,
          id: 'start' }),
        _react2.default.createElement(_wvTimelineDragger2.default, {
          max: this.state.max,
          position: this.state.endLocation,
          color: this.props.endColor,
          width: this.props.pinWidth,
          height: this.props.height,
          first: false,
          onDrag: this.onItemDrag.bind(this),
          onStop: this.onDragStop.bind(this),
          triangleColor: this.props.endTriangleColor,
          id: 'end' })
      );
    }
  }]);

  return TimelineRangeSelector;
}(_react2.default.Component);

exports.default = TimelineRangeSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./wv.timeline.dragger.js":19,"./wv.timeline.draggerrange.js":20}],22:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var Tooltip = function (_React$Component) {
  _inherits(Tooltip, _React$Component);

  function Tooltip(props) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props));

    _this.state = {
      hovered: false
    };
    return _this;
  }

  _createClass(Tooltip, [{
    key: "mouseOver",
    value: function mouseOver() {
      this.setState({
        hovered: true
      });
    }
  }, {
    key: "mouseOut",
    value: function mouseOut() {
      this.setState({
        hovered: false
      });
    }
  }, {
    key: "onClick",
    value: function onClick(str) {
      this.props.onClick(str);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        "div",
        {
          onMouseEnter: this.mouseOver.bind(this),
          onMouseLeave: this.mouseOut.bind(this),
          className: "wv-tooltip-case" },
        _react2.default.createElement(
          "span",
          null,
          this.props.text
        ),
        _react2.default.createElement(
          "div",
          { className: "wv-tooltip", style: this.state.hovered ? { visibility: 'visible' } : {} },
          _react2.default.createElement(
            "ul",
            null,
            this.props.dataArray.map(function (dataEl, i) {
              return _react2.default.createElement(
                "li",
                { key: 'tooltip-' + dataEl + '-' + i, id: dataEl, onClick: _this2.onClick.bind(_this2, dataEl) },
                dataEl
              );
            })
          )
        )
      );
    }
  }]);

  return Tooltip;
}(_react2.default.Component);

exports.default = Tooltip;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * NASA Worldview
 *
 * This code was originally developed at NASA/Goddard Space Flight Center for
 * the Earth Science Data and Information System (ESDIS) project.
 *
 * Copyright (C) 2013 - 2016 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 */

/* global ga:true */

exports.default = {
  /**
   * Initialize GA tracking if tracking
   * code is present
   *
   * @func init
   * @static
   *
   * @param Category {id} GA tracking code
   *
   * @return {void}
   */
  init: function init(id) {
    if (id) {
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments);
        }, i[r].l = 1 * new Date();
        a = s.createElement(o), m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
      ga('create', id, 'auto');
      ga('send', 'pageview');
    }
  },

  /**
   * @func TrackEventGA
   * @static
   *
   * @param Category {string} Event group name
   * @param Action {string} Type of user interaction
   * @param Label {string} Optional string for better
   *     verification of the event
   * @param Value {number} Optional number to associate
   *     with event
   *
    * @return {void}
   */
  event: function event(category, action, label, value) {
    if (typeof ga !== "undefined") {
      ga('send', 'event', category, action, label, value);
    }
  }
};

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * NASA Worldview
 *
 * This code was originally developed at NASA/Goddard Space Flight Center for
 * the Earth Science Data and Information System (ESDIS) project.
 *
 * Copyright (C) 2013 - 2016 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 *
 * Licensed under the NASA Open Source Agreement, Version 1.3
 * http://opensource.gsfc.nasa.gov/nosa.php
 */

var Utils = function () {
  /*
   * @constructor
   */
  function Utils() {
    _classCallCheck(this, Utils);

    this.monthStringArray = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
  }
  /**
   * Gets the current day. Use this instead of the Date methods to allow
   * debugging alternate "now" times.
   *
   * @method today
   * @static
   * @return {Date} The current time with the UTC hours, minutes, and seconds
   * fields set to zero or an overriden value.
   */


  _createClass(Utils, [{
    key: "today",
    value: function today() {
      return this.clearTimeUTC(this.now());
    }

    /**
     * Sets a date to UTC midnight.
     *
     * @method clearTimeUTC
     * @static
     * @param date {Date} date to set the UTC hours, minutes, and seconds
     * to zero.
     * @return {Date} the date object
     */

  }, {
    key: "clearTimeUTC",
    value: function clearTimeUTC(date) {
      date.setUTCHours(0);
      date.setUTCMinutes(0);
      date.setUTCSeconds(0);
      date.setUTCMilliseconds(0);
      return date;
    }
  }, {
    key: "clamp",
    value: function clamp(val, min, max) {
      if (val < min) {
        return min;
      }
      if (val > max) {
        return max;
      }
      return val;
    }
  }, {
    key: "daysInMonth",
    value: function daysInMonth(d) {
      var y;
      var m;
      if (d.getUTCFullYear) {
        y = d.getUTCFullYear();
        m = d.getUTCMonth();
      } else {
        y = d.year;
        m = d.month;
      }
      var lastDay = new Date(Date.UTC(y, m + 1, 0));
      return lastDay.getUTCDate();
    }
    /**
     * Gets the current time. Use this instead of the Date methods to allow
     * debugging alternate "now" times.
     *
     * @method now
     * @static
     * @return {Date} The current time or an overriden value.
     */

  }, {
    key: "now",
    value: function now() {
      return new Date();
    }
  }, {
    key: "stringInArray",
    value: function stringInArray(arra, value) {
      for (var i = 0, len = arra.length; i < len; i++) {
        if (arra[i] === value) {
          return i;
        }
      }
      return false;
    }
  }, {
    key: "minDate",
    value: function minDate() {
      return new Date(Date.UTC(1000, 0, 1));
    }
  }, {
    key: "maxDate",
    value: function maxDate() {
      return new Date(Date.UTC(3000, 11, 31));
    }
    /**
     * Parses a UTC ISO 8601 date.
     *
     * @method parseDateUTC
     * @static
     * @param str {string} Date to parse in the form of ``YYYY-MM-DD``.
     * @return {Date} converted string as a date object, throws an exception if
     * the string is invalid
     */
    // NOTE: Older Safari doesn't like Date.parse

  }, {
    key: "parseDateUTC",
    value: function parseDateUTC(dateAsString) {
      var dateTimeArr = dateAsString.split(/T/);
      var yyyymmdd = dateTimeArr[0].split('-');

      // Parse elements of date and time
      var year = yyyymmdd[0];
      var month = yyyymmdd[1] - 1;
      var day = yyyymmdd[2];

      var hour = 0;
      var minute = 0;
      var second = 0;
      var millisecond = 0;

      // Use default of midnight if time is not specified
      if (dateTimeArr.length > 1) {
        var hhmmss = dateTimeArr[1].split(/[:\.Z]/);
        hour = hhmmss[0] || 0;
        minute = hhmmss[1] || 0;
        second = hhmmss[2] || 0;
        millisecond = hhmmss[3] || 0;
      }
      var date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      if (isNaN(date.getTime())) {
        throw new Error('Invalid date: ' + dateAsString);
      }
      return date;
    }
  }, {
    key: "repeat",
    value: function repeat(value, length) {
      var result = "";
      for (var i = 0; i < length; i++) {
        result += value;
      }
      return result;
    }
  }, {
    key: "roll",
    value: function roll(val, min, max) {
      if (val < min) {
        return max - (min - val) + 1;
      }
      if (val > max) {
        return min + (val - max) - 1;
      }
      return val;
    }
  }, {
    key: "rollRange",
    value: function rollRange(date, interval, minDate, maxDate) {
      var y = date.getUTCFullYear();
      var m = date.getUTCMonth();
      var first, last;
      switch (interval) {
        case "day":
          var firstDay = new Date(Date.UTC(y, m, 1));
          var lastDay = new Date(Date.UTC(y, m, this.daysInMonth(date)));
          first = new Date(Math.max(firstDay, minDate)).getUTCDate();
          last = new Date(Math.min(lastDay, maxDate)).getUTCDate();
          break;
        case "month":
          var firstMonth = new Date(Date.UTC(y, 0, 1));
          var lastMonth = new Date(Date.UTC(y, 11, 31));
          first = new Date(Math.max(firstMonth, minDate)).getUTCMonth();
          last = new Date(Math.min(lastMonth, maxDate)).getUTCMonth();
          break;
        case "year":
          var firstYear = this.minDate();
          var lastYear = this.maxDate();
          first = new Date(Math.max(firstYear, minDate)).getUTCFullYear();
          last = new Date(Math.min(lastYear, maxDate)).getUTCFullYear();
          break;
      }
      return { first: first, last: last };
    }
  }, {
    key: "rollDate",
    value: function rollDate(date, interval, amount, minDate, maxDate) {
      minDate = minDate || this.minDate();
      maxDate = maxDate || this.maxDate();
      var range = this.rollRange(date, interval, minDate, maxDate);
      var min = range.first;
      var max = range.last;
      var day = date.getUTCDate();
      var month = date.getUTCMonth();
      var year = date.getUTCFullYear();
      switch (interval) {
        case "day":
          day = this.roll(day + amount, min, max);
          break;
        case "month":
          month = this.roll(month + amount, min, max);
          break;
        case "year":
          year = this.roll(year + amount, min, max);
          break;
        default:
          throw new Error("[rollDate] Invalid interval: " + interval);
      }
      var daysInMonth = this.daysInMonth({ year: year, month: month });
      if (day > daysInMonth) {
        day = daysInMonth;
      }
      var newDate = new Date(Date.UTC(year, month, day));
      newDate = new Date(this.clamp(newDate, minDate, maxDate));
      return newDate;
    }
  }, {
    key: "pad",
    value: function pad(value, width, padding) {
      value = "" + value;
      if (value.length < width) {
        var add = width - value.length;
        value = this.repeat(padding, add) + value;
      }
      return value;
    }
  }]);

  return Utils;
}();

exports.default = Utils;

},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wvAnimationWidget = require('./components/animationwidget/wv.animation.widget.js');

Object.defineProperty(exports, 'AnimationWidget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvAnimationWidget).default;
  }
});

var _wvTimelineRangeselection = require('./components/rangeselection/wv.timeline.rangeselection.js');

Object.defineProperty(exports, 'RangeSelector', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvTimelineRangeselection).default;
  }
});

var _wvDateSelector = require('./components/dateSelector/wv.dateSelector.js');

Object.defineProperty(exports, 'DateSelector', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvDateSelector).default;
  }
});

var _wvTooltip = require('./components/tooltip/wv.tooltip.js');

Object.defineProperty(exports, 'ToolTip', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvTooltip).default;
  }
});

var _wvUtils = require('./components/util/wv.utils.js');

Object.defineProperty(exports, 'Utils', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvUtils).default;
  }
});

var _wvGoogleAnalytics = require('./components/util/wv.googleAnalytics.js');

Object.defineProperty(exports, 'GA', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvGoogleAnalytics).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./components/animationwidget/wv.animation.widget.js":12,"./components/dateSelector/wv.dateSelector.js":15,"./components/rangeselection/wv.timeline.rangeselection.js":21,"./components/tooltip/wv.tooltip.js":22,"./components/util/wv.googleAnalytics.js":23,"./components/util/wv.utils.js":24}]},{},[25])(25)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2Rpc3QvcmVhY3QtZHJhZ2dhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL0lucHV0UmFuZ2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtcmFuZ2UvbGliL0lucHV0UmFuZ2UvTGFiZWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtcmFuZ2UvbGliL0lucHV0UmFuZ2UvU2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL1RyYWNrLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL2RlZmF1bHRDbGFzc05hbWVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL3Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1pbnB1dC1yYW5nZS9saWIvSW5wdXRSYW5nZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL3ZhbHVlVHJhbnNmb3JtZXIuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5hbmltYXRpb24ud2lkZ2V0LmhlYWRlci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvYW5pbWF0aW9ud2lkZ2V0L3d2LmFuaW1hdGlvbi53aWRnZXQuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5sb29wYnV0dG9uLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy9hbmltYXRpb253aWRnZXQvd3YucGxheWJ1dHRvbi5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZVNlbGVjdG9yL3d2LmRhdGVTZWxlY3Rvci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZVNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5pbnB1dC5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZXNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5pbnB1dC5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZXNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUuZHJhZ2dlci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUuZHJhZ2dlcnJhbmdlLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy9yYW5nZXNlbGVjdGlvbi93di50aW1lbGluZS5yYW5nZXNlbGVjdGlvbi5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvdG9vbHRpcC93di50b29sdGlwLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy91dGlsL3d2Lmdvb2dsZUFuYWx5dGljcy5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvdXRpbC93di51dGlscy5qcyIsInNyYy9zY3JpcHRzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdGtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3B3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4S0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFmQTs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7SUFPcUIsZ0I7OztBQUNuQiw0QkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsK0hBQ1gsS0FEVztBQUVsQjs7Ozs2QkFDUTtBQUNQLGFBQ0U7QUFBQTtBQUFBLFVBQUssV0FBVSw0QkFBZjtBQUNHLHlCQURIO0FBRUUsc0RBQVMsTUFBTSxLQUFLLEtBQUwsQ0FBVyxJQUExQixFQUFnQyxTQUFTLEtBQUssS0FBTCxDQUFXLE9BQXBELEVBQTZELFdBQVcsS0FBSyxLQUFMLENBQVcsZ0JBQW5GLEdBRkY7QUFHRztBQUhILE9BREY7QUFPRDs7OztFQVoyQyxnQkFBTSxTOztrQkFBL0IsZ0I7Ozs7Ozs7Ozs7Ozs7O0FDVnJCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQXBCQTs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7SUFPcUIsZTs7O0FBQ25CLDJCQUFZLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSUFDWCxLQURXOztBQUVqQixVQUFLLEtBQUwsR0FBYztBQUNaLGFBQU8sTUFBTSxXQUREO0FBRVosZUFBUyxNQUFNLE9BRkg7QUFHWixpQkFBVyxNQUFNLFNBSEw7QUFJWixlQUFTLE1BQU0sT0FKSDtBQUtaLGNBQVEsTUFBTSxNQUxGO0FBTVosc0JBQWdCLE1BQU0sY0FOVjtBQU9aLGlCQUFXLE1BQU07O0FBUEwsS0FBZDtBQUZpQjtBQVlsQjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBYVEsUyxFQUFXLEssRUFBTztBQUN4QixXQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLEtBQW5CO0FBQ0EsV0FBSyxRQUFMLENBQWM7QUFDWixlQUFPO0FBREssT0FBZDtBQUdEOztBQUVEOzs7Ozs7Ozs7OzsyQkFRTztBQUNMLFdBQUssS0FBTCxDQUFXLFVBQVg7QUFDQSxXQUFLLFFBQUwsQ0FBYztBQUNaLGlCQUFTO0FBREcsT0FBZDtBQUdEOzs7NEJBQ087QUFDTixXQUFLLEtBQUwsQ0FBVyxXQUFYO0FBQ0EsV0FBSyxRQUFMLENBQWM7QUFDWixpQkFBUztBQURHLE9BQWQ7QUFHRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7OzZCQWFTO0FBQ1AsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFHLEtBQUssS0FBTCxDQUFXLE9BQWQsRUFBdUI7QUFDckIsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxXQUFLLFFBQUwsQ0FBYztBQUNaLGlCQUFTO0FBREcsT0FBZDtBQUdBLFdBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsSUFBdEI7QUFDRDs7O2lDQUNZLEUsRUFBSSxJLEVBQU07QUFDckIsVUFBRyxPQUFPLE9BQVYsRUFBbUI7QUFDakIsYUFBSyxRQUFMLENBQWM7QUFDWixxQkFBVztBQURDLFNBQWQ7QUFHQSxhQUFLLEtBQUwsQ0FBVyxZQUFYLENBQ0UsSUFERixFQUVFLEtBQUssS0FBTCxDQUFXLE9BRmI7QUFJRCxPQVJELE1BUU87QUFDTCxhQUFLLFFBQUwsQ0FBYztBQUNaLG1CQUFTO0FBREcsU0FBZDtBQUdBLGFBQUssS0FBTCxDQUFXLFlBQVgsQ0FDRSxLQUFLLEtBQUwsQ0FBVyxTQURiLEVBRUUsSUFGRjtBQUlEO0FBQ0Y7Ozs2QkFDUTtBQUNQLGFBQ0U7QUFBQTtBQUFBLFVBQUssSUFBRyxxQkFBUixFQUE4QixXQUFVLHFCQUF4QztBQUNFO0FBQ0UsZ0JBQU0sS0FBSyxLQUFMLENBQVcsU0FEbkI7QUFFRSw0QkFBa0IsS0FBSyxLQUFMLENBQVcsY0FGL0I7QUFHRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxZQUh0QixHQURGO0FBTUUsc0RBQVksU0FBUyxLQUFLLEtBQUwsQ0FBVyxPQUFoQyxFQUF5QyxNQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUFmLENBQS9DLEVBQXFFLE9BQU8sS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixJQUFoQixDQUE1RSxHQU5GO0FBT0Usc0RBQVksU0FBUyxLQUFLLEtBQUwsQ0FBVyxPQUFoQyxFQUF5QyxRQUFRLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FBakQsR0FQRjtBQVFFO0FBQUE7QUFBQSxZQUFLLFdBQVUsZ0JBQWY7QUFDRSxxRUFBWSxVQUFVLEVBQXRCLEVBQTBCLFVBQVUsQ0FBcEMsRUFBdUMsT0FBTyxLQUFLLEtBQUwsQ0FBVyxLQUF6RCxFQUFnRSxVQUFVLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FBMUUsR0FERjtBQUVFO0FBQUE7QUFBQSxjQUFNLFdBQVUsaUJBQWhCO0FBQW1DLGlCQUFLLEtBQUwsQ0FBVztBQUE5QztBQUZGLFNBUkY7QUFhRTtBQUFBO0FBQUEsWUFBRyxNQUFLLHVCQUFSO0FBQ0UsbUJBQU0scUJBRFI7QUFFRSx1QkFBVSxjQUZaO0FBR0UscUJBQVMsS0FBSyxLQUFMLENBQVc7QUFIdEI7QUFLRSwrQ0FBRyxXQUFVLDZDQUFiO0FBTEYsU0FiRjtBQW9CRTtBQUFBO0FBQUEsWUFBSyxXQUFVLG9CQUFmO0FBQ0U7QUFDRSxtQkFBTSxLQURSO0FBRUUsb0JBQU8sSUFGVDtBQUdFLGtCQUFNLEtBQUssS0FBTCxDQUFXLFNBSG5CO0FBSUUsZ0JBQUcsT0FKTDtBQUtFLDBCQUFjLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUxoQjtBQU1FLHFCQUFTLEtBQUssS0FBTCxDQUFXLE9BTnRCO0FBT0UscUJBQVMsS0FBSyxLQUFMLENBQVc7QUFQdEIsWUFERjtBQVVFO0FBQUE7QUFBQSxjQUFLLFdBQVUsWUFBZjtBQUFBO0FBQUEsV0FWRjtBQVdFO0FBQ0UsbUJBQU0sS0FEUjtBQUVFLG9CQUFPLElBRlQ7QUFHRSxrQkFBTSxLQUFLLEtBQUwsQ0FBVyxPQUhuQjtBQUlFLGdCQUFHLEtBSkw7QUFLRSwwQkFBYyxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FMaEI7QUFNRSxxQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQU50QjtBQU9FLHFCQUFTLEtBQUssS0FBTCxDQUFXO0FBUHRCO0FBWEYsU0FwQkY7QUF5Q0U7QUFDRSxxQkFBVSxzQkFEWjtBQUVFLG1CQUFTLEtBQUssS0FBTCxDQUFXO0FBRnRCO0FBekNGLE9BREY7QUFpREQ7Ozs7RUFuSjBDLGdCQUFNLFM7O2tCQUE5QixlOzs7Ozs7Ozs7Ozs7OztBQ2pCckI7Ozs7Ozs7Ozs7K2VBZEE7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7O0lBT3FCLFU7OztBQUNuQixzQkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsbUhBQ1gsS0FEVztBQUVsQjs7Ozs2QkFDUTtBQUNQLGFBQ0k7QUFBQTtBQUFBLFVBQUcsTUFBSyx1QkFBUjtBQUNFLGlCQUFPLEtBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUIsV0FBckIsR0FBbUMsWUFENUM7QUFFRSxxQkFBVyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCLHVDQUFyQixHQUErRCxnQ0FGNUU7QUFHRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVztBQUh0QjtBQUtFLDZDQUFHLFdBQVUsd0NBQWI7QUFMRixPQURKO0FBU0Q7Ozs7RUFkcUMsZ0JBQU0sUzs7a0JBQXpCLFU7Ozs7Ozs7Ozs7Ozs7O0FDVHJCOzs7Ozs7Ozs7OytlQWRBOzs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7OztJQU9xQixVOzs7QUFDbkIsc0JBQVksS0FBWixFQUFtQjtBQUFBOztBQUFBLG1IQUNYLEtBRFc7QUFFbEI7Ozs7NkJBQ1E7QUFDUCxhQUNFO0FBQUE7QUFBQSxVQUFHLE1BQUssdUJBQVIsRUFBZ0MsT0FBTyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCLGFBQXJCLEdBQXFDLFlBQTVFO0FBQ0UscUJBQVUsZ0NBRFo7QUFFRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCLEtBQUssS0FBTCxDQUFXLEtBQWhDLEdBQXdDLEtBQUssS0FBTCxDQUFXO0FBRjlEO0FBSUUsNkNBQUcsV0FBVyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCLHNDQUFyQixHQUE2RCxxQ0FBM0U7QUFKRixPQURGO0FBUUQ7Ozs7RUFicUMsZ0JBQU0sUzs7a0JBQXpCLFU7Ozs7Ozs7Ozs7Ozs7O0FDVHJCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFoQkE7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLElBQU0sT0FBTyxrQkFBYjs7QUFFQTs7Ozs7Ozs7SUFPcUIsWTs7O0FBRW5COzs7QUFHQSx3QkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsNEhBQ1gsS0FEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWE7QUFDWCxZQUFNLE1BQU0sSUFERDtBQUVYLGVBQVMsTUFBTSxPQUZKO0FBR1gsZUFBUyxNQUFNLE9BSEo7QUFJWCxXQUFLO0FBSk0sS0FBYjtBQUZpQjtBQVFsQjs7Ozs4Q0FDeUIsSyxFQUFPO0FBQy9CLFdBQUssUUFBTCxDQUFjO0FBQ1osY0FBTSxNQUFNLElBREE7QUFFWixpQkFBUyxNQUFNLE9BRkg7QUFHWixpQkFBUyxNQUFNO0FBSEgsT0FBZDtBQUtEOzs7MkJBQ007QUFDTCxXQUFLLFFBQUwsQ0FBYyxFQUFDLEtBQUssSUFBTixFQUFkO0FBQ0Q7Ozs0QkFDTyxLLEVBQU87QUFDYixVQUFJLE9BQUo7QUFDQSxVQUFHLFFBQVEsQ0FBWCxFQUFjO0FBQ1osa0JBQVUsUUFBUSxDQUFsQjtBQUNELE9BRkQsTUFFTztBQUNMLGtCQUFVLENBQVY7QUFDRDtBQUNELFdBQUssUUFBTCxDQUFjO0FBQ1osYUFBSztBQURPLE9BQWQ7QUFHRDs7OytCQUNVLEksRUFBTTtBQUNmLFdBQUssUUFBTCxDQUFjO0FBQ1osY0FBTTtBQURNLE9BQWQ7QUFHQSxXQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXdCLEtBQUssS0FBTCxDQUFXLEVBQW5DLEVBQXVDLElBQXZDO0FBQ0Q7Ozs2QkFDUTtBQUNQLGFBQ0U7QUFBQTtBQUFBLFVBQUssV0FBVSx5QkFBZjtBQUNFLGtFQUFpQixXQUFXLElBQUksSUFBSixDQUFTLElBQVQsQ0FBNUI7QUFDRSxpQkFBTyxJQUFJLElBQUosRUFEVDtBQUVFLGdCQUFNLEtBQUssS0FBTCxDQUFXLElBRm5CO0FBR0UsaUJBQU8sS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixjQUFoQixFQUhUO0FBSUUsZ0JBQUssTUFKUDtBQUtFLGtCQUFRLEtBQUssS0FBTCxDQUFXLE1BTHJCO0FBTUUsaUJBQU8sS0FBSyxLQUFMLENBQVcsS0FOcEI7QUFPRSxzQkFBWSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsSUFBckIsQ0FQZDtBQVFFLG9CQUFVLENBUlo7QUFTRSxtQkFBVSxLQUFLLEtBQUwsQ0FBVyxHQUFYLElBQWtCLENBVDlCO0FBVUUsbUJBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixJQUFsQixDQVZYO0FBV0UsbUJBQVMsS0FBSyxLQUFMLENBQVcsT0FYdEI7QUFZRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQVp0QjtBQWFFLGdCQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUFmO0FBYlIsVUFERjtBQWdCRTtBQUNFLHFCQUFXLElBQUksSUFBSixDQUFTLElBQVQsQ0FEYjtBQUVFLGlCQUFPLElBQUksSUFBSixFQUZULEVBRXFCLE1BQU0sS0FBSyxLQUFMLENBQVcsSUFGdEM7QUFHRSxnQkFBSyxPQUhQLEVBR2UsUUFBUSxLQUFLLEtBQUwsQ0FBVyxNQUhsQztBQUlFLGlCQUFPLEtBQUssS0FBTCxDQUFXLEtBSnBCO0FBS0Usc0JBQVksS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBTGQ7QUFNRSxpQkFBTyxLQUFLLGdCQUFMLENBQXNCLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsV0FBaEIsRUFBdEIsQ0FOVDtBQU9FLG9CQUFVLENBUFo7QUFRRSxtQkFBVSxLQUFLLEtBQUwsQ0FBVyxHQUFYLElBQWtCLENBUjlCO0FBU0UsbUJBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixJQUFsQixDQVRYO0FBVUUsbUJBQVMsS0FBSyxLQUFMLENBQVcsT0FWdEI7QUFXRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQVh0QjtBQVlFLGdCQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUFmO0FBWlIsVUFoQkY7QUE4QkU7QUFDRSxxQkFBVyxJQUFJLElBQUosQ0FBUyxJQUFULENBRGI7QUFFRSxpQkFBTyxJQUFJLElBQUosRUFGVDtBQUdFLGdCQUFNLEtBQUssS0FBTCxDQUFXLElBSG5CO0FBSUUsZ0JBQUssS0FKUDtBQUtFLGtCQUFRLEtBQUssS0FBTCxDQUFXLE1BTHJCO0FBTUUsaUJBQU8sS0FBSyxLQUFMLENBQVcsS0FOcEI7QUFPRSxzQkFBWSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsSUFBckIsQ0FQZDtBQVFFLGlCQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsVUFBaEIsRUFBVCxFQUF1QyxDQUF2QyxFQUEwQyxHQUExQyxDQVJUO0FBU0Usb0JBQVUsQ0FUWjtBQVVFLG1CQUFVLEtBQUssS0FBTCxDQUFXLEdBQVgsSUFBa0IsQ0FWOUI7QUFXRSxtQkFBUyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLElBQWxCLENBWFg7QUFZRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQVp0QjtBQWFFLG1CQUFTLEtBQUssS0FBTCxDQUFXLE9BYnRCO0FBY0UsZ0JBQU0sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLElBQWY7QUFkUjtBQTlCRixPQURGO0FBaUREOzs7O0VBM0Z1QyxnQkFBTSxTOztrQkFBM0IsWTs7Ozs7Ozs7Ozs7Ozs7QUNickI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWhCQTs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsSUFBTSxPQUFPLGtCQUFiOztBQUVBOzs7Ozs7OztJQU9xQixlOzs7QUFFbkI7OztBQUdBLDJCQUFZLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSUFDWCxLQURXOztBQUVqQixVQUFLLEtBQUwsR0FBYTtBQUNYLGFBQU8sTUFBSyxLQUFMLENBQVcsS0FEUDtBQUVYLGFBQU87QUFGSSxLQUFiO0FBRmlCO0FBTWxCOzs7O3lDQUNvQjtBQUNuQixVQUFHLEtBQUssS0FBTCxDQUFXLE9BQWQsRUFBdUI7QUFDckIsMkJBQVMsV0FBVCxDQUFxQixLQUFLLElBQUwsQ0FBVSxXQUFXLEtBQUssS0FBTCxDQUFXLFFBQWhDLENBQXJCLEVBQWdFLEtBQWhFO0FBQ0Q7QUFDRjs7O3lDQUNvQjtBQUNuQixVQUFJLElBQUo7QUFDQSxVQUFJLElBQUo7QUFDQSxhQUFPLEtBQUssS0FBTCxDQUFXLElBQWxCO0FBQ0EsVUFBRyxTQUFTLE1BQVosRUFBb0I7QUFDbEIsZUFBTyxHQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUcsU0FBUyxLQUFaLEVBQW1CO0FBQ3hCLGVBQU8sQ0FBUDtBQUNELE9BRk0sTUFFQTtBQUNMLGVBQU8sQ0FBUDtBQUNEO0FBQ0QsV0FBSyxJQUFMLEdBQVksSUFBWjtBQUNEOzs7OENBQ3lCLEssRUFBTztBQUMvQixXQUFLLFFBQUwsQ0FBYyxFQUFDLE9BQU8sTUFBTSxLQUFkLEVBQWQ7QUFDRDs7OytCQUNVLEMsRUFBRztBQUNaLFVBQUksS0FBSyxFQUFFLE9BQVg7QUFDQSxVQUFHLE9BQU8sQ0FBUCxJQUFZO0FBQ2IsYUFBTyxFQURULEVBQ2E7QUFBRTtBQUNiLFVBQUUsY0FBRjtBQUNBLFVBQUUsZUFBRjtBQUNEO0FBQ0Y7Ozs0QkFDTyxDLEVBQUc7QUFDVCxVQUFJLFVBQVUsRUFBRSxPQUFoQjtBQUNBLFVBQUksUUFBUSxFQUFFLE1BQUYsQ0FBUyxLQUFyQjtBQUNBLFVBQUksT0FBSjtBQUNBLFVBQUksVUFBVyxXQUFXLEVBQVgsSUFBaUIsV0FBVyxDQUEzQztBQUNBLFVBQUcsWUFBWSxFQUFmLEVBQW1CO0FBQUU7QUFDbkIsVUFBRSxjQUFGO0FBQ0EsYUFBSyxTQUFMO0FBQ0E7QUFDRDtBQUNELFVBQUcsWUFBWSxFQUFmLEVBQW1CO0FBQUM7QUFDbEIsVUFBRSxjQUFGO0FBQ0EsYUFBSyxXQUFMO0FBQ0E7QUFDRDtBQUNELFVBQUksRUFBRSxJQUFGLElBQVUsVUFBVixJQUF3QixPQUE1QixFQUFxQztBQUNuQyxZQUFHLEtBQUssS0FBTCxDQUFXLElBQVgsSUFBbUIsTUFBbkIsSUFBNkIsS0FBSyxLQUFMLENBQVcsSUFBWCxJQUFtQixLQUFuRCxFQUEwRDtBQUN4RCxjQUFHLEVBQUcsV0FBVyxFQUFYLElBQWlCLFdBQVcsRUFBN0IsSUFDRixPQURFLElBRUYsV0FBVyxDQUZYLENBQUgsRUFFa0I7QUFDaEI7QUFDRDtBQUNGO0FBQ0QsZ0JBQU8sS0FBSyxLQUFMLENBQVcsSUFBbEI7QUFDRSxlQUFLLE1BQUw7QUFDRSxzQkFBVSxLQUFLLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBVjtBQUNBO0FBQ0YsZUFBSyxLQUFMO0FBQ0Usc0JBQVUsS0FBSyxhQUFMLENBQW1CLEtBQW5CLENBQVY7QUFDQTtBQUNGLGVBQUssT0FBTDtBQUNFLHNCQUFVLEtBQUssZUFBTCxDQUFxQixLQUFyQixDQUFWO0FBQ0E7QUFUSjtBQVdBLFlBQUcsT0FBSCxFQUFZO0FBQ1YsZUFBSyxLQUFMLENBQVcsVUFBWCxDQUFzQixPQUF0QjtBQUNBLGNBQUcsT0FBSCxFQUFZO0FBQUU7QUFDWixpQkFBSyxPQUFMO0FBQ0Q7QUFDRixTQUxELE1BS08sSUFBRyxPQUFILEVBQVk7QUFDakIsZUFBSyxRQUFMLENBQWM7QUFDWixtQkFBTztBQURLLFdBQWQ7QUFHRDtBQUNGO0FBQ0Y7OztnQ0FDVztBQUNWLFdBQUssUUFBTCxDQUFjLENBQWQ7QUFDQSxXQUFLLFFBQUwsQ0FBYztBQUNaLGVBQU87QUFESyxPQUFkO0FBSUQ7OztrQ0FDYTtBQUNaLFdBQUssUUFBTCxDQUFjLENBQUMsQ0FBZjtBQUNBLFdBQUssUUFBTCxDQUFjO0FBQ1osZUFBTztBQURLLE9BQWQ7QUFHRDs7O21DQUNjLEssRUFBTztBQUNwQixVQUFJLE9BQUo7QUFDQSxVQUFJLFFBQVEsSUFBVCxJQUFtQixRQUFRLElBQTlCLEVBQXFDO0FBQ25DLGtCQUFVLElBQUksSUFBSixDQUFVLElBQUksSUFBSixDQUFTLEtBQUssS0FBTCxDQUFXLElBQXBCLENBQUQsQ0FBNEIsY0FBNUIsQ0FBMkMsS0FBM0MsQ0FBVCxDQUFWO0FBQ0EsZUFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7OztrQ0FDYSxLLEVBQU87QUFDbkIsVUFBSSxPQUFKO0FBQ0EsVUFBSSxPQUFKO0FBQ0EsVUFBSSxjQUFjLEtBQUssS0FBTCxDQUFXLElBQTdCOztBQUVBLGdCQUFVLElBQUksSUFBSixDQUFTLFlBQVksT0FBWixFQUFULEVBQWdDLFlBQVksUUFBWixLQUF5QixDQUF6RCxFQUE0RCxDQUE1RCxFQUErRCxPQUEvRCxFQUFWOztBQUVBLFVBQUcsUUFBUSxDQUFSLElBQWEsU0FBUyxPQUF6QixFQUFrQztBQUNoQyxrQkFBVSxJQUFJLElBQUosQ0FBVSxJQUFJLElBQUosQ0FBUyxXQUFULENBQUQsQ0FBd0IsVUFBeEIsQ0FBbUMsS0FBbkMsQ0FBVCxDQUFWO0FBQ0EsZUFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBUDtBQUNEO0FBRUY7Ozs2QkFDUSxHLEVBQUs7QUFDWixVQUFJLFVBQVUsS0FBSyxRQUFMLENBQ1osS0FBSyxLQUFMLENBQVcsSUFEQyxFQUVaLEtBQUssS0FBTCxDQUFXLElBRkMsRUFHWixHQUhZLEVBSVosS0FBSyxLQUFMLENBQVcsT0FKQyxFQUtaLEtBQUssS0FBTCxDQUFXLE9BTEMsQ0FBZDtBQU9BLFdBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsT0FBdEI7QUFDRDs7O29DQUVlLEssRUFBTztBQUNyQixVQUFJLE9BQUo7QUFDQSxVQUFLLENBQUMsTUFBTSxLQUFOLENBQUYsSUFBbUIsUUFBUSxFQUEzQixJQUFpQyxRQUFRLENBQTdDLEVBQWdEO0FBQzlDLGtCQUFVLElBQUksSUFBSixDQUFVLElBQUksSUFBSixDQUFTLEtBQUssS0FBTCxDQUFXLElBQXBCLENBQUQsQ0FBNEIsV0FBNUIsQ0FBd0MsUUFBUSxDQUFoRCxDQUFULENBQVY7QUFDQSxZQUFHLE9BQUgsRUFBWTtBQUNWLGVBQUssUUFBTCxDQUFjO0FBQ1osbUJBQU8sS0FBSyxnQkFBTCxDQUFzQixRQUFNLENBQTVCO0FBREssV0FBZDtBQUdBLGlCQUFPLEtBQUssWUFBTCxDQUFrQixPQUFsQixDQUFQO0FBQ0Q7QUFDRixPQVJELE1BUU87QUFDTCxZQUFJLGtCQUFKO0FBQ0Esb0JBQVksS0FBSyxhQUFMLENBQW1CLEtBQUssZ0JBQXhCLEVBQTBDLEtBQTFDLENBQVo7QUFDQSxZQUFHLGNBQWMsS0FBakIsRUFBd0I7QUFDdEIsb0JBQVUsSUFBSSxJQUFKLENBQVUsSUFBSSxJQUFKLENBQVMsS0FBSyxLQUFMLENBQVcsSUFBcEIsQ0FBRCxDQUE0QixXQUE1QixDQUF3QyxTQUF4QyxDQUFULENBQVY7QUFDQSxpQkFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBUDtBQUNELFNBSEQsTUFHTztBQUNMLGlCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7OzsyQkFDTTtBQUNMLFdBQUssUUFBTCxDQUFjO0FBQ1osZUFBTyxLQUFLLEtBQUwsQ0FBVyxLQUROO0FBRVosZUFBTztBQUZLLE9BQWQ7O0FBS0EsV0FBSyxLQUFMLENBQVcsSUFBWDtBQUNEOzs7NkJBQ1EsQyxFQUFHO0FBQ1YsV0FBSyxRQUFMLENBQWM7QUFDWixlQUFPLEVBQUUsTUFBRixDQUFTLEtBQVQsQ0FBZSxXQUFmO0FBREssT0FBZDtBQUdEOzs7OEJBQ1M7QUFDUixXQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLEtBQUssS0FBTCxDQUFXLFFBQTlCO0FBQ0Q7OztpQ0FDWSxJLEVBQU07QUFDakIsVUFBRyxPQUFPLEtBQUssS0FBTCxDQUFXLE9BQWxCLElBQTZCLFFBQVEsS0FBSyxLQUFMLENBQVcsT0FBbkQsRUFBNEQ7QUFDMUQsYUFBSyxRQUFMLENBQWM7QUFDWixpQkFBTztBQURLLFNBQWQ7QUFHQSxlQUFPLElBQVA7QUFDRDtBQUNELGFBQU8sS0FBUDtBQUNEOzs7NkJBQ1E7QUFDUCxhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUsZUFBZixFQUErQixPQUFRLEtBQUssS0FBTCxDQUFXLEtBQVosR0FBcUIsRUFBckIsR0FBMEIsRUFBQyxhQUFhLFNBQWQsRUFBaEU7QUFDRTtBQUFBO0FBQUEsWUFBSyxTQUFTLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsSUFBcEIsQ0FBZCxFQUF5QyxXQUFVLDJCQUFuRCxFQUErRSxpQkFBZSxLQUFLLEtBQUwsQ0FBVyxJQUF6RztBQUNJO0FBQUE7QUFBQSxjQUFLLE9BQU0sSUFBWCxFQUFnQixRQUFPLEdBQXZCO0FBQ0Usb0RBQU0sR0FBRSxxQkFBUixFQUE4QixXQUFVLFNBQXhDO0FBREY7QUFESixTQURGO0FBT0U7QUFDRSxnQkFBSyxNQURQO0FBRUUsZUFBSyxXQUFXLEtBQUssS0FBTCxDQUFXLFFBRjdCO0FBR0UsZ0JBQU0sS0FBSyxJQUhiO0FBSUUscUJBQVcsS0FBSyxJQUpsQjtBQUtFLHFCQUFVLG9CQUxaO0FBTUUsY0FBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEdBQWtCLGNBTnhCO0FBT0UsaUJBQU8sS0FBSyxLQUFMLENBQVcsS0FQcEI7QUFRRSxvQkFBVSxLQUFLLEtBQUwsQ0FBVyxRQVJ2QjtBQVNFLG1CQUFTLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FUWDtBQVVFLHFCQUFXLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixJQUFyQixDQVZiLENBVXlDO0FBVnpDLFlBV0UsVUFBVSxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLElBQW5CLENBWFo7QUFZRSxpQkFBTyxFQUFDLFVBQVksS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUFyQixHQUEwQixJQUF0QyxFQVpUO0FBYUUsa0JBQVEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLElBQWY7QUFiVixVQVBGO0FBc0JFO0FBQUE7QUFBQSxZQUFLLFNBQVMsS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQWQsRUFBMkMsV0FBVSw2QkFBckQsRUFBbUYsaUJBQWUsS0FBSyxLQUFMLENBQVcsSUFBN0c7QUFDRTtBQUFBO0FBQUEsY0FBSyxPQUFNLElBQVgsRUFBZ0IsUUFBTyxHQUF2QjtBQUNFLG9EQUFNLEdBQUUscUJBQVIsRUFBOEIsV0FBVSxXQUF4QztBQURGO0FBREY7QUF0QkYsT0FERjtBQThCRDs7OztFQWhOMEMsZ0JBQU0sUzs7a0JBQTlCLGU7Ozs7Ozs7Ozs7Ozs7O0FDYnJCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUFoQkE7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLElBQU0sT0FBTyxrQkFBYjs7QUFFQTs7Ozs7Ozs7SUFPcUIsZTs7O0FBRW5COzs7QUFHQSwyQkFBWSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsa0lBQ1gsS0FEVzs7QUFFakIsVUFBSyxLQUFMLEdBQWE7QUFDWCxhQUFPLE1BQUssS0FBTCxDQUFXLEtBRFA7QUFFWCxhQUFPO0FBRkksS0FBYjtBQUZpQjtBQU1sQjs7Ozt5Q0FDb0I7QUFDbkIsVUFBRyxLQUFLLEtBQUwsQ0FBVyxPQUFkLEVBQXVCO0FBQ3JCLDJCQUFTLFdBQVQsQ0FBcUIsS0FBSyxJQUFMLENBQVUsV0FBVyxLQUFLLEtBQUwsQ0FBVyxRQUFoQyxDQUFyQixFQUFnRSxLQUFoRTtBQUNEO0FBQ0Y7Ozt5Q0FDb0I7QUFDbkIsVUFBSSxJQUFKO0FBQ0EsVUFBSSxJQUFKO0FBQ0EsYUFBTyxLQUFLLEtBQUwsQ0FBVyxJQUFsQjtBQUNBLFVBQUcsU0FBUyxNQUFaLEVBQW9CO0FBQ2xCLGVBQU8sR0FBUDtBQUNELE9BRkQsTUFFTyxJQUFHLFNBQVMsS0FBWixFQUFtQjtBQUN4QixlQUFPLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxlQUFPLENBQVA7QUFDRDtBQUNELFdBQUssSUFBTCxHQUFZLElBQVo7QUFDRDs7OzhDQUN5QixLLEVBQU87QUFDL0IsV0FBSyxRQUFMLENBQWMsRUFBQyxPQUFPLE1BQU0sS0FBZCxFQUFkO0FBQ0Q7OzsrQkFDVSxDLEVBQUc7QUFDWixVQUFJLEtBQUssRUFBRSxPQUFYO0FBQ0EsVUFBRyxPQUFPLENBQVAsSUFBWTtBQUNiLGFBQU8sRUFEVCxFQUNhO0FBQUU7QUFDYixVQUFFLGNBQUY7QUFDQSxVQUFFLGVBQUY7QUFDRDtBQUNGOzs7NEJBQ08sQyxFQUFHO0FBQ1QsVUFBSSxVQUFVLEVBQUUsT0FBaEI7QUFDQSxVQUFJLFFBQVEsRUFBRSxNQUFGLENBQVMsS0FBckI7QUFDQSxVQUFJLE9BQUo7QUFDQSxVQUFJLFVBQVcsV0FBVyxFQUFYLElBQWlCLFdBQVcsQ0FBM0M7QUFDQSxVQUFHLFlBQVksRUFBZixFQUFtQjtBQUFFO0FBQ25CLFVBQUUsY0FBRjtBQUNBLGFBQUssU0FBTDtBQUNBO0FBQ0Q7QUFDRCxVQUFHLFlBQVksRUFBZixFQUFtQjtBQUFDO0FBQ2xCLFVBQUUsY0FBRjtBQUNBLGFBQUssV0FBTDtBQUNBO0FBQ0Q7QUFDRCxVQUFJLEVBQUUsSUFBRixJQUFVLFVBQVYsSUFBd0IsT0FBNUIsRUFBcUM7QUFDbkMsWUFBRyxLQUFLLEtBQUwsQ0FBVyxJQUFYLElBQW1CLE1BQW5CLElBQTZCLEtBQUssS0FBTCxDQUFXLElBQVgsSUFBbUIsS0FBbkQsRUFBMEQ7QUFDeEQsY0FBRyxFQUFHLFdBQVcsRUFBWCxJQUFpQixXQUFXLEVBQTdCLElBQ0YsT0FERSxJQUVGLFdBQVcsQ0FGWCxDQUFILEVBRWtCO0FBQ2hCO0FBQ0Q7QUFDRjtBQUNELGdCQUFPLEtBQUssS0FBTCxDQUFXLElBQWxCO0FBQ0UsZUFBSyxNQUFMO0FBQ0Usc0JBQVUsS0FBSyxjQUFMLENBQW9CLEtBQXBCLENBQVY7QUFDQTtBQUNGLGVBQUssS0FBTDtBQUNFLHNCQUFVLEtBQUssYUFBTCxDQUFtQixLQUFuQixDQUFWO0FBQ0E7QUFDRixlQUFLLE9BQUw7QUFDRSxzQkFBVSxLQUFLLGVBQUwsQ0FBcUIsS0FBckIsQ0FBVjtBQUNBO0FBVEo7QUFXQSxZQUFHLE9BQUgsRUFBWTtBQUNWLGVBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsT0FBdEI7QUFDQSxjQUFHLE9BQUgsRUFBWTtBQUFFO0FBQ1osaUJBQUssT0FBTDtBQUNEO0FBQ0YsU0FMRCxNQUtPLElBQUcsT0FBSCxFQUFZO0FBQ2pCLGVBQUssUUFBTCxDQUFjO0FBQ1osbUJBQU87QUFESyxXQUFkO0FBR0Q7QUFDRjtBQUNGOzs7Z0NBQ1c7QUFDVixXQUFLLFFBQUwsQ0FBYyxDQUFkO0FBQ0EsV0FBSyxRQUFMLENBQWM7QUFDWixlQUFPO0FBREssT0FBZDtBQUlEOzs7a0NBQ2E7QUFDWixXQUFLLFFBQUwsQ0FBYyxDQUFDLENBQWY7QUFDQSxXQUFLLFFBQUwsQ0FBYztBQUNaLGVBQU87QUFESyxPQUFkO0FBR0Q7OzttQ0FDYyxLLEVBQU87QUFDcEIsVUFBSSxPQUFKO0FBQ0EsVUFBSSxRQUFRLElBQVQsSUFBbUIsUUFBUSxJQUE5QixFQUFxQztBQUNuQyxrQkFBVSxJQUFJLElBQUosQ0FBVSxJQUFJLElBQUosQ0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFwQixDQUFELENBQTRCLGNBQTVCLENBQTJDLEtBQTNDLENBQVQsQ0FBVjtBQUNBLGVBQU8sS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQVA7QUFDRDtBQUNGOzs7a0NBQ2EsSyxFQUFPO0FBQ25CLFVBQUksT0FBSjtBQUNBLFVBQUksT0FBSjtBQUNBLFVBQUksY0FBYyxLQUFLLEtBQUwsQ0FBVyxJQUE3Qjs7QUFFQSxnQkFBVSxJQUFJLElBQUosQ0FBUyxZQUFZLE9BQVosRUFBVCxFQUFnQyxZQUFZLFFBQVosS0FBeUIsQ0FBekQsRUFBNEQsQ0FBNUQsRUFBK0QsT0FBL0QsRUFBVjs7QUFFQSxVQUFHLFFBQVEsQ0FBUixJQUFhLFNBQVMsT0FBekIsRUFBa0M7QUFDaEMsa0JBQVUsSUFBSSxJQUFKLENBQVUsSUFBSSxJQUFKLENBQVMsV0FBVCxDQUFELENBQXdCLFVBQXhCLENBQW1DLEtBQW5DLENBQVQsQ0FBVjtBQUNBLGVBQU8sS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQVA7QUFDRDtBQUVGOzs7NkJBQ1EsRyxFQUFLO0FBQ1osVUFBSSxVQUFVLEtBQUssUUFBTCxDQUNaLEtBQUssS0FBTCxDQUFXLElBREMsRUFFWixLQUFLLEtBQUwsQ0FBVyxJQUZDLEVBR1osR0FIWSxFQUlaLEtBQUssS0FBTCxDQUFXLE9BSkMsRUFLWixLQUFLLEtBQUwsQ0FBVyxPQUxDLENBQWQ7QUFPQSxXQUFLLEtBQUwsQ0FBVyxVQUFYLENBQXNCLE9BQXRCO0FBQ0Q7OztvQ0FFZSxLLEVBQU87QUFDckIsVUFBSSxPQUFKO0FBQ0EsVUFBSyxDQUFDLE1BQU0sS0FBTixDQUFGLElBQW1CLFFBQVEsRUFBM0IsSUFBaUMsUUFBUSxDQUE3QyxFQUFnRDtBQUM5QyxrQkFBVSxJQUFJLElBQUosQ0FBVSxJQUFJLElBQUosQ0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFwQixDQUFELENBQTRCLFdBQTVCLENBQXdDLFFBQVEsQ0FBaEQsQ0FBVCxDQUFWO0FBQ0EsWUFBRyxPQUFILEVBQVk7QUFDVixlQUFLLFFBQUwsQ0FBYztBQUNaLG1CQUFPLEtBQUssZ0JBQUwsQ0FBc0IsUUFBTSxDQUE1QjtBQURLLFdBQWQ7QUFHQSxpQkFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBUDtBQUNEO0FBQ0YsT0FSRCxNQVFPO0FBQ0wsWUFBSSxrQkFBSjtBQUNBLG9CQUFZLEtBQUssYUFBTCxDQUFtQixLQUFLLGdCQUF4QixFQUEwQyxLQUExQyxDQUFaO0FBQ0EsWUFBRyxjQUFjLEtBQWpCLEVBQXdCO0FBQ3RCLG9CQUFVLElBQUksSUFBSixDQUFVLElBQUksSUFBSixDQUFTLEtBQUssS0FBTCxDQUFXLElBQXBCLENBQUQsQ0FBNEIsV0FBNUIsQ0FBd0MsU0FBeEMsQ0FBVCxDQUFWO0FBQ0EsaUJBQU8sS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQVA7QUFDRCxTQUhELE1BR087QUFDTCxpQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGOzs7MkJBQ007QUFDTCxXQUFLLFFBQUwsQ0FBYztBQUNaLGVBQU8sS0FBSyxLQUFMLENBQVcsS0FETjtBQUVaLGVBQU87QUFGSyxPQUFkOztBQUtBLFdBQUssS0FBTCxDQUFXLElBQVg7QUFDRDs7OzZCQUNRLEMsRUFBRztBQUNWLFdBQUssUUFBTCxDQUFjO0FBQ1osZUFBTyxFQUFFLE1BQUYsQ0FBUyxLQUFULENBQWUsV0FBZjtBQURLLE9BQWQ7QUFHRDs7OzhCQUNTO0FBQ1IsV0FBSyxLQUFMLENBQVcsT0FBWCxDQUFtQixLQUFLLEtBQUwsQ0FBVyxRQUE5QjtBQUNEOzs7aUNBQ1ksSSxFQUFNO0FBQ2pCLFVBQUcsT0FBTyxLQUFLLEtBQUwsQ0FBVyxPQUFsQixJQUE2QixRQUFRLEtBQUssS0FBTCxDQUFXLE9BQW5ELEVBQTREO0FBQzFELGFBQUssUUFBTCxDQUFjO0FBQ1osaUJBQU87QUFESyxTQUFkO0FBR0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQVA7QUFDRDs7OzZCQUNRO0FBQ1AsYUFDRTtBQUFBO0FBQUEsVUFBSyxXQUFVLGVBQWYsRUFBK0IsT0FBUSxLQUFLLEtBQUwsQ0FBVyxLQUFaLEdBQXFCLEVBQXJCLEdBQTBCLEVBQUMsYUFBYSxTQUFkLEVBQWhFO0FBQ0U7QUFBQTtBQUFBLFlBQUssU0FBUyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLENBQWQsRUFBeUMsV0FBVSwyQkFBbkQsRUFBK0UsaUJBQWUsS0FBSyxLQUFMLENBQVcsSUFBekc7QUFDSTtBQUFBO0FBQUEsY0FBSyxPQUFNLElBQVgsRUFBZ0IsUUFBTyxHQUF2QjtBQUNFLG9EQUFNLEdBQUUscUJBQVIsRUFBOEIsV0FBVSxTQUF4QztBQURGO0FBREosU0FERjtBQU9FO0FBQ0UsZ0JBQUssTUFEUDtBQUVFLGVBQUssV0FBVyxLQUFLLEtBQUwsQ0FBVyxRQUY3QjtBQUdFLGdCQUFNLEtBQUssSUFIYjtBQUlFLHFCQUFXLEtBQUssSUFKbEI7QUFLRSxxQkFBVSxvQkFMWjtBQU1FLGNBQUksS0FBSyxLQUFMLENBQVcsSUFBWCxHQUFrQixjQU54QjtBQU9FLGlCQUFPLEtBQUssS0FBTCxDQUFXLEtBUHBCO0FBUUUsb0JBQVUsS0FBSyxLQUFMLENBQVcsUUFSdkI7QUFTRSxtQkFBUyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLElBQWxCLENBVFg7QUFVRSxxQkFBVyxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsSUFBckIsQ0FWYixDQVV5QztBQVZ6QyxZQVdFLFVBQVUsS0FBSyxRQUFMLENBQWMsSUFBZCxDQUFtQixJQUFuQixDQVhaO0FBWUUsaUJBQU8sRUFBQyxVQUFZLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBckIsR0FBMEIsSUFBdEMsRUFaVDtBQWFFLGtCQUFRLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUFmO0FBYlYsVUFQRjtBQXNCRTtBQUFBO0FBQUEsWUFBSyxTQUFTLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFkLEVBQTJDLFdBQVUsNkJBQXJELEVBQW1GLGlCQUFlLEtBQUssS0FBTCxDQUFXLElBQTdHO0FBQ0U7QUFBQTtBQUFBLGNBQUssT0FBTSxJQUFYLEVBQWdCLFFBQU8sR0FBdkI7QUFDRSxvREFBTSxHQUFFLHFCQUFSLEVBQThCLFdBQVUsV0FBeEM7QUFERjtBQURGO0FBdEJGLE9BREY7QUE4QkQ7Ozs7RUFoTjBDLGdCQUFNLFM7O2tCQUE5QixlOzs7Ozs7Ozs7Ozs7OztBQ2JyQjs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBaEJBOzs7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFNLE9BQU8sa0JBQWI7O0FBRUE7Ozs7Ozs7O0lBT3FCLFk7OztBQUVuQjs7O0FBR0Esd0JBQVksS0FBWixFQUFtQjtBQUFBOztBQUFBLDRIQUNYLEtBRFc7O0FBRWpCLFVBQUssS0FBTCxHQUFhO0FBQ1gsWUFBTSxNQUFNLElBREQ7QUFFWCxlQUFTLE1BQU0sT0FGSjtBQUdYLGVBQVMsTUFBTSxPQUhKO0FBSVgsV0FBSztBQUpNLEtBQWI7QUFGaUI7QUFRbEI7Ozs7OENBQ3lCLEssRUFBTztBQUMvQixXQUFLLFFBQUwsQ0FBYztBQUNaLGNBQU0sTUFBTSxJQURBO0FBRVosaUJBQVMsTUFBTSxPQUZIO0FBR1osaUJBQVMsTUFBTTtBQUhILE9BQWQ7QUFLRDs7OzJCQUNNO0FBQ0wsV0FBSyxRQUFMLENBQWMsRUFBQyxLQUFLLElBQU4sRUFBZDtBQUNEOzs7NEJBQ08sSyxFQUFPO0FBQ2IsVUFBSSxPQUFKO0FBQ0EsVUFBRyxRQUFRLENBQVgsRUFBYztBQUNaLGtCQUFVLFFBQVEsQ0FBbEI7QUFDRCxPQUZELE1BRU87QUFDTCxrQkFBVSxDQUFWO0FBQ0Q7QUFDRCxXQUFLLFFBQUwsQ0FBYztBQUNaLGFBQUs7QUFETyxPQUFkO0FBR0Q7OzsrQkFDVSxJLEVBQU07QUFDZixXQUFLLFFBQUwsQ0FBYztBQUNaLGNBQU07QUFETSxPQUFkO0FBR0EsV0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixLQUFLLEtBQUwsQ0FBVyxFQUFuQyxFQUF1QyxJQUF2QztBQUNEOzs7NkJBQ1E7QUFDUCxhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQVUseUJBQWY7QUFDRSxrRUFBaUIsV0FBVyxJQUFJLElBQUosQ0FBUyxJQUFULENBQTVCO0FBQ0UsaUJBQU8sSUFBSSxJQUFKLEVBRFQ7QUFFRSxnQkFBTSxLQUFLLEtBQUwsQ0FBVyxJQUZuQjtBQUdFLGlCQUFPLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsY0FBaEIsRUFIVDtBQUlFLGdCQUFLLE1BSlA7QUFLRSxrQkFBUSxLQUFLLEtBQUwsQ0FBVyxNQUxyQjtBQU1FLGlCQUFPLEtBQUssS0FBTCxDQUFXLEtBTnBCO0FBT0Usc0JBQVksS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBUGQ7QUFRRSxvQkFBVSxDQVJaO0FBU0UsbUJBQVUsS0FBSyxLQUFMLENBQVcsR0FBWCxJQUFrQixDQVQ5QjtBQVVFLG1CQUFTLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FWWDtBQVdFLG1CQUFTLEtBQUssS0FBTCxDQUFXLE9BWHRCO0FBWUUsbUJBQVMsS0FBSyxLQUFMLENBQVcsT0FadEI7QUFhRSxnQkFBTSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsSUFBZjtBQWJSLFVBREY7QUFnQkU7QUFDRSxxQkFBVyxJQUFJLElBQUosQ0FBUyxJQUFULENBRGI7QUFFRSxpQkFBTyxJQUFJLElBQUosRUFGVCxFQUVxQixNQUFNLEtBQUssS0FBTCxDQUFXLElBRnRDO0FBR0UsZ0JBQUssT0FIUCxFQUdlLFFBQVEsS0FBSyxLQUFMLENBQVcsTUFIbEM7QUFJRSxpQkFBTyxLQUFLLEtBQUwsQ0FBVyxLQUpwQjtBQUtFLHNCQUFZLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixJQUFyQixDQUxkO0FBTUUsaUJBQU8sS0FBSyxnQkFBTCxDQUFzQixLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLFdBQWhCLEVBQXRCLENBTlQ7QUFPRSxvQkFBVSxDQVBaO0FBUUUsbUJBQVUsS0FBSyxLQUFMLENBQVcsR0FBWCxJQUFrQixDQVI5QjtBQVNFLG1CQUFTLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FUWDtBQVVFLG1CQUFTLEtBQUssS0FBTCxDQUFXLE9BVnRCO0FBV0UsbUJBQVMsS0FBSyxLQUFMLENBQVcsT0FYdEI7QUFZRSxnQkFBTSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsSUFBZjtBQVpSLFVBaEJGO0FBOEJFO0FBQ0UscUJBQVcsSUFBSSxJQUFKLENBQVMsSUFBVCxDQURiO0FBRUUsaUJBQU8sSUFBSSxJQUFKLEVBRlQ7QUFHRSxnQkFBTSxLQUFLLEtBQUwsQ0FBVyxJQUhuQjtBQUlFLGdCQUFLLEtBSlA7QUFLRSxrQkFBUSxLQUFLLEtBQUwsQ0FBVyxNQUxyQjtBQU1FLGlCQUFPLEtBQUssS0FBTCxDQUFXLEtBTnBCO0FBT0Usc0JBQVksS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBUGQ7QUFRRSxpQkFBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLFVBQWhCLEVBQVQsRUFBdUMsQ0FBdkMsRUFBMEMsR0FBMUMsQ0FSVDtBQVNFLG9CQUFVLENBVFo7QUFVRSxtQkFBVSxLQUFLLEtBQUwsQ0FBVyxHQUFYLElBQWtCLENBVjlCO0FBV0UsbUJBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixJQUFsQixDQVhYO0FBWUUsbUJBQVMsS0FBSyxLQUFMLENBQVcsT0FadEI7QUFhRSxtQkFBUyxLQUFLLEtBQUwsQ0FBVyxPQWJ0QjtBQWNFLGdCQUFNLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxJQUFmO0FBZFI7QUE5QkYsT0FERjtBQWlERDs7OztFQTNGdUMsZ0JBQU0sUzs7a0JBQTNCLFk7Ozs7Ozs7Ozs7Ozs7O0FDYnJCOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBZkE7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7O0lBT3FCLGU7OztBQUVuQjs7O0FBR0EsMkJBQVksS0FBWixFQUFtQjtBQUFBOztBQUFBLDZIQUNYLEtBRFc7QUFFbEI7Ozs7c0NBQ2lCO0FBQ2hCLFVBQUksYUFBYSxTQUFqQjtBQUNBLFVBQUcsS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixDQUF0QixJQUEyQixLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLEtBQUssS0FBTCxDQUFXLEdBQS9ELEVBQW9FO0FBQ2xFLHFCQUFhLFFBQWI7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhO0FBQ1gsb0JBQVk7QUFERCxPQUFiO0FBR0Q7QUFDRDs7Ozs7Ozs7Ozs7OzsrQkFVVyxDLEVBQUcsQyxFQUFHO0FBQ2YsUUFBRSxlQUFGO0FBQ0EsV0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixFQUFFLE1BQXBCLEVBQTRCLEtBQUssS0FBTCxDQUFXLEVBQXZDO0FBQ0Q7O0FBRUQ7Ozs7Ozs2QkFHUztBQUNQLFdBQUssZUFBTDtBQUNBLGFBQ0U7QUFBQTtBQUFBO0FBQ0Usa0JBQVEsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBRFY7QUFFRSxvQkFBVSxFQUFDLEdBQUUsS0FBSyxLQUFMLENBQVcsUUFBZCxFQUF3QixHQUFFLENBQTFCLEVBRlo7QUFHRSxrQkFBUSxLQUFLLEtBQUwsQ0FBVyxNQUhyQjtBQUlFLGdCQUFLO0FBSlA7QUFNRTtBQUFBO0FBQUE7QUFDRTtBQUNFLG1CQUFPLEtBQUssS0FBTCxDQUFXLEtBRHBCO0FBRUUsb0JBQVEsS0FBSyxLQUFMLENBQVcsTUFGckI7QUFHRSxtQkFBTztBQUNMLG9CQUFLLEtBQUssS0FBTCxDQUFXLEtBRFg7QUFFTCwwQkFBWSxLQUFLLEtBQUwsQ0FBVztBQUZsQjtBQUhULFlBREY7QUFnQkU7QUFDRSxvQkFBUSxTQUFTLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsR0FBN0IsR0FBbUMsS0FBbkMsR0FBMkMsS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUEvRCxHQUFtRSxJQUFuRSxHQUF5RSxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLEdBRHZHO0FBRUUsdUJBQVcsZUFBZ0IsRUFBRSxLQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLElBQXJCLENBQWhCLEdBQThDLElBQTlDLEdBQXNELEVBQUUsS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUF0QixDQUF0RCxHQUFpRixHQUY5RjtBQUdFLG1CQUFPO0FBQ0wsb0JBQU0sS0FBSyxLQUFMLENBQVcsYUFEWjtBQUVMLDBCQUFZLEtBQUssS0FBTCxDQUFXLFVBRmxCO0FBR0wsc0JBQVEsTUFISDtBQUlMLHNCQUFRO0FBSkg7QUFIVDtBQWhCRjtBQU5GLE9BREY7QUFvQ0Q7Ozs7RUF6RTBDLGdCQUFNLFM7O2tCQUE5QixlOztBQTJFckIsZ0JBQWdCLFlBQWhCLEdBQStCO0FBQzdCLFdBQVM7QUFEb0IsQ0FBL0I7Ozs7Ozs7Ozs7Ozs7O0FDckZBOzs7Ozs7Ozs7OytlQWRBOzs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7SUFNcUIsb0I7OztBQUVuQjs7O0FBR0EsZ0NBQVksS0FBWixFQUFtQjtBQUFBOztBQUFBLDRJQUNYLEtBRFc7O0FBRWpCLFVBQUssT0FBTCxHQUFlO0FBQ2IsbUJBQWEsTUFBSyxLQUFMLENBQVc7QUFEWCxLQUFmO0FBRmlCO0FBS2xCOzs7O2lDQUNZO0FBQ1gsVUFBSSxRQUFRLEtBQUssS0FBTCxDQUFXLGFBQXZCO0FBQ0EsVUFBSSxNQUFNLEtBQUssS0FBTCxDQUFXLFdBQXJCO0FBQ0EsVUFBSSxNQUFNLEtBQUssS0FBTCxDQUFXLEdBQXJCO0FBQ0EsVUFBSSxLQUFKOztBQUVBLFVBQUcsUUFBUSxDQUFYLEVBQWE7QUFDWCxnQkFBUSxDQUFSO0FBQ0Q7QUFDRCxVQUFHLE1BQU0sR0FBVCxFQUFhO0FBQ1gsY0FBTSxHQUFOO0FBQ0Q7QUFDRCxjQUFRLE1BQU0sS0FBZDtBQUNBLFVBQUcsUUFBUSxDQUFYLEVBQWM7QUFDWixnQkFBUSxDQUFSO0FBQ0Q7QUFDRCxXQUFLLEtBQUwsR0FBYTtBQUNYLGVBQU8sS0FESTtBQUVYLHVCQUFlO0FBRkosT0FBYjtBQUlEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7K0JBVVcsQyxFQUFHLEMsRUFBRTtBQUNkLFFBQUUsZUFBRjtBQUNBLFdBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsRUFBRSxNQUFwQjtBQUNEOztBQUVEOzs7Ozs7NkJBR1M7QUFDUCxXQUFLLFVBQUw7QUFDQSxhQUNFO0FBQ0UsV0FBRyxLQUFLLEtBQUwsQ0FBVyxhQURoQjtBQUVFLGNBQU0sS0FBSyxLQUFMLENBQVcsS0FGbkI7QUFHRSxlQUFPLEtBQUssS0FBTCxDQUFXLEtBSHBCO0FBSUUsZUFBTyxLQUFLLE9BSmQ7QUFLRSxnQkFBUSxLQUFLLEtBQUwsQ0FBVyxNQUxyQjtBQU1FLG1CQUFVLGVBTlo7QUFPRSxpQkFBUyxLQUFLLEtBQUwsQ0FBVztBQVB0QixRQURGO0FBV0Q7Ozs7RUEvRCtDLGdCQUFNLFM7O2tCQUFuQyxvQjs7Ozs7Ozs7Ozs7Ozs7QUNQckI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OytlQWhCQTs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7SUFPcUIscUI7OztBQUVuQjs7O0FBR0EsaUNBQVksS0FBWixFQUFtQjtBQUFBOztBQUFBLDhJQUNYLEtBRFc7O0FBRWpCLFVBQUssS0FBTCxHQUFjO0FBQ1oscUJBQWUsTUFBTSxhQURUO0FBRVosbUJBQWEsTUFBTSxXQUZQO0FBR1osV0FBSyxNQUFNO0FBSEMsS0FBZDtBQUZpQjtBQU9sQjs7Ozs4Q0FDeUIsSyxFQUFPO0FBQy9CLFdBQUssUUFBTCxDQUFjO0FBQ1osdUJBQWUsTUFBTSxhQURUO0FBRVoscUJBQWEsTUFBTSxXQUZQO0FBR1osYUFBSyxNQUFNO0FBSEMsT0FBZDtBQUtEO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQWNXLE0sRUFBUSxFLEVBQUk7QUFDckIsVUFBSSxNQUFKO0FBQ0EsVUFBSSxJQUFKOztBQUVBLFVBQUcsT0FBTyxPQUFWLEVBQW1CO0FBQ2pCLGlCQUFTLFNBQVMsS0FBSyxLQUFMLENBQVcsYUFBN0I7QUFDQSxlQUFPLEtBQUssS0FBTCxDQUFXLFdBQWxCO0FBQ0EsWUFBRyxTQUFTLENBQVQsSUFBYyxTQUFTLElBQTFCLEVBQWdDO0FBQzlCO0FBQ0Q7QUFDRCxZQUFHLFNBQVUsSUFBSSxLQUFLLEtBQUwsQ0FBVyxRQUF6QixJQUFzQyxJQUF6QyxFQUErQztBQUM3QyxpQkFBTyxTQUFTLEtBQUssS0FBTCxDQUFXLFFBQTNCO0FBQ0Q7QUFDRixPQVRELE1BU08sSUFBRyxPQUFPLEtBQVYsRUFBaUI7QUFDdEIsaUJBQVMsS0FBSyxLQUFMLENBQVcsYUFBcEI7QUFDQSxlQUFPLFNBQVMsS0FBSyxLQUFMLENBQVcsV0FBM0I7QUFDQSxZQUFHLE9BQU8sS0FBSyxLQUFMLENBQVcsR0FBbEIsSUFBeUIsU0FBUyxJQUFyQyxFQUEyQztBQUN6QztBQUNEO0FBQ0QsWUFBRyxTQUFVLElBQUksS0FBSyxLQUFMLENBQVcsUUFBekIsSUFBc0MsSUFBekMsRUFBK0M7QUFDN0MsbUJBQVMsT0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUEzQjtBQUNEO0FBQ0YsT0FUTSxNQVNBO0FBQ0wsaUJBQVMsU0FBUyxLQUFLLEtBQUwsQ0FBVyxhQUE3QjtBQUNBLGVBQU8sU0FBUyxLQUFLLEtBQUwsQ0FBVyxXQUEzQjtBQUNBLFlBQUcsUUFBUSxLQUFLLEtBQUwsQ0FBVyxHQUFuQixJQUEwQixTQUFTLENBQXRDLEVBQXlDO0FBQ3ZDO0FBQ0Q7QUFDRjtBQUNELFdBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsTUFBbEIsRUFBMEIsSUFBMUI7O0FBRUEsV0FBSyxRQUFMLENBQWM7QUFDWix1QkFBZSxNQURIO0FBRVoscUJBQWE7QUFGRCxPQUFkO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7O2lDQVFhO0FBQ1gsV0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixLQUFLLEtBQUwsQ0FBVyxhQUE3QixFQUE0QyxLQUFLLEtBQUwsQ0FBVyxXQUF2RDtBQUNEOzs7aUNBQ1ksQyxFQUFHO0FBQ2QsV0FBSyxLQUFMLENBQVcsWUFBWCxDQUF3QixFQUFFLFdBQTFCO0FBQ0Q7QUFDRDs7Ozs7OzZCQUdTO0FBQ1AsYUFDRTtBQUFBO0FBQUEsVUFBSyxJQUFHLDRCQUFSLEVBQXFDLFdBQVUsNEJBQS9DO0FBQ0U7QUFDRSxpQkFBTyxLQUFLLEtBQUwsQ0FBVyxRQURwQjtBQUVFLHVCQUFhLEtBQUssS0FBTCxDQUFXLFdBRjFCO0FBR0UsbUJBQVMsS0FBSyxLQUFMLENBQVcsWUFIdEI7QUFJRSxpQkFBTyxLQUFLLEtBQUwsQ0FBVyxVQUpwQjtBQUtFLGtCQUFRLEtBQUssS0FBTCxDQUFXLE1BTHJCO0FBTUUseUJBQWUsS0FBSyxLQUFMLENBQVcsYUFBWCxHQUEyQixLQUFLLEtBQUwsQ0FBVyxRQU52RDtBQU9FLG1CQUFTLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQVBYO0FBUUUsZUFBSyxLQUFLLEtBQUwsQ0FBVyxHQVJsQjtBQVNFLGNBQUcsT0FUTCxHQURGO0FBV0U7QUFDRSxvQkFBVSxLQUFLLEtBQUwsQ0FBVyxhQUR2QjtBQUVFLGlCQUFPLEtBQUssS0FBTCxDQUFXLFVBRnBCO0FBR0UsaUJBQU8sS0FBSyxLQUFMLENBQVcsUUFIcEI7QUFJRSxrQkFBUSxLQUFLLEtBQUwsQ0FBVyxNQUpyQjtBQUtFLGtCQUFRLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixJQUFyQixDQUxWO0FBTUUsa0JBQVEsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBTlY7QUFPRSxlQUFLLEtBQUssS0FBTCxDQUFXLEdBUGxCO0FBUUUseUJBQWUsS0FBSyxLQUFMLENBQVcsa0JBUjVCO0FBU0UsaUJBQU8sSUFUVDtBQVVFLGNBQUcsT0FWTCxHQVhGO0FBc0JFO0FBQ0UsZUFBSyxLQUFLLEtBQUwsQ0FBVyxHQURsQjtBQUVFLG9CQUFVLEtBQUssS0FBTCxDQUFXLFdBRnZCO0FBR0UsaUJBQU8sS0FBSyxLQUFMLENBQVcsUUFIcEI7QUFJRSxpQkFBTyxLQUFLLEtBQUwsQ0FBVyxRQUpwQjtBQUtFLGtCQUFRLEtBQUssS0FBTCxDQUFXLE1BTHJCO0FBTUUsaUJBQU8sS0FOVDtBQU9FLGtCQUFRLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixJQUFyQixDQVBWO0FBUUUsa0JBQVEsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBUlY7QUFTRSx5QkFBZSxLQUFLLEtBQUwsQ0FBVyxnQkFUNUI7QUFVRSxjQUFHLEtBVkw7QUF0QkYsT0FERjtBQW9DRDs7OztFQTdIZ0QsZ0JBQU0sUzs7a0JBQXBDLHFCOzs7Ozs7Ozs7Ozs7OztBQ1hyQjs7Ozs7Ozs7OzsrZUFkQTs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7SUFPcUIsTzs7O0FBQ25CLG1CQUFZLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSEFDWCxLQURXOztBQUVqQixVQUFLLEtBQUwsR0FBYTtBQUNYLGVBQVM7QUFERSxLQUFiO0FBRmlCO0FBS2xCOzs7O2dDQUNXO0FBQ1YsV0FBSyxRQUFMLENBQWM7QUFDWixpQkFBUztBQURHLE9BQWQ7QUFHRDs7OytCQUNVO0FBQ1QsV0FBSyxRQUFMLENBQWM7QUFDWixpQkFBUztBQURHLE9BQWQ7QUFHRDs7OzRCQUNPLEcsRUFBSztBQUNYLFdBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsR0FBbkI7QUFDRDs7OzZCQUNRO0FBQUE7O0FBQ1AsYUFDRTtBQUFBO0FBQUE7QUFDQSx3QkFBYyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLENBRGQ7QUFFQSx3QkFBYyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLElBQW5CLENBRmQ7QUFHQSxxQkFBVSxpQkFIVjtBQUlFO0FBQUE7QUFBQTtBQUFPLGVBQUssS0FBTCxDQUFXO0FBQWxCLFNBSkY7QUFLRTtBQUFBO0FBQUEsWUFBSyxXQUFVLFlBQWYsRUFBNEIsT0FBUSxLQUFLLEtBQUwsQ0FBVyxPQUFaLEdBQXVCLEVBQUMsWUFBWSxTQUFiLEVBQXZCLEdBQWlELEVBQXBGO0FBQ0U7QUFBQTtBQUFBO0FBQ0csaUJBQUssS0FBTCxDQUFXLFNBQVgsQ0FBcUIsR0FBckIsQ0FBeUIsVUFBQyxNQUFELEVBQVMsQ0FBVCxFQUFlO0FBQ3ZDLHFCQUFPO0FBQUE7QUFBQSxrQkFBSSxLQUFLLGFBQVcsTUFBWCxHQUFvQixHQUFwQixHQUEwQixDQUFuQyxFQUFzQyxJQUFJLE1BQTFDLEVBQWtELFNBQVMsT0FBSyxPQUFMLENBQWEsSUFBYixTQUF3QixNQUF4QixDQUEzRDtBQUE2RjtBQUE3RixlQUFQO0FBQ0QsYUFGQTtBQURIO0FBREY7QUFMRixPQURGO0FBZUQ7Ozs7RUFwQ2tDLGdCQUFNLFM7O2tCQUF0QixPOzs7Ozs7Ozs7O0FDdkJyQjs7Ozs7Ozs7Ozs7QUFXQTs7a0JBRWU7QUFDYjs7Ozs7Ozs7Ozs7QUFXQSxNQVphLGdCQVlSLEVBWlEsRUFZSjtBQUNQLFFBQUcsRUFBSCxFQUFPO0FBQ0wsT0FBQyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QjtBQUM3QixVQUFFLHVCQUFGLElBQTJCLENBQTNCO0FBQ0EsVUFBRSxDQUFGLElBQUssRUFBRSxDQUFGLEtBQU0sWUFBVztBQUNwQixXQUFDLEVBQUUsQ0FBRixFQUFLLENBQUwsR0FBTyxFQUFFLENBQUYsRUFBSyxDQUFMLElBQVEsRUFBaEIsRUFBb0IsSUFBcEIsQ0FBeUIsU0FBekI7QUFDRCxTQUZELEVBR0EsRUFBRSxDQUFGLEVBQUssQ0FBTCxHQUFPLElBQUUsSUFBSSxJQUFKLEVBSFQ7QUFJQSxZQUFFLEVBQUUsYUFBRixDQUFnQixDQUFoQixDQUFGLEVBQ0EsSUFBRSxFQUFFLG9CQUFGLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBREY7QUFFQSxVQUFFLEtBQUYsR0FBUSxDQUFSO0FBQ0EsVUFBRSxHQUFGLEdBQU0sQ0FBTjtBQUNBLFVBQUUsVUFBRixDQUFhLFlBQWIsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0I7QUFDRCxPQVhELEVBV0csTUFYSCxFQVdXLFFBWFgsRUFXcUIsUUFYckIsRUFXK0IsK0NBWC9CLEVBV2dGLElBWGhGO0FBWUEsU0FBRyxRQUFILEVBQWEsRUFBYixFQUFpQixNQUFqQjtBQUNBLFNBQUcsTUFBSCxFQUFXLFVBQVg7QUFDRDtBQUNGLEdBN0JZOztBQThCZDs7Ozs7Ozs7Ozs7OztBQWFDLE9BM0NhLGlCQTJDUCxRQTNDTyxFQTJDRyxNQTNDSCxFQTJDVyxLQTNDWCxFQTJDa0IsS0EzQ2xCLEVBMkN5QjtBQUNwQyxRQUFJLE9BQVEsRUFBUixLQUFnQixXQUFwQixFQUFpQztBQUMvQixTQUFHLE1BQUgsRUFBVyxPQUFYLEVBQW9CLFFBQXBCLEVBQThCLE1BQTlCLEVBQXNDLEtBQXRDLEVBQTZDLEtBQTdDO0FBQ0Q7QUFDRjtBQS9DWSxDOzs7Ozs7Ozs7Ozs7O0FDYmY7Ozs7Ozs7Ozs7Ozs7O0lBY3FCLEs7QUFDbkI7OztBQUdBLG1CQUFjO0FBQUE7O0FBQ1osU0FBSyxnQkFBTCxHQUF1QixDQUFFLEtBQUYsRUFBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXVCLEtBQXZCLEVBQThCLEtBQTlCLEVBQXFDLEtBQXJDLEVBQ0QsS0FEQyxFQUNNLEtBRE4sRUFDYSxLQURiLEVBQ29CLEtBRHBCLEVBQzJCLEtBRDNCLEVBQ2tDLEtBRGxDLENBQXZCO0FBRUQ7QUFDRDs7Ozs7Ozs7Ozs7Ozs0QkFTUTtBQUNOLGFBQU8sS0FBSyxZQUFMLENBQWtCLEtBQUssR0FBTCxFQUFsQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OztpQ0FTYSxJLEVBQU07QUFDakIsV0FBSyxXQUFMLENBQWlCLENBQWpCO0FBQ0EsV0FBSyxhQUFMLENBQW1CLENBQW5CO0FBQ0EsV0FBSyxhQUFMLENBQW1CLENBQW5CO0FBQ0EsV0FBSyxrQkFBTCxDQUF3QixDQUF4QjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7MEJBQ0ssRyxFQUFLLEcsRUFBSyxHLEVBQUs7QUFDbkIsVUFBSSxNQUFNLEdBQVYsRUFBZTtBQUFFLGVBQU8sR0FBUDtBQUFhO0FBQzlCLFVBQUksTUFBTSxHQUFWLEVBQWU7QUFBRSxlQUFPLEdBQVA7QUFBYTtBQUM5QixhQUFPLEdBQVA7QUFDRDs7O2dDQUNXLEMsRUFBRztBQUNiLFVBQUksQ0FBSjtBQUNBLFVBQUksQ0FBSjtBQUNBLFVBQUcsRUFBRSxjQUFMLEVBQXFCO0FBQ25CLFlBQUksRUFBRSxjQUFGLEVBQUo7QUFDQSxZQUFJLEVBQUUsV0FBRixFQUFKO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSSxFQUFFLElBQU47QUFDQSxZQUFJLEVBQUUsS0FBTjtBQUNEO0FBQ0QsVUFBSSxVQUFVLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJLENBQWhCLEVBQW1CLENBQW5CLENBQVQsQ0FBZDtBQUNBLGFBQU8sUUFBUSxVQUFSLEVBQVA7QUFDRDtBQUNEOzs7Ozs7Ozs7OzswQkFRTTtBQUNKLGFBQU8sSUFBSSxJQUFKLEVBQVA7QUFDRDs7O2tDQUNhLEksRUFBTSxLLEVBQU87QUFDekIsV0FBSSxJQUFJLElBQUksQ0FBUixFQUFXLE1BQU0sS0FBSyxNQUExQixFQUFrQyxJQUFJLEdBQXRDLEVBQTJDLEdBQTNDLEVBQWdEO0FBQzlDLFlBQUcsS0FBSyxDQUFMLE1BQVksS0FBZixFQUFzQjtBQUNwQixpQkFBTyxDQUFQO0FBQ0Q7QUFDRjtBQUNELGFBQU8sS0FBUDtBQUNEOzs7OEJBQ1M7QUFDUixhQUFPLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCLENBQWxCLENBQVQsQ0FBUDtBQUNEOzs7OEJBRVM7QUFDUixhQUFPLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLEVBQW5CLENBQVQsQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7OztBQVNFOzs7O2lDQUNXLFksRUFBYztBQUN6QixVQUFJLGNBQWMsYUFBYSxLQUFiLENBQW1CLEdBQW5CLENBQWxCO0FBQ0EsVUFBSSxXQUFXLFlBQVksQ0FBWixFQUFlLEtBQWYsQ0FBcUIsR0FBckIsQ0FBZjs7QUFFQTtBQUNBLFVBQUksT0FBTyxTQUFTLENBQVQsQ0FBWDtBQUNBLFVBQUksUUFBUSxTQUFTLENBQVQsSUFBYyxDQUExQjtBQUNBLFVBQUksTUFBTSxTQUFTLENBQVQsQ0FBVjs7QUFFQSxVQUFJLE9BQU8sQ0FBWDtBQUNBLFVBQUksU0FBUyxDQUFiO0FBQ0EsVUFBSSxTQUFTLENBQWI7QUFDQSxVQUFJLGNBQWMsQ0FBbEI7O0FBRUE7QUFDQSxVQUFJLFlBQVksTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUMxQixZQUFJLFNBQVMsWUFBWSxDQUFaLEVBQWUsS0FBZixDQUFxQixRQUFyQixDQUFiO0FBQ0EsZUFBTyxPQUFPLENBQVAsS0FBYSxDQUFwQjtBQUNBLGlCQUFTLE9BQU8sQ0FBUCxLQUFhLENBQXRCO0FBQ0EsaUJBQVMsT0FBTyxDQUFQLEtBQWEsQ0FBdEI7QUFDQSxzQkFBYyxPQUFPLENBQVAsS0FBYSxDQUEzQjtBQUNEO0FBQ0QsVUFBSSxPQUFPLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLElBQTNCLEVBQWlDLE1BQWpDLEVBQXlDLE1BQXpDLEVBQWlELFdBQWpELENBQVQsQ0FBWDtBQUNBLFVBQUksTUFBTSxLQUFLLE9BQUwsRUFBTixDQUFKLEVBQTJCO0FBQ3pCLGNBQU0sSUFBSSxLQUFKLENBQVUsbUJBQW1CLFlBQTdCLENBQU47QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEOzs7MkJBQ00sSyxFQUFPLE0sRUFBUTtBQUNwQixVQUFJLFNBQVMsRUFBYjtBQUNBLFdBQUksSUFBSSxJQUFJLENBQVosRUFBZSxJQUFJLE1BQW5CLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzlCLGtCQUFVLEtBQVY7QUFDRDtBQUNELGFBQU8sTUFBUDtBQUNEOzs7eUJBQ0ksRyxFQUFLLEcsRUFBSyxHLEVBQUs7QUFDbEIsVUFBRyxNQUFNLEdBQVQsRUFBYztBQUFDLGVBQU8sT0FBTyxNQUFNLEdBQWIsSUFBb0IsQ0FBM0I7QUFBOEI7QUFDN0MsVUFBRyxNQUFNLEdBQVQsRUFBYztBQUFDLGVBQU8sT0FBTyxNQUFNLEdBQWIsSUFBb0IsQ0FBM0I7QUFBOEI7QUFDN0MsYUFBTyxHQUFQO0FBQ0Q7Ozs4QkFDUyxJLEVBQU0sUSxFQUFVLE8sRUFBUyxPLEVBQVM7QUFDMUMsVUFBSSxJQUFJLEtBQUssY0FBTCxFQUFSO0FBQ0EsVUFBSSxJQUFJLEtBQUssV0FBTCxFQUFSO0FBQ0EsVUFBSSxLQUFKLEVBQVcsSUFBWDtBQUNBLGNBQVEsUUFBUjtBQUNFLGFBQUssS0FBTDtBQUNFLGNBQUksV0FBVyxJQUFJLElBQUosQ0FBUyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWYsQ0FBVCxDQUFmO0FBQ0EsY0FBSSxVQUFVLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsS0FBSyxXQUFMLENBQWlCLElBQWpCLENBQWYsQ0FBVCxDQUFkO0FBQ0Esa0JBQVEsSUFBSSxJQUFKLENBQVMsS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixPQUFuQixDQUFULEVBQXNDLFVBQXRDLEVBQVI7QUFDQSxpQkFBTyxJQUFJLElBQUosQ0FBUyxLQUFLLEdBQUwsQ0FBUyxPQUFULEVBQWtCLE9BQWxCLENBQVQsRUFBcUMsVUFBckMsRUFBUDtBQUNBO0FBQ0YsYUFBSyxPQUFMO0FBQ0UsY0FBSSxhQUFhLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixDQUFULENBQWpCO0FBQ0EsY0FBSSxZQUFZLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxFQUFaLEVBQWdCLEVBQWhCLENBQVQsQ0FBaEI7QUFDQSxrQkFBUSxJQUFJLElBQUosQ0FBUyxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLE9BQXJCLENBQVQsRUFBd0MsV0FBeEMsRUFBUjtBQUNBLGlCQUFPLElBQUksSUFBSixDQUFTLEtBQUssR0FBTCxDQUFTLFNBQVQsRUFBb0IsT0FBcEIsQ0FBVCxFQUF1QyxXQUF2QyxFQUFQO0FBQ0E7QUFDRixhQUFLLE1BQUw7QUFDRSxjQUFJLFlBQVksS0FBSyxPQUFMLEVBQWhCO0FBQ0EsY0FBSSxXQUFXLEtBQUssT0FBTCxFQUFmO0FBQ0Esa0JBQVEsSUFBSSxJQUFKLENBQVMsS0FBSyxHQUFMLENBQVMsU0FBVCxFQUFvQixPQUFwQixDQUFULEVBQXVDLGNBQXZDLEVBQVI7QUFDQSxpQkFBTyxJQUFJLElBQUosQ0FBUyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLE9BQW5CLENBQVQsRUFBc0MsY0FBdEMsRUFBUDtBQUNBO0FBbEJKO0FBb0JBLGFBQU8sRUFBRSxPQUFPLEtBQVQsRUFBZ0IsTUFBTSxJQUF0QixFQUFQO0FBQ0Q7Ozs2QkFDUSxJLEVBQU0sUSxFQUFVLE0sRUFBUSxPLEVBQVMsTyxFQUFTO0FBQ2pELGdCQUFVLFdBQVcsS0FBSyxPQUFMLEVBQXJCO0FBQ0EsZ0JBQVUsV0FBVyxLQUFLLE9BQUwsRUFBckI7QUFDQSxVQUFJLFFBQVEsS0FBSyxTQUFMLENBQWUsSUFBZixFQUFxQixRQUFyQixFQUErQixPQUEvQixFQUF3QyxPQUF4QyxDQUFaO0FBQ0EsVUFBSSxNQUFNLE1BQU0sS0FBaEI7QUFDQSxVQUFJLE1BQU0sTUFBTSxJQUFoQjtBQUNBLFVBQUksTUFBTSxLQUFLLFVBQUwsRUFBVjtBQUNBLFVBQUksUUFBUSxLQUFLLFdBQUwsRUFBWjtBQUNBLFVBQUksT0FBTyxLQUFLLGNBQUwsRUFBWDtBQUNBLGNBQVEsUUFBUjtBQUNFLGFBQUssS0FBTDtBQUNFLGdCQUFNLEtBQUssSUFBTCxDQUFVLE1BQU0sTUFBaEIsRUFBd0IsR0FBeEIsRUFBNkIsR0FBN0IsQ0FBTjtBQUNBO0FBQ0YsYUFBSyxPQUFMO0FBQ0Usa0JBQVEsS0FBSyxJQUFMLENBQVUsUUFBUSxNQUFsQixFQUEwQixHQUExQixFQUErQixHQUEvQixDQUFSO0FBQ0E7QUFDRixhQUFLLE1BQUw7QUFDRSxpQkFBTyxLQUFLLElBQUwsQ0FBVSxPQUFPLE1BQWpCLEVBQXlCLEdBQXpCLEVBQThCLEdBQTlCLENBQVA7QUFDQTtBQUNGO0FBQ0UsZ0JBQU0sSUFBSSxLQUFKLENBQVUsa0NBQWtDLFFBQTVDLENBQU47QUFYSjtBQWFBLFVBQUksY0FBYyxLQUFLLFdBQUwsQ0FBaUIsRUFBQyxNQUFNLElBQVAsRUFBYSxPQUFPLEtBQXBCLEVBQWpCLENBQWxCO0FBQ0EsVUFBRyxNQUFNLFdBQVQsRUFBc0I7QUFDcEIsY0FBTSxXQUFOO0FBQ0Q7QUFDRCxVQUFJLFVBQVUsSUFBSSxJQUFKLENBQVMsS0FBSyxHQUFMLENBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0IsR0FBdEIsQ0FBVCxDQUFkO0FBQ0EsZ0JBQVUsSUFBSSxJQUFKLENBQVMsS0FBSyxLQUFMLENBQVcsT0FBWCxFQUFvQixPQUFwQixFQUE2QixPQUE3QixDQUFULENBQVY7QUFDQSxhQUFPLE9BQVA7QUFDRDs7O3dCQUNHLEssRUFBTyxLLEVBQU8sTyxFQUFTO0FBQ3pCLGNBQVEsS0FBSyxLQUFiO0FBQ0EsVUFBRyxNQUFNLE1BQU4sR0FBZSxLQUFsQixFQUF5QjtBQUN2QixZQUFJLE1BQU0sUUFBUSxNQUFNLE1BQXhCO0FBQ0EsZ0JBQVEsS0FBSyxNQUFMLENBQVksT0FBWixFQUFxQixHQUFyQixJQUE0QixLQUFwQztBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozs7OztrQkFsTWtCLEs7Ozs7Ozs7Ozs7Ozs7O3NEQ0hiLE87Ozs7Ozs7Ozs2REFDQSxPOzs7Ozs7Ozs7bURBQ0EsTzs7Ozs7Ozs7OzhDQUNBLE87Ozs7Ozs7Ozs0Q0FDQSxPOzs7Ozs7Ozs7c0RBQ0EsTyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3QnXSA6IG51bGwpLCAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snUmVhY3RET00nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ1JlYWN0RE9NJ10gOiBudWxsKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiLCBcInJlYWN0LWRvbVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdERyYWdnYWJsZVwiXSA9IGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCksICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdERPTSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3RET00nXSA6IG51bGwpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdERyYWdnYWJsZVwiXSA9IGZhY3Rvcnkocm9vdFtcIlJlYWN0XCJdLCByb290W1wiUmVhY3RET01cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuZGVmYXVsdDtcblx0bW9kdWxlLmV4cG9ydHMuRHJhZ2dhYmxlQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuZGVmYXVsdDtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblx0XG5cdHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXHRcblx0dmFyIF9yZWFjdERvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblx0XG5cdHZhciBfY2xhc3NuYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cdFxuXHR2YXIgX2RvbUZucyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX3Bvc2l0aW9uRm5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0XG5cdHZhciBfc2hpbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9EcmFnZ2FibGVDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfRHJhZ2dhYmxlQ29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGVDb3JlKTtcblx0XG5cdHZhciBfbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHR2YXIgX2xvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2cpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblx0Ly8gJEZsb3dJZ25vcmVcblx0XG5cdFxuXHQvKjo6IGltcG9ydCB0eXBlIHtEcmFnZ2FibGVFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG5cdC8qOjogdHlwZSBEcmFnZ2FibGVTdGF0ZSA9IHtcblx0ICBkcmFnZ2luZzogYm9vbGVhbixcblx0ICBkcmFnZ2VkOiBib29sZWFuLFxuXHQgIHg6IG51bWJlciwgeTogbnVtYmVyLFxuXHQgIHNsYWNrWDogbnVtYmVyLCBzbGFja1k6IG51bWJlcixcblx0ICBpc0VsZW1lbnRTVkc6IGJvb2xlYW5cblx0fTsqL1xuXHRcblx0XG5cdC8vXG5cdC8vIERlZmluZSA8RHJhZ2dhYmxlPlxuXHQvL1xuXHRcblx0Lyo6OiB0eXBlIENvbnN0cnVjdG9yUHJvcHMgPSB7XG5cdCAgcG9zaXRpb246IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSxcblx0ICBkZWZhdWx0UG9zaXRpb246IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfVxuXHR9OyovXG5cdFxuXHR2YXIgRHJhZ2dhYmxlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoRHJhZ2dhYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcblx0XG5cdCAgZnVuY3Rpb24gRHJhZ2dhYmxlKHByb3BzIC8qOiBDb25zdHJ1Y3RvclByb3BzKi8pIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFnZ2FibGUpO1xuXHRcblx0ICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEcmFnZ2FibGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcmFnZ2FibGUpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cdFxuXHQgICAgX3RoaXMub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgY29yZURhdGEpIHtcblx0ICAgICAgKDAsIF9sb2cyLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0YXJ0OiAlaicsIGNvcmVEYXRhKTtcblx0XG5cdCAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cblx0ICAgICAgdmFyIHNob3VsZFN0YXJ0ID0gX3RoaXMucHJvcHMub25TdGFydChlLCAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKF90aGlzLCBjb3JlRGF0YSkpO1xuXHQgICAgICAvLyBLaWxscyBzdGFydCBldmVudCBvbiBjb3JlIGFzIHdlbGwsIHNvIG1vdmUgaGFuZGxlcnMgYXJlIG5ldmVyIGJvdW5kLlxuXHQgICAgICBpZiAoc2hvdWxkU3RhcnQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdFxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGRyYWdnaW5nOiB0cnVlLCBkcmFnZ2VkOiB0cnVlIH0pO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgY29yZURhdGEpIHtcblx0ICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnOiAlaicsIGNvcmVEYXRhKTtcblx0XG5cdCAgICAgIHZhciB1aURhdGEgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKF90aGlzLCBjb3JlRGF0YSk7XG5cdFxuXHQgICAgICB2YXIgbmV3U3RhdGUgLyo6ICRTaGFwZTxEcmFnZ2FibGVTdGF0ZT4qLyA9IHtcblx0ICAgICAgICB4OiB1aURhdGEueCxcblx0ICAgICAgICB5OiB1aURhdGEueVxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgLy8gS2VlcCB3aXRoaW4gYm91bmRzLlxuXHQgICAgICBpZiAoX3RoaXMucHJvcHMuYm91bmRzKSB7XG5cdCAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCB4IGFuZCB5LlxuXHQgICAgICAgIHZhciBfeCA9IG5ld1N0YXRlLngsXG5cdCAgICAgICAgICAgIF95ID0gbmV3U3RhdGUueTtcblx0XG5cdCAgICAgICAgLy8gQWRkIHNsYWNrIHRvIHRoZSB2YWx1ZXMgdXNlZCB0byBjYWxjdWxhdGUgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBpZlxuXHQgICAgICAgIC8vIHdlIHN0YXJ0IHJlbW92aW5nIHNsYWNrLCB0aGUgZWxlbWVudCB3b24ndCByZWFjdCB0byBpdCByaWdodCBhd2F5IHVudGlsIGl0J3MgYmVlblxuXHQgICAgICAgIC8vIGNvbXBsZXRlbHkgcmVtb3ZlZC5cblx0XG5cdCAgICAgICAgbmV3U3RhdGUueCArPSBfdGhpcy5zdGF0ZS5zbGFja1g7XG5cdCAgICAgICAgbmV3U3RhdGUueSArPSBfdGhpcy5zdGF0ZS5zbGFja1k7XG5cdFxuXHQgICAgICAgIC8vIEdldCBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGNlaWwvZmxvb3IgdGhlIHggYW5kIHkgd2l0aGluIHRoZSBib3VuZGFyaWVzLlxuXHQgICAgICAgIC8vICRGbG93QnVnXG5cdFxuXHQgICAgICAgIC8vIFJlY2FsY3VsYXRlIHNsYWNrIGJ5IG5vdGluZyBob3cgbXVjaCB3YXMgc2hhdmVkIGJ5IHRoZSBib3VuZFBvc2l0aW9uIGhhbmRsZXIuXG5cdCAgICAgICAgdmFyIF9nZXRCb3VuZFBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRCb3VuZFBvc2l0aW9uKShfdGhpcywgbmV3U3RhdGUueCwgbmV3U3RhdGUueSk7XG5cdFxuXHQgICAgICAgIHZhciBfZ2V0Qm91bmRQb3NpdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfZ2V0Qm91bmRQb3NpdGlvbiwgMik7XG5cdFxuXHQgICAgICAgIG5ld1N0YXRlLnggPSBfZ2V0Qm91bmRQb3NpdGlvbjJbMF07XG5cdCAgICAgICAgbmV3U3RhdGUueSA9IF9nZXRCb3VuZFBvc2l0aW9uMlsxXTtcblx0ICAgICAgICBuZXdTdGF0ZS5zbGFja1ggPSBfdGhpcy5zdGF0ZS5zbGFja1ggKyAoX3ggLSBuZXdTdGF0ZS54KTtcblx0ICAgICAgICBuZXdTdGF0ZS5zbGFja1kgPSBfdGhpcy5zdGF0ZS5zbGFja1kgKyAoX3kgLSBuZXdTdGF0ZS55KTtcblx0XG5cdCAgICAgICAgLy8gVXBkYXRlIHRoZSBldmVudCB3ZSBmaXJlIHRvIHJlZmxlY3Qgd2hhdCByZWFsbHkgaGFwcGVuZWQgYWZ0ZXIgYm91bmRzIHRvb2sgZWZmZWN0LlxuXHQgICAgICAgIHVpRGF0YS54ID0gX3g7XG5cdCAgICAgICAgdWlEYXRhLnkgPSBfeTtcblx0ICAgICAgICB1aURhdGEuZGVsdGFYID0gbmV3U3RhdGUueCAtIF90aGlzLnN0YXRlLng7XG5cdCAgICAgICAgdWlEYXRhLmRlbHRhWSA9IG5ld1N0YXRlLnkgLSBfdGhpcy5zdGF0ZS55O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG5cdCAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBfdGhpcy5wcm9wcy5vbkRyYWcoZSwgdWlEYXRhKTtcblx0ICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcblx0ICAgIH07XG5cdFxuXHQgICAgX3RoaXMub25EcmFnU3RvcCA9IGZ1bmN0aW9uIChlLCBjb3JlRGF0YSkge1xuXHQgICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG5cdFxuXHQgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG5cdCAgICAgIHZhciBzaG91bGRTdG9wID0gX3RoaXMucHJvcHMub25TdG9wKGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX3RoaXMsIGNvcmVEYXRhKSk7XG5cdCAgICAgIGlmIChzaG91bGRTdG9wID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRcblx0ICAgICAgKDAsIF9sb2cyLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0b3A6ICVqJywgY29yZURhdGEpO1xuXHRcblx0ICAgICAgdmFyIG5ld1N0YXRlIC8qOiAkU2hhcGU8RHJhZ2dhYmxlU3RhdGU+Ki8gPSB7XG5cdCAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXHQgICAgICAgIHNsYWNrWDogMCxcblx0ICAgICAgICBzbGFja1k6IDBcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbiB3aWxsIGJlIHRvXG5cdCAgICAgIC8vIHJldmVydCBiYWNrIHRvIHRoZSBvbGQgcG9zaXRpb24uIFdlIGV4cGVjdCBhIGhhbmRsZXIgb24gYG9uRHJhZ1N0b3BgLCBhdCB0aGUgbGVhc3QuXG5cdCAgICAgIHZhciBjb250cm9sbGVkID0gQm9vbGVhbihfdGhpcy5wcm9wcy5wb3NpdGlvbik7XG5cdCAgICAgIGlmIChjb250cm9sbGVkKSB7XG5cdCAgICAgICAgdmFyIF90aGlzJHByb3BzJHBvc2l0aW9uID0gX3RoaXMucHJvcHMucG9zaXRpb24sXG5cdCAgICAgICAgICAgIF94MiA9IF90aGlzJHByb3BzJHBvc2l0aW9uLngsXG5cdCAgICAgICAgICAgIF95MiA9IF90aGlzJHByb3BzJHBvc2l0aW9uLnk7XG5cdFxuXHQgICAgICAgIG5ld1N0YXRlLnggPSBfeDI7XG5cdCAgICAgICAgbmV3U3RhdGUueSA9IF95Mjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5zdGF0ZSA9IHtcblx0ICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cblx0ICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXHRcblx0ICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgaGF2ZSBiZWVuIGRyYWdnZWQgYmVmb3JlLlxuXHQgICAgICBkcmFnZ2VkOiBmYWxzZSxcblx0XG5cdCAgICAgIC8vIEN1cnJlbnQgdHJhbnNmb3JtIHggYW5kIHkuXG5cdCAgICAgIHg6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueCA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi54LFxuXHQgICAgICB5OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnkgOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueSxcblx0XG5cdCAgICAgIC8vIFVzZWQgZm9yIGNvbXBlbnNhdGluZyBmb3Igb3V0LW9mLWJvdW5kcyBkcmFnc1xuXHQgICAgICBzbGFja1g6IDAsIHNsYWNrWTogMCxcblx0XG5cdCAgICAgIC8vIENhbiBvbmx5IGRldGVybWluZSBpZiBTVkcgYWZ0ZXIgbW91bnRpbmdcblx0ICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhEcmFnZ2FibGUsIFt7XG5cdCAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0ICAgICAgaWYgKHRoaXMucHJvcHMucG9zaXRpb24gJiYgISh0aGlzLnByb3BzLm9uRHJhZyB8fCB0aGlzLnByb3BzLm9uU3RvcCkpIHtcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0ICAgICAgICBjb25zb2xlLndhcm4oJ0EgYHBvc2l0aW9uYCB3YXMgYXBwbGllZCB0byB0aGlzIDxEcmFnZ2FibGU+LCB3aXRob3V0IGRyYWcgaGFuZGxlcnMuIFRoaXMgd2lsbCBtYWtlIHRoaXMgJyArICdjb21wb25lbnQgZWZmZWN0aXZlbHkgdW5kcmFnZ2FibGUuIFBsZWFzZSBhdHRhY2ggYG9uRHJhZ2Agb3IgYG9uU3RvcGAgaGFuZGxlcnMgc28geW91IGNhbiBhZGp1c3QgdGhlICcgKyAnYHBvc2l0aW9uYCBvZiB0aGlzIGVsZW1lbnQuJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG5cdCAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG5cdCAgICAgIGlmICh0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKHRoaXMpIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuXHQgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0VsZW1lbnRTVkc6IHRydWUgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcyAvKjogT2JqZWN0Ki8pIHtcblx0ICAgICAgLy8gU2V0IHgveSBpZiBwb3NpdGlvbiBoYXMgY2hhbmdlZFxuXHQgICAgICBpZiAobmV4dFByb3BzLnBvc2l0aW9uICYmICghdGhpcy5wcm9wcy5wb3NpdGlvbiB8fCBuZXh0UHJvcHMucG9zaXRpb24ueCAhPT0gdGhpcy5wcm9wcy5wb3NpdGlvbi54IHx8IG5leHRQcm9wcy5wb3NpdGlvbi55ICE9PSB0aGlzLnByb3BzLnBvc2l0aW9uLnkpKSB7XG5cdCAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHg6IG5leHRQcm9wcy5wb3NpdGlvbi54LCB5OiBuZXh0UHJvcHMucG9zaXRpb24ueSB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0ICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRyYWdnaW5nOiBmYWxzZSB9KTsgLy8gcHJldmVudHMgaW52YXJpYW50IGlmIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3JlbmRlcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8YW55PiovIHtcblx0ICAgICAgdmFyIF9jbGFzc05hbWVzO1xuXHRcblx0ICAgICAgdmFyIHN0eWxlID0ge30sXG5cdCAgICAgICAgICBzdmdUcmFuc2Zvcm0gPSBudWxsO1xuXHRcblx0ICAgICAgLy8gSWYgdGhpcyBpcyBjb250cm9sbGVkLCB3ZSBkb24ndCB3YW50IHRvIG1vdmUgaXQgLSB1bmxlc3MgaXQncyBkcmFnZ2luZy5cblx0ICAgICAgdmFyIGNvbnRyb2xsZWQgPSBCb29sZWFuKHRoaXMucHJvcHMucG9zaXRpb24pO1xuXHQgICAgICB2YXIgZHJhZ2dhYmxlID0gIWNvbnRyb2xsZWQgfHwgdGhpcy5zdGF0ZS5kcmFnZ2luZztcblx0XG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucHJvcHMucG9zaXRpb24gfHwgdGhpcy5wcm9wcy5kZWZhdWx0UG9zaXRpb247XG5cdCAgICAgIHZhciB0cmFuc2Zvcm1PcHRzID0ge1xuXHQgICAgICAgIC8vIFNldCBsZWZ0IGlmIGhvcml6b250YWwgZHJhZyBpcyBlbmFibGVkXG5cdCAgICAgICAgeDogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWCkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS54IDogcG9zaXRpb24ueCxcblx0XG5cdCAgICAgICAgLy8gU2V0IHRvcCBpZiB2ZXJ0aWNhbCBkcmFnIGlzIGVuYWJsZWRcblx0ICAgICAgICB5OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdZKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnkgOiBwb3NpdGlvbi55XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgd2FzIFNWRywgd2UgdXNlIHRoZSBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUuXG5cdCAgICAgIGlmICh0aGlzLnN0YXRlLmlzRWxlbWVudFNWRykge1xuXHQgICAgICAgIHN2Z1RyYW5zZm9ybSA9ICgwLCBfZG9tRm5zLmNyZWF0ZVNWR1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gQWRkIGEgQ1NTIHRyYW5zZm9ybSB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZC4gVGhpcyBhbGxvd3MgdXMgdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmRcblx0ICAgICAgICAvLyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlbGF0aXZlbHkgb3IgYWJzb2x1dGVseSBwb3NpdGlvbmVkLlxuXHQgICAgICAgIC8vIElmIHRoZSBpdGVtIHlvdSBhcmUgZHJhZ2dpbmcgYWxyZWFkeSBoYXMgYSB0cmFuc2Zvcm0gc2V0LCB3cmFwIGl0IGluIGEgPHNwYW4+IHNvIDxEcmFnZ2FibGU+XG5cdCAgICAgICAgLy8gaGFzIGEgY2xlYW4gc2xhdGUuXG5cdCAgICAgICAgc3R5bGUgPSAoMCwgX2RvbUZucy5jcmVhdGVDU1NUcmFuc2Zvcm0pKHRyYW5zZm9ybU9wdHMpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcblx0ICAgICAgICAgIGRlZmF1bHRDbGFzc05hbWUgPSBfcHJvcHMuZGVmYXVsdENsYXNzTmFtZSxcblx0ICAgICAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyA9IF9wcm9wcy5kZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmcsXG5cdCAgICAgICAgICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZCA9IF9wcm9wcy5kZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDtcblx0XG5cdCAgICAgIC8vIE1hcmsgd2l0aCBjbGFzcyB3aGlsZSBkcmFnZ2luZ1xuXHRcblx0ICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lczIuZGVmYXVsdCkodGhpcy5wcm9wcy5jaGlsZHJlbi5wcm9wcy5jbGFzc05hbWUgfHwgJycsIGRlZmF1bHRDbGFzc05hbWUsIChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZywgdGhpcy5zdGF0ZS5kcmFnZ2luZyksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQsIHRoaXMuc3RhdGUuZHJhZ2dlZCksIF9jbGFzc05hbWVzKSk7XG5cdFxuXHQgICAgICAvLyBSZXVzZSB0aGUgY2hpbGQgcHJvdmlkZWRcblx0ICAgICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0Yylcblx0ICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuXHQgICAgICAgIF9EcmFnZ2FibGVDb3JlMi5kZWZhdWx0LFxuXHQgICAgICAgIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsIG9uRHJhZzogdGhpcy5vbkRyYWcsIG9uU3RvcDogdGhpcy5vbkRyYWdTdG9wIH0pLFxuXHQgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jbG9uZUVsZW1lbnQoX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHtcblx0ICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuXHQgICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLmNoaWxkcmVuLnByb3BzLnN0eWxlLCBzdHlsZSksXG5cdCAgICAgICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuXHQgICAgICAgIH0pXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gRHJhZ2dhYmxlO1xuXHR9KF9yZWFjdDIuZGVmYXVsdC5Db21wb25lbnQpO1xuXHRcblx0RHJhZ2dhYmxlLmRpc3BsYXlOYW1lID0gJ0RyYWdnYWJsZSc7XG5cdERyYWdnYWJsZS5wcm9wVHlwZXMgPSBfZXh0ZW5kcyh7fSwgX0RyYWdnYWJsZUNvcmUyLmRlZmF1bHQucHJvcFR5cGVzLCB7XG5cdFxuXHQgIC8qKlxuXHQgICAqIGBheGlzYCBkZXRlcm1pbmVzIHdoaWNoIGF4aXMgdGhlIGRyYWdnYWJsZSBjYW4gbW92ZS5cblx0ICAgKlxuXHQgICAqICBOb3RlIHRoYXQgYWxsIGNhbGxiYWNrcyB3aWxsIHN0aWxsIHJldHVybiBkYXRhIGFzIG5vcm1hbC4gVGhpcyBvbmx5XG5cdCAgICogIGNvbnRyb2xzIGZsdXNoaW5nIHRvIHRoZSBET00uXG5cdCAgICpcblx0ICAgKiAnYm90aCcgYWxsb3dzIG1vdmVtZW50IGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cblx0ICAgKiAneCcgbGltaXRzIG1vdmVtZW50IHRvIGhvcml6b250YWwgYXhpcy5cblx0ICAgKiAneScgbGltaXRzIG1vdmVtZW50IHRvIHZlcnRpY2FsIGF4aXMuXG5cdCAgICogJ25vbmUnIGxpbWl0cyBhbGwgbW92ZW1lbnQuXG5cdCAgICpcblx0ICAgKiBEZWZhdWx0cyB0byAnYm90aCcuXG5cdCAgICovXG5cdCAgYXhpczogX3JlYWN0LlByb3BUeXBlcy5vbmVPZihbJ2JvdGgnLCAneCcsICd5JywgJ25vbmUnXSksXG5cdFxuXHQgIC8qKlxuXHQgICAqIGBib3VuZHNgIGRldGVybWluZXMgdGhlIHJhbmdlIG9mIG1vdmVtZW50IGF2YWlsYWJsZSB0byB0aGUgZWxlbWVudC5cblx0ICAgKiBBdmFpbGFibGUgdmFsdWVzIGFyZTpcblx0ICAgKlxuXHQgICAqICdwYXJlbnQnIHJlc3RyaWN0cyBtb3ZlbWVudCB3aXRoaW4gdGhlIERyYWdnYWJsZSdzIHBhcmVudCBub2RlLlxuXHQgICAqXG5cdCAgICogQWx0ZXJuYXRpdmVseSwgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMsIGFsbCBvZiB3aGljaCBhcmUgb3B0aW9uYWw6XG5cdCAgICpcblx0ICAgKiB7bGVmdDogTEVGVF9CT1VORCwgcmlnaHQ6IFJJR0hUX0JPVU5ELCBib3R0b206IEJPVFRPTV9CT1VORCwgdG9wOiBUT1BfQk9VTkR9XG5cdCAgICpcblx0ICAgKiBBbGwgdmFsdWVzIGFyZSBpbiBweC5cblx0ICAgKlxuXHQgICAqIEV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiBgYGBqc3hcblx0ICAgKiAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICogICAgICAgICByZXR1cm4gKFxuXHQgICAqICAgICAgICAgICAgPERyYWdnYWJsZSBib3VuZHM9e3tyaWdodDogMzAwLCBib3R0b206IDMwMH19PlxuXHQgICAqICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQ8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG5cdCAgICogICAgICAgICApO1xuXHQgICAqICAgICAgIH1cblx0ICAgKiAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIGJvdW5kczogX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUoW19yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuXHQgICAgbGVmdDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cdCAgICByaWdodDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cdCAgICB0b3A6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuXHQgICAgYm90dG9tOiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxuXHQgIH0pLCBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0LlByb3BUeXBlcy5vbmVPZihbZmFsc2VdKV0pLFxuXHRcblx0ICBkZWZhdWx0Q2xhc3NOYW1lOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuXHQgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcblx0XG5cdCAgLyoqXG5cdCAgICogYGRlZmF1bHRQb3NpdGlvbmAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgdGhlIGRyYWdnZWQgaXRlbSBzaG91bGQgc3RhcnQgYXRcblx0ICAgKlxuXHQgICAqIEV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiBgYGBqc3hcblx0ICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICogICAgICAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGRlZmF1bHRQb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuXHQgICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICAgICAgKTtcblx0ICAgKiAgICAgICAgICB9XG5cdCAgICogICAgICB9KTtcblx0ICAgKiBgYGBcblx0ICAgKi9cblx0ICBkZWZhdWx0UG9zaXRpb246IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuXHQgICAgeDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cdCAgICB5OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlclxuXHQgIH0pLFxuXHRcblx0ICAvKipcblx0ICAgKiBgcG9zaXRpb25gLCBpZiBwcmVzZW50LCBkZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuXHQgICAqXG5cdCAgICogIFRoaXMgaXMgc2ltaWxhciB0byBob3cgZm9ybSBlbGVtZW50cyBpbiBSZWFjdCB3b3JrIC0gaWYgbm8gYHBvc2l0aW9uYCBpcyBzdXBwbGllZCwgdGhlIGNvbXBvbmVudFxuXHQgICAqICBpcyB1bmNvbnRyb2xsZWQuXG5cdCAgICpcblx0ICAgKiBFeGFtcGxlOlxuXHQgICAqXG5cdCAgICogYGBganN4XG5cdCAgICogICAgICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXHQgICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAqICAgICAgICAgICAgICByZXR1cm4gKFxuXHQgICAqICAgICAgICAgICAgICAgICAgPERyYWdnYWJsZSBwb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuXHQgICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICAgICAgKTtcblx0ICAgKiAgICAgICAgICB9XG5cdCAgICogICAgICB9KTtcblx0ICAgKiBgYGBcblx0ICAgKi9cblx0ICBwb3NpdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG5cdCAgICB4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG5cdCAgfSksXG5cdFxuXHQgIC8qKlxuXHQgICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cblx0ICAgKi9cblx0ICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG5cdCAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG5cdCAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG5cdH0pO1xuXHREcmFnZ2FibGUuZGVmYXVsdFByb3BzID0gX2V4dGVuZHMoe30sIF9EcmFnZ2FibGVDb3JlMi5kZWZhdWx0LmRlZmF1bHRQcm9wcywge1xuXHQgIGF4aXM6ICdib3RoJyxcblx0ICBib3VuZHM6IGZhbHNlLFxuXHQgIGRlZmF1bHRDbGFzc05hbWU6ICdyZWFjdC1kcmFnZ2FibGUnLFxuXHQgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZycsXG5cdCAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6ICdyZWFjdC1kcmFnZ2FibGUtZHJhZ2dlZCcsXG5cdCAgZGVmYXVsdFBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcblx0ICBwb3NpdGlvbjogbnVsbFxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXG5cdCAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG5cdCAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcblx0ICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG5cdCovXG5cdC8qIGdsb2JhbCBkZWZpbmUgKi9cblx0XG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRcdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdFx0dmFyIGNsYXNzZXMgPSBbXTtcblx0XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cdFxuXHRcdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFxuXHRcdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHRcdH1cblx0XG5cdFx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdFx0fSBlbHNlIGlmICh0cnVlKSB7XG5cdFx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0XHQhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdFx0fS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdFx0fVxuXHR9KCkpO1xuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cdFxuXHRleHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3Rvcjtcblx0ZXhwb3J0cy5tYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8gPSBtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG87XG5cdGV4cG9ydHMuYWRkRXZlbnQgPSBhZGRFdmVudDtcblx0ZXhwb3J0cy5yZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50O1xuXHRleHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5cdGV4cG9ydHMub3V0ZXJXaWR0aCA9IG91dGVyV2lkdGg7XG5cdGV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcblx0ZXhwb3J0cy5pbm5lcldpZHRoID0gaW5uZXJXaWR0aDtcblx0ZXhwb3J0cy5vZmZzZXRYWUZyb21QYXJlbnQgPSBvZmZzZXRYWUZyb21QYXJlbnQ7XG5cdGV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuXHRleHBvcnRzLmNyZWF0ZVNWR1RyYW5zZm9ybSA9IGNyZWF0ZVNWR1RyYW5zZm9ybTtcblx0ZXhwb3J0cy5nZXRUb3VjaCA9IGdldFRvdWNoO1xuXHRleHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcblx0ZXhwb3J0cy5hZGRVc2VyU2VsZWN0U3R5bGVzID0gYWRkVXNlclNlbGVjdFN0eWxlcztcblx0ZXhwb3J0cy5yZW1vdmVVc2VyU2VsZWN0U3R5bGVzID0gcmVtb3ZlVXNlclNlbGVjdFN0eWxlcztcblx0ZXhwb3J0cy5zdHlsZUhhY2tzID0gc3R5bGVIYWNrcztcblx0XG5cdHZhciBfc2hpbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9nZXRQcmVmaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF9nZXRQcmVmaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJlZml4KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXHRcblx0Lyo6OiBpbXBvcnQgdHlwZSB7Q29udHJvbFBvc2l0aW9ufSBmcm9tICcuL3R5cGVzJzsqL1xuXHRcblx0XG5cdHZhciBtYXRjaGVzU2VsZWN0b3JGdW5jID0gJyc7XG5cdGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvcihlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8pIC8qOiBib29sZWFuKi8ge1xuXHQgIGlmICghbWF0Y2hlc1NlbGVjdG9yRnVuYykge1xuXHQgICAgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ29NYXRjaGVzU2VsZWN0b3InXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuXHQgICAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cdCAgICAgIHJldHVybiAoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21ldGhvZF0pO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cdCAgcmV0dXJuIGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdLmNhbGwoZWwsIHNlbGVjdG9yKTtcblx0fVxuXHRcblx0Ly8gV29ya3MgdXAgdGhlIHRyZWUgdG8gdGhlIGRyYWdnYWJsZSBpdHNlbGYgYXR0ZW1wdGluZyB0byBtYXRjaCBzZWxlY3Rvci5cblx0ZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLywgYmFzZU5vZGUgLyo6IE5vZGUqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgdmFyIG5vZGUgPSBlbDtcblx0ICBkbyB7XG5cdCAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG5cdCAgICBpZiAobm9kZSA9PT0gYmFzZU5vZGUpIHJldHVybiBmYWxzZTtcblx0ICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgfSB3aGlsZSAobm9kZSk7XG5cdFxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLykgLyo6IHZvaWQqLyB7XG5cdCAgaWYgKCFlbCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0ICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG5cdCAgfSBlbHNlIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuXHQgICAgZWxbJ29uJyArIGV2ZW50XSA9IGhhbmRsZXI7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZW1vdmVFdmVudChlbCAvKjogP05vZGUqLywgZXZlbnQgLyo6IHN0cmluZyovLCBoYW5kbGVyIC8qOiBGdW5jdGlvbiovKSAvKjogdm9pZCovIHtcblx0ICBpZiAoIWVsKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChlbC5kZXRhY2hFdmVudCkge1xuXHQgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcblx0ICB9IGVsc2UgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cdCAgICBlbFsnb24nICsgZXZlbnRdID0gbnVsbDtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG91dGVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqLyB7XG5cdCAgLy8gVGhpcyBpcyBkZWxpYmVyYXRlbHkgZXhjbHVkaW5nIG1hcmdpbiBmb3Igb3VyIGNhbGN1bGF0aW9ucywgc2luY2Ugd2UgYXJlIHVzaW5nXG5cdCAgLy8gb2Zmc2V0VG9wIHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG5cdCAgdmFyIGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgaGVpZ2h0ICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoKTtcblx0ICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuXHQgIHJldHVybiBoZWlnaHQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG91dGVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcblx0ICAvLyBvZmZzZXRMZWZ0IHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG5cdCAgdmFyIHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcblx0ICB2YXIgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHQgIHdpZHRoICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCk7XG5cdCAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdCAgcmV0dXJuIHdpZHRoO1xuXHR9XG5cdGZ1bmN0aW9uIGlubmVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqLyB7XG5cdCAgdmFyIGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApO1xuXHQgIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcblx0ICByZXR1cm4gaGVpZ2h0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpbm5lcldpZHRoKG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqLyB7XG5cdCAgdmFyIHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcblx0ICB2YXIgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHQgIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KTtcblx0ICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuXHQgIHJldHVybiB3aWR0aDtcblx0fVxuXHRcblx0Ly8gR2V0IGZyb20gb2Zmc2V0UGFyZW50XG5cdGZ1bmN0aW9uIG9mZnNldFhZRnJvbVBhcmVudChldnQgLyo6IHtjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn0qLywgb2Zmc2V0UGFyZW50IC8qOiBIVE1MRWxlbWVudCovKSAvKjogQ29udHJvbFBvc2l0aW9uKi8ge1xuXHQgIHZhciBpc0JvZHkgPSBvZmZzZXRQYXJlbnQgPT09IG9mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG5cdCAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBpc0JvZHkgPyB7IGxlZnQ6IDAsIHRvcDogMCB9IDogb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcblx0ICB2YXIgeCA9IGV2dC5jbGllbnRYICsgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQgLSBvZmZzZXRQYXJlbnRSZWN0LmxlZnQ7XG5cdCAgdmFyIHkgPSBldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcDtcblx0XG5cdCAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjcmVhdGVDU1NUcmFuc2Zvcm0oX3JlZikgLyo6IE9iamVjdCovIHtcblx0ICB2YXIgeCA9IF9yZWYueCxcblx0ICAgICAgeSA9IF9yZWYueTtcblx0XG5cdCAgLy8gUmVwbGFjZSB1bml0bGVzcyBpdGVtcyB3aXRoIHB4XG5cdCAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgKDAsIF9nZXRQcmVmaXguYnJvd3NlclByZWZpeFRvS2V5KSgndHJhbnNmb3JtJywgX2dldFByZWZpeDIuZGVmYXVsdCksICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNyZWF0ZVNWR1RyYW5zZm9ybShfcmVmMykgLyo6IHN0cmluZyovIHtcblx0ICB2YXIgeCA9IF9yZWYzLngsXG5cdCAgICAgIHkgPSBfcmVmMy55O1xuXHRcblx0ICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSc7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldFRvdWNoKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCBpZGVudGlmaWVyIC8qOiBudW1iZXIqLykgLyo6ID97Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9Ki8ge1xuXHQgIHJldHVybiBlLnRhcmdldFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS50YXJnZXRUb3VjaGVzLCBmdW5jdGlvbiAodCkge1xuXHQgICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IHQuaWRlbnRpZmllcjtcblx0ICB9KSB8fCBlLmNoYW5nZWRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0KSB7XG5cdCAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyO1xuXHQgIH0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXRUb3VjaElkZW50aWZpZXIoZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pIC8qOiA/bnVtYmVyKi8ge1xuXHQgIGlmIChlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzWzBdKSByZXR1cm4gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG5cdCAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlc1swXSkgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcblx0fVxuXHRcblx0Ly8gVXNlci1zZWxlY3QgSGFja3M6XG5cdC8vXG5cdC8vIFVzZWZ1bCBmb3IgcHJldmVudGluZyBibHVlIGhpZ2hsaWdodHMgYWxsIG92ZXIgZXZlcnl0aGluZyB3aGVuIGRyYWdnaW5nLlxuXHR2YXIgdXNlclNlbGVjdFByZWZpeCA9ICgwLCBfZ2V0UHJlZml4LmdldFByZWZpeCkoJ3VzZXItc2VsZWN0Jyk7XG5cdHZhciB1c2VyU2VsZWN0ID0gKDAsIF9nZXRQcmVmaXguYnJvd3NlclByZWZpeFRvU3R5bGUpKCd1c2VyLXNlbGVjdCcsIHVzZXJTZWxlY3RQcmVmaXgpO1xuXHR2YXIgdXNlclNlbGVjdFN0eWxlID0gJzsnICsgdXNlclNlbGVjdCArICc6IG5vbmU7Jztcblx0dmFyIHVzZXJTZWxlY3RSZXBsYWNlUmVnRXhwID0gbmV3IFJlZ0V4cCgnOz8nICsgdXNlclNlbGVjdCArICc6IG5vbmU7Jyk7IC8vIGxlYWRpbmcgOyBub3QgcHJlc2VudCBvbiBJRVxuXHRcblx0Ly8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcblx0ZnVuY3Rpb24gYWRkVXNlclNlbGVjdFN0eWxlcyhib2R5IC8qOiBIVE1MRWxlbWVudCovKSB7XG5cdCAgdmFyIHN0eWxlID0gYm9keS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJyc7XG5cdCAgYm9keS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGUgKyB1c2VyU2VsZWN0U3R5bGUpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiByZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGJvZHkgLyo6IEhUTUxFbGVtZW50Ki8pIHtcblx0ICB2YXIgc3R5bGUgPSBib2R5LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcblx0ICBib2R5LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZS5yZXBsYWNlKHVzZXJTZWxlY3RSZXBsYWNlUmVnRXhwLCAnJykpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzdHlsZUhhY2tzKCkgLyo6IE9iamVjdCovIHtcblx0ICB2YXIgY2hpbGRTdHlsZSAvKjogT2JqZWN0Ki8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHRcblx0ICAvLyBXb3JrYXJvdW5kIElFIHBvaW50ZXIgZXZlbnRzOyBzZWUgIzUxXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvcmVhY3QtZHJhZ2dhYmxlL2lzc3Vlcy81MSNpc3N1ZWNvbW1lbnQtMTAzNDg4Mjc4XG5cdCAgcmV0dXJuIF9leHRlbmRzKHtcblx0ICAgIHRvdWNoQWN0aW9uOiAnbm9uZSdcblx0ICB9LCBjaGlsZFN0eWxlKTtcblx0fVxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZmluZEluQXJyYXkgPSBmaW5kSW5BcnJheTtcblx0ZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblx0ZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuXHRleHBvcnRzLmludCA9IGludDtcblx0ZXhwb3J0cy5kb250U2V0TWUgPSBkb250U2V0TWU7XG5cdFxuXHQvLyBAY3JlZGl0cyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yb2dvemhuaWtvZmYvYTQzY2ZlZDI3YzQxZTRlNjhjZGNcblx0ZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqLyB7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIFthcnJheVtpXSwgaSwgYXJyYXldKSkgcmV0dXJuIGFycmF5W2ldO1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRcblx0ZnVuY3Rpb24gaXNOdW0obnVtIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmICFpc05hTihudW0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqLyB7XG5cdCAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZG9udFNldE1lKHByb3BzIC8qOiBPYmplY3QqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovLCBjb21wb25lbnROYW1lIC8qOiBzdHJpbmcqLykge1xuXHQgIGlmIChwcm9wc1twcm9wTmFtZV0pIHtcblx0ICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcCAnICsgcHJvcE5hbWUgKyAnIHBhc3NlZCB0byAnICsgY29tcG9uZW50TmFtZSArICcgLSBkbyBub3Qgc2V0IHRoaXMsIHNldCBpdCBvbiB0aGUgY2hpbGQuJyk7XG5cdCAgfVxuXHR9XG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5nZXRQcmVmaXggPSBnZXRQcmVmaXg7XG5cdGV4cG9ydHMuYnJvd3NlclByZWZpeFRvS2V5ID0gYnJvd3NlclByZWZpeFRvS2V5O1xuXHRleHBvcnRzLmJyb3dzZXJQcmVmaXhUb1N0eWxlID0gYnJvd3NlclByZWZpeFRvU3R5bGU7XG5cdHZhciBwcmVmaXhlcyA9IFsnTW96JywgJ1dlYmtpdCcsICdPJywgJ21zJ107XG5cdGZ1bmN0aW9uIGdldFByZWZpeCgpIC8qOiBzdHJpbmcqLyB7XG5cdCAgdmFyIHByb3AgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcblx0XG5cdCAgLy8gQ2hlY2tpbmcgc3BlY2lmaWNhbGx5IGZvciAnd2luZG93LmRvY3VtZW50JyBpcyBmb3IgcHNldWRvLWJyb3dzZXIgc2VydmVyLXNpZGVcblx0ICAvLyBlbnZpcm9ubWVudHMgdGhhdCBkZWZpbmUgJ3dpbmRvdycgYXMgdGhlIGdsb2JhbCBjb250ZXh0LlxuXHQgIC8vIEUuZy4gUmVhY3QtcmFpbHMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yYWlscy9wdWxsLzg0KVxuXHQgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LmRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuXHRcblx0ICB2YXIgc3R5bGUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXHRcblx0ICBpZiAocHJvcCBpbiBzdHlsZSkgcmV0dXJuICcnO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoYnJvd3NlclByZWZpeFRvS2V5KHByb3AsIHByZWZpeGVzW2ldKSBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeGVzW2ldO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuICcnO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBicm93c2VyUHJlZml4VG9LZXkocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqLyB7XG5cdCAgcmV0dXJuIHByZWZpeCA/ICcnICsgcHJlZml4ICsga2ViYWJUb1RpdGxlQ2FzZShwcm9wKSA6IHByb3A7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb1N0eWxlKHByb3AgLyo6IHN0cmluZyovLCBwcmVmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi8ge1xuXHQgIHJldHVybiBwcmVmaXggPyAnLScgKyBwcmVmaXgudG9Mb3dlckNhc2UoKSArICctJyArIHByb3AgOiBwcm9wO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBrZWJhYlRvVGl0bGVDYXNlKHN0ciAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqLyB7XG5cdCAgdmFyIG91dCA9ICcnO1xuXHQgIHZhciBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHNob3VsZENhcGl0YWxpemUpIHtcblx0ICAgICAgb3V0ICs9IHN0cltpXS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICBzaG91bGRDYXBpdGFsaXplID0gZmFsc2U7XG5cdCAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJy0nKSB7XG5cdCAgICAgIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0ICs9IHN0cltpXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG91dDtcblx0fVxuXHRcblx0Ly8gRGVmYXVsdCBleHBvcnQgaXMgdGhlIHByZWZpeCBpdHNlbGYsIGxpa2UgJ01veicsICdXZWJraXQnLCBldGNcblx0Ly8gTm90ZSB0aGF0IHlvdSBtYXkgaGF2ZSB0byByZS10ZXN0IGZvciBjZXJ0YWluIHRoaW5nczsgZm9yIGluc3RhbmNlLCBDaHJvbWUgNTBcblx0Ly8gY2FuIGhhbmRsZSB1bnByZWZpeGVkIGB0cmFuc2Zvcm1gLCBidXQgbm90IHVucHJlZml4ZWQgYHVzZXItc2VsZWN0YFxuXHRleHBvcnRzLmRlZmF1bHQgPSBnZXRQcmVmaXgoKTtcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmdldEJvdW5kUG9zaXRpb24gPSBnZXRCb3VuZFBvc2l0aW9uO1xuXHRleHBvcnRzLnNuYXBUb0dyaWQgPSBzbmFwVG9HcmlkO1xuXHRleHBvcnRzLmNhbkRyYWdYID0gY2FuRHJhZ1g7XG5cdGV4cG9ydHMuY2FuRHJhZ1kgPSBjYW5EcmFnWTtcblx0ZXhwb3J0cy5nZXRDb250cm9sUG9zaXRpb24gPSBnZXRDb250cm9sUG9zaXRpb247XG5cdGV4cG9ydHMuY3JlYXRlQ29yZURhdGEgPSBjcmVhdGVDb3JlRGF0YTtcblx0ZXhwb3J0cy5jcmVhdGVEcmFnZ2FibGVEYXRhID0gY3JlYXRlRHJhZ2dhYmxlRGF0YTtcblx0XG5cdHZhciBfc2hpbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9yZWFjdERvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblx0XG5cdHZhciBfZG9tRm5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHQvKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZSBmcm9tICcuLi9EcmFnZ2FibGUnOyovXG5cdC8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgQ29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVEYXRhfSBmcm9tICcuL3R5cGVzJzsqL1xuXHQvKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZUNvcmUgZnJvbSAnLi4vRHJhZ2dhYmxlQ29yZSc7Ki9cblx0ZnVuY3Rpb24gZ2V0Qm91bmRQb3NpdGlvbihkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8ge1xuXHQgIC8vIElmIG5vIGJvdW5kcywgc2hvcnQtY2lyY3VpdCBhbmQgbW92ZSBvblxuXHQgIGlmICghZHJhZ2dhYmxlLnByb3BzLmJvdW5kcykgcmV0dXJuIFt4LCB5XTtcblx0XG5cdCAgLy8gQ2xvbmUgbmV3IGJvdW5kc1xuXHQgIHZhciBib3VuZHMgPSBkcmFnZ2FibGUucHJvcHMuYm91bmRzO1xuXHRcblx0ICBib3VuZHMgPSB0eXBlb2YgYm91bmRzID09PSAnc3RyaW5nJyA/IGJvdW5kcyA6IGNsb25lQm91bmRzKGJvdW5kcyk7XG5cdCAgdmFyIG5vZGUgPSBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcblx0XG5cdCAgaWYgKHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnKSB7XG5cdCAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcblx0XG5cdCAgICB2YXIgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHQgICAgdmFyIGJvdW5kTm9kZSA9IHZvaWQgMDtcblx0ICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG5cdCAgICAgIGJvdW5kTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGJvdW5kTm9kZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuXHQgICAgICBpZiAoIWJvdW5kTm9kZSkgdGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgc2VsZWN0b3IgXCInICsgYm91bmRzICsgJ1wiIGNvdWxkIG5vdCBmaW5kIGFuIGVsZW1lbnQuJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgbm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0ICAgIHZhciBib3VuZE5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYm91bmROb2RlKTtcblx0ICAgIC8vIENvbXB1dGUgYm91bmRzLiBUaGlzIGlzIGEgcGFpbiB3aXRoIHBhZGRpbmcgYW5kIG9mZnNldHMgYnV0IHRoaXMgZ2V0cyBpdCBleGFjdGx5IHJpZ2h0LlxuXHQgICAgYm91bmRzID0ge1xuXHQgICAgICBsZWZ0OiAtbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdMZWZ0KSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luTGVmdCksXG5cdCAgICAgIHRvcDogLW5vZGUub2Zmc2V0VG9wICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdUb3ApICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5ib3JkZXJUb3BXaWR0aCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpblRvcCksXG5cdCAgICAgIHJpZ2h0OiAoMCwgX2RvbUZucy5pbm5lcldpZHRoKShib3VuZE5vZGUpIC0gKDAsIF9kb21GbnMub3V0ZXJXaWR0aCkobm9kZSkgLSBub2RlLm9mZnNldExlZnQsXG5cdCAgICAgIGJvdHRvbTogKDAsIF9kb21GbnMuaW5uZXJIZWlnaHQpKGJvdW5kTm9kZSkgLSAoMCwgX2RvbUZucy5vdXRlckhlaWdodCkobm9kZSkgLSBub2RlLm9mZnNldFRvcFxuXHQgICAgfTtcblx0ICB9XG5cdFxuXHQgIC8vIEtlZXAgeCBhbmQgeSBiZWxvdyByaWdodCBhbmQgYm90dG9tIGxpbWl0cy4uLlxuXHQgIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMucmlnaHQpKSB4ID0gTWF0aC5taW4oeCwgYm91bmRzLnJpZ2h0KTtcblx0ICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTtcblx0XG5cdCAgLy8gQnV0IGFib3ZlIGxlZnQgYW5kIHRvcCBsaW1pdHMuXG5cdCAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5sZWZ0KSkgeCA9IE1hdGgubWF4KHgsIGJvdW5kcy5sZWZ0KTtcblx0ICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLnRvcCkpIHkgPSBNYXRoLm1heCh5LCBib3VuZHMudG9wKTtcblx0XG5cdCAgcmV0dXJuIFt4LCB5XTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gc25hcFRvR3JpZChncmlkIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8sIHBlbmRpbmdYIC8qOiBudW1iZXIqLywgcGVuZGluZ1kgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSovIHtcblx0ICB2YXIgeCA9IE1hdGgucm91bmQocGVuZGluZ1ggLyBncmlkWzBdKSAqIGdyaWRbMF07XG5cdCAgdmFyIHkgPSBNYXRoLnJvdW5kKHBlbmRpbmdZIC8gZ3JpZFsxXSkgKiBncmlkWzFdO1xuXHQgIHJldHVybiBbeCwgeV07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNhbkRyYWdYKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi8ge1xuXHQgIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneCc7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNhbkRyYWdZKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi8ge1xuXHQgIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneSc7XG5cdH1cblx0XG5cdC8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXG5cdGZ1bmN0aW9uIGdldENvbnRyb2xQb3NpdGlvbihlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgdG91Y2hJZGVudGlmaWVyIC8qOiA/bnVtYmVyKi8sIGRyYWdnYWJsZUNvcmUgLyo6IERyYWdnYWJsZUNvcmUqLykgLyo6ID9Db250cm9sUG9zaXRpb24qLyB7XG5cdCAgdmFyIHRvdWNoT2JqID0gdHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgPyAoMCwgX2RvbUZucy5nZXRUb3VjaCkoZSwgdG91Y2hJZGVudGlmaWVyKSA6IG51bGw7XG5cdCAgaWYgKHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInICYmICF0b3VjaE9iaikgcmV0dXJuIG51bGw7IC8vIG5vdCB0aGUgcmlnaHQgdG91Y2hcblx0ICB2YXIgbm9kZSA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShkcmFnZ2FibGVDb3JlKTtcblx0ICAvLyBVc2VyIGNhbiBwcm92aWRlIGFuIG9mZnNldFBhcmVudCBpZiBkZXNpcmVkLlxuXHQgIHZhciBvZmZzZXRQYXJlbnQgPSBkcmFnZ2FibGVDb3JlLnByb3BzLm9mZnNldFBhcmVudCB8fCBub2RlLm9mZnNldFBhcmVudCB8fCBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcblx0ICByZXR1cm4gKDAsIF9kb21GbnMub2Zmc2V0WFlGcm9tUGFyZW50KSh0b3VjaE9iaiB8fCBlLCBvZmZzZXRQYXJlbnQpO1xuXHR9XG5cdFxuXHQvLyBDcmVhdGUgYW4gZGF0YSBvYmplY3QgZXhwb3NlZCBieSA8RHJhZ2dhYmxlQ29yZT4ncyBldmVudHNcblx0ZnVuY3Rpb24gY3JlYXRlQ29yZURhdGEoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGVDb3JlKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLykgLyo6IERyYWdnYWJsZURhdGEqLyB7XG5cdCAgdmFyIHN0YXRlID0gZHJhZ2dhYmxlLnN0YXRlO1xuXHQgIHZhciBpc1N0YXJ0ID0gISgwLCBfc2hpbXMuaXNOdW0pKHN0YXRlLmxhc3RYKTtcblx0XG5cdCAgaWYgKGlzU3RhcnQpIHtcblx0ICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IG1vdmUsIHVzZSB0aGUgeCBhbmQgeSBhcyBsYXN0IGNvb3Jkcy5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG5vZGU6IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShkcmFnZ2FibGUpLFxuXHQgICAgICBkZWx0YVg6IDAsIGRlbHRhWTogMCxcblx0ICAgICAgbGFzdFg6IHgsIGxhc3RZOiB5LFxuXHQgICAgICB4OiB4LCB5OiB5XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHByb3BlciB2YWx1ZXMuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBub2RlOiBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoZHJhZ2dhYmxlKSxcblx0ICAgICAgZGVsdGFYOiB4IC0gc3RhdGUubGFzdFgsIGRlbHRhWTogeSAtIHN0YXRlLmxhc3RZLFxuXHQgICAgICBsYXN0WDogc3RhdGUubGFzdFgsIGxhc3RZOiBzdGF0ZS5sYXN0WSxcblx0ICAgICAgeDogeCwgeTogeVxuXHQgICAgfTtcblx0ICB9XG5cdH1cblx0XG5cdC8vIENyZWF0ZSBhbiBkYXRhIGV4cG9zZWQgYnkgPERyYWdnYWJsZT4ncyBldmVudHNcblx0ZnVuY3Rpb24gY3JlYXRlRHJhZ2dhYmxlRGF0YShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCBjb3JlRGF0YSAvKjogRHJhZ2dhYmxlRGF0YSovKSAvKjogRHJhZ2dhYmxlRGF0YSovIHtcblx0ICByZXR1cm4ge1xuXHQgICAgbm9kZTogY29yZURhdGEubm9kZSxcblx0ICAgIHg6IGRyYWdnYWJsZS5zdGF0ZS54ICsgY29yZURhdGEuZGVsdGFYLFxuXHQgICAgeTogZHJhZ2dhYmxlLnN0YXRlLnkgKyBjb3JlRGF0YS5kZWx0YVksXG5cdCAgICBkZWx0YVg6IGNvcmVEYXRhLmRlbHRhWCxcblx0ICAgIGRlbHRhWTogY29yZURhdGEuZGVsdGFZLFxuXHQgICAgbGFzdFg6IGRyYWdnYWJsZS5zdGF0ZS54LFxuXHQgICAgbGFzdFk6IGRyYWdnYWJsZS5zdGF0ZS55XG5cdCAgfTtcblx0fVxuXHRcblx0Ly8gQSBsb3QgZmFzdGVyIHRoYW4gc3RyaW5naWZ5L3BhcnNlXG5cdGZ1bmN0aW9uIGNsb25lQm91bmRzKGJvdW5kcyAvKjogQm91bmRzKi8pIC8qOiBCb3VuZHMqLyB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuXHQgICAgdG9wOiBib3VuZHMudG9wLFxuXHQgICAgcmlnaHQ6IGJvdW5kcy5yaWdodCxcblx0ICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuXHQgIH07XG5cdH1cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHR2YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblx0XG5cdHZhciBfcmVhY3REb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9yZWFjdERvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdERvbSk7XG5cdFxuXHR2YXIgX2RvbUZucyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX3Bvc2l0aW9uRm5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0XG5cdHZhciBfc2hpbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9sb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0XG5cdHZhciBfbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXHRcblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cdFxuXHQvLyBTaW1wbGUgYWJzdHJhY3Rpb24gZm9yIGRyYWdnaW5nIGV2ZW50cyBuYW1lcy5cblx0Lyo6OiBpbXBvcnQgdHlwZSB7RXZlbnRIYW5kbGVyfSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuXHR2YXIgZXZlbnRzRm9yID0ge1xuXHQgIHRvdWNoOiB7XG5cdCAgICBzdGFydDogJ3RvdWNoc3RhcnQnLFxuXHQgICAgbW92ZTogJ3RvdWNobW92ZScsXG5cdCAgICBzdG9wOiAndG91Y2hlbmQnXG5cdCAgfSxcblx0ICBtb3VzZToge1xuXHQgICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuXHQgICAgbW92ZTogJ21vdXNlbW92ZScsXG5cdCAgICBzdG9wOiAnbW91c2V1cCdcblx0ICB9XG5cdH07XG5cdFxuXHQvLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cblx0dmFyIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTtcblx0XG5cdC8vXG5cdC8vIERlZmluZSA8RHJhZ2dhYmxlQ29yZT4uXG5cdC8vXG5cdC8vIDxEcmFnZ2FibGVDb3JlPiBpcyBmb3IgYWR2YW5jZWQgdXNhZ2Ugb2YgPERyYWdnYWJsZT4uIEl0IG1haW50YWlucyBtaW5pbWFsIGludGVybmFsIHN0YXRlIHNvIGl0IGNhblxuXHQvLyB3b3JrIHdlbGwgd2l0aCBsaWJyYXJpZXMgdGhhdCByZXF1aXJlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBlbGVtZW50LlxuXHQvL1xuXHRcblx0Lyo6OiB0eXBlIENvcmVTdGF0ZSA9IHtcblx0ICBkcmFnZ2luZzogYm9vbGVhbixcblx0ICBsYXN0WDogbnVtYmVyLFxuXHQgIGxhc3RZOiBudW1iZXIsXG5cdCAgdG91Y2hJZGVudGlmaWVyOiA/bnVtYmVyXG5cdH07Ki9cblx0XG5cdHZhciBEcmFnZ2FibGVDb3JlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcblx0ICBfaW5oZXJpdHMoRHJhZ2dhYmxlQ29yZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cdFxuXHQgIGZ1bmN0aW9uIERyYWdnYWJsZUNvcmUoKSB7XG5cdCAgICB2YXIgX3JlZjtcblx0XG5cdCAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXHRcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmFnZ2FibGVDb3JlKTtcblx0XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBEcmFnZ2FibGVDb3JlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJhZ2dhYmxlQ29yZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdCAgICAgIC8vIFVzZWQgd2hpbGUgZHJhZ2dpbmcgdG8gZGV0ZXJtaW5lIGRlbHRhcy5cblx0ICAgICAgbGFzdFg6IE5hTiwgbGFzdFk6IE5hTixcblx0ICAgICAgdG91Y2hJZGVudGlmaWVyOiBudWxsXG5cdCAgICB9LCBfdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG5cdCAgICAgIF90aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXHRcblx0ICAgICAgLy8gT25seSBhY2NlcHQgbGVmdC1jbGlja3MuXG5cdCAgICAgIGlmICghX3RoaXMucHJvcHMuYWxsb3dBbnlDbGljayAmJiB0eXBlb2YgZS5idXR0b24gPT09ICdudW1iZXInICYmIGUuYnV0dG9uICE9PSAwKSByZXR1cm4gZmFsc2U7XG5cdFxuXHQgICAgICAvLyBHZXQgbm9kZXMuIEJlIHN1cmUgdG8gZ3JhYiByZWxhdGl2ZSBkb2N1bWVudCAoY291bGQgYmUgaWZyYW1lZClcblx0ICAgICAgdmFyIGRvbU5vZGUgPSBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoX3RoaXMpO1xuXHQgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGRvbU5vZGUub3duZXJEb2N1bWVudDtcblx0XG5cdCAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaGFuZGxlIG9yIGNhbmNlbCBwcm9wIHdhcyBwcm92aWRlZCBhbmQgc2VsZWN0b3IgZG9lc24ndCBtYXRjaC5cblx0XG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCAhKGUudGFyZ2V0IGluc3RhbmNlb2Ygb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5Ob2RlKSB8fCBfdGhpcy5wcm9wcy5oYW5kbGUgJiYgISgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIF90aGlzLnByb3BzLmhhbmRsZSwgZG9tTm9kZSkgfHwgX3RoaXMucHJvcHMuY2FuY2VsICYmICgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIF90aGlzLnByb3BzLmNhbmNlbCwgZG9tTm9kZSkpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFNldCB0b3VjaCBpZGVudGlmaWVyIGluIGNvbXBvbmVudCBzdGF0ZSBpZiB0aGlzIGlzIGEgdG91Y2ggZXZlbnQuIFRoaXMgYWxsb3dzIHVzIHRvXG5cdCAgICAgIC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbCB0b3VjaGVzIG9uIG11bHRpdG91Y2ggc2NyZWVucyBieSBpZGVudGlmeWluZyB3aGljaFxuXHQgICAgICAvLyB0b3VjaHBvaW50IHdhcyBzZXQgdG8gdGhpcyBlbGVtZW50LlxuXHQgICAgICB2YXIgdG91Y2hJZGVudGlmaWVyID0gKDAsIF9kb21GbnMuZ2V0VG91Y2hJZGVudGlmaWVyKShlKTtcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoeyB0b3VjaElkZW50aWZpZXI6IHRvdWNoSWRlbnRpZmllciB9KTtcblx0XG5cdCAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cblx0ICAgICAgdmFyIHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgX3RoaXMpO1xuXHQgICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuOyAvLyBub3QgcG9zc2libGUgYnV0IHNhdGlzZmllcyBmbG93XG5cdCAgICAgIHZhciB4ID0gcG9zaXRpb24ueCxcblx0ICAgICAgICAgIHkgPSBwb3NpdGlvbi55O1xuXHRcblx0ICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSBwYXJlbnRzIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhlcmUuXG5cdFxuXHQgICAgICB2YXIgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkoX3RoaXMsIHgsIHkpO1xuXHRcblx0ICAgICAgKDAsIF9sb2cyLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RhcnQ6ICVqJywgY29yZUV2ZW50KTtcblx0XG5cdCAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlci4gSWYgaXQgcmV0dXJucyBleHBsaWNpdCBmYWxzZSwgY2FuY2VsLlxuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ2NhbGxpbmcnLCBfdGhpcy5wcm9wcy5vblN0YXJ0KTtcblx0ICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcblx0ICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcblx0XG5cdCAgICAgIC8vIEFkZCBhIHN0eWxlIHRvIHRoZSBib2R5IHRvIGRpc2FibGUgdXNlci1zZWxlY3QuIFRoaXMgcHJldmVudHMgdGV4dCBmcm9tXG5cdCAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuXHQgICAgICBpZiAoX3RoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQuYm9keSk7XG5cdFxuXHQgICAgICAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuXHQgICAgICAvLyBzbyB3ZSBrbm93IGhvdyBtdWNoIHdlJ3ZlIG1vdmVkIGR1cmluZyB0aGUgZHJhZy4gVGhpcyBhbGxvd3MgdXNcblx0ICAgICAgLy8gdG8gZHJhZyBlbGVtZW50cyBhcm91bmQgZXZlbiBpZiB0aGV5IGhhdmUgYmVlbiBtb3ZlZCwgd2l0aG91dCBpc3N1ZS5cblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuXHQgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuXHRcblx0ICAgICAgICBsYXN0WDogeCxcblx0ICAgICAgICBsYXN0WTogeVxuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIC8vIEFkZCBldmVudHMgdG8gdGhlIGRvY3VtZW50IGRpcmVjdGx5IHNvIHdlIGNhdGNoIHdoZW4gdGhlIHVzZXIncyBtb3VzZS90b3VjaCBtb3ZlcyBvdXRzaWRlIG9mXG5cdCAgICAgIC8vIHRoaXMgZWxlbWVudC4gV2UgdXNlIGRpZmZlcmVudCBldmVudHMgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHdlIGhhdmUgZGV0ZWN0ZWQgdGhhdCB0aGlzXG5cdCAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG5cdCAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgX3RoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3Iuc3RvcCwgX3RoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuXHQgICAgfSwgX3RoaXMuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChlKSB7XG5cdFxuXHQgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlcywgbGlrZSBpcGFkL2lwaG9uZS5cblx0ICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIGUucHJldmVudERlZmF1bHQoKTtcblx0XG5cdCAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cblx0ICAgICAgdmFyIHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIF90aGlzLnN0YXRlLnRvdWNoSWRlbnRpZmllciwgX3RoaXMpO1xuXHQgICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG5cdCAgICAgICAgICB5ID0gcG9zaXRpb24ueTtcblx0XG5cdCAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG5cdFxuXHQgICAgICBpZiAoeCAhPT0geCkgZGVidWdnZXI7XG5cdFxuXHQgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5wcm9wcy5ncmlkKSkge1xuXHQgICAgICAgIHZhciBkZWx0YVggPSB4IC0gX3RoaXMuc3RhdGUubGFzdFgsXG5cdCAgICAgICAgICAgIGRlbHRhWSA9IHkgLSBfdGhpcy5zdGF0ZS5sYXN0WTtcblx0XG5cdCAgICAgICAgdmFyIF9zbmFwVG9HcmlkID0gKDAsIF9wb3NpdGlvbkZucy5zbmFwVG9HcmlkKShfdGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG5cdFxuXHQgICAgICAgIHZhciBfc25hcFRvR3JpZDIgPSBfc2xpY2VkVG9BcnJheShfc25hcFRvR3JpZCwgMik7XG5cdFxuXHQgICAgICAgIGRlbHRhWCA9IF9zbmFwVG9HcmlkMlswXTtcblx0ICAgICAgICBkZWx0YVkgPSBfc25hcFRvR3JpZDJbMV07XG5cdFxuXHQgICAgICAgIGlmICghZGVsdGFYICYmICFkZWx0YVkpIHJldHVybjsgLy8gc2tpcCB1c2VsZXNzIGRyYWdcblx0ICAgICAgICB4ID0gX3RoaXMuc3RhdGUubGFzdFggKyBkZWx0YVgsIHkgPSBfdGhpcy5zdGF0ZS5sYXN0WSArIGRlbHRhWTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKF90aGlzLCB4LCB5KTtcblx0XG5cdCAgICAgICgwLCBfbG9nMi5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogaGFuZGxlRHJhZzogJWonLCBjb3JlRXZlbnQpO1xuXHRcblx0ICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cblx0ICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uRHJhZyhlLCBjb3JlRXZlbnQpO1xuXHQgICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxuXHQgICAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0b3AobmV3IE1vdXNlRXZlbnQoJ21vdXNldXAnKSk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAvLyBPbGQgYnJvd3NlcnNcblx0ICAgICAgICAgIHZhciBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJykgLyo6IGFueSovKSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pO1xuXHQgICAgICAgICAgLy8gSSBzZWUgd2h5IHRoaXMgaW5zYW5pdHkgd2FzIGRlcHJlY2F0ZWRcblx0ICAgICAgICAgIC8vICRGbG93SWdub3JlXG5cdCAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2V1cCcsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHQgICAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0b3AoZXZlbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHtcblx0ICAgICAgICBsYXN0WDogeCxcblx0ICAgICAgICBsYXN0WTogeVxuXHQgICAgICB9KTtcblx0ICAgIH0sIF90aGlzLmhhbmRsZURyYWdTdG9wID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuO1xuXHRcblx0ICAgICAgdmFyIHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIF90aGlzLnN0YXRlLnRvdWNoSWRlbnRpZmllciwgX3RoaXMpO1xuXHQgICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG5cdCAgICAgICAgICB5ID0gcG9zaXRpb24ueTtcblx0XG5cdCAgICAgIHZhciBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKShfdGhpcywgeCwgeSk7XG5cdFxuXHQgICAgICB2YXIgX1JlYWN0RE9NJGZpbmRET01Ob2RlID0gX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKF90aGlzKSxcblx0ICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBfUmVhY3RET00kZmluZERPTU5vZGUub3duZXJEb2N1bWVudDtcblx0XG5cdCAgICAgIC8vIFJlbW92ZSB1c2VyLXNlbGVjdCBoYWNrXG5cdFxuXHRcblx0ICAgICAgaWYgKF90aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSAoMCwgX2RvbUZucy5yZW1vdmVVc2VyU2VsZWN0U3R5bGVzKShvd25lckRvY3VtZW50LmJvZHkpO1xuXHRcblx0ICAgICAgKDAsIF9sb2cyLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RvcDogJWonLCBjb3JlRXZlbnQpO1xuXHRcblx0ICAgICAgLy8gUmVzZXQgdGhlIGVsLlxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG5cdCAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXHQgICAgICAgIGxhc3RYOiBOYU4sXG5cdCAgICAgICAgbGFzdFk6IE5hTlxuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlclxuXHQgICAgICBfdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcblx0XG5cdCAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IFJlbW92aW5nIGhhbmRsZXJzJyk7XG5cdCAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgX3RoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3Iuc3RvcCwgX3RoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuXHQgICAgfSwgX3RoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7IC8vIG9uIHRvdWNoc2NyZWVuIGxhcHRvcHMgd2UgY291bGQgc3dpdGNoIGJhY2sgdG8gbW91c2Vcblx0XG5cdCAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RhcnQoZSk7XG5cdCAgICB9LCBfdGhpcy5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG5cdFxuXHQgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRHJhZ1N0b3AoZSk7XG5cdCAgICB9LCBfdGhpcy5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcblx0ICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuXHRcblx0ICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdGFydChlKTtcblx0ICAgIH0sIF90aGlzLm9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcblx0ICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuXHRcblx0ICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuXHQgICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoRHJhZ2dhYmxlQ29yZSwgW3tcblx0ICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0ICAgICAgLy8gUmVtb3ZlIGFueSBsZWZ0b3ZlciBldmVudCBoYW5kbGVycy4gUmVtb3ZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGhhbmRsZXJzIGluIGNhc2Vcblx0ICAgICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cblx0ICAgICAgdmFyIF9SZWFjdERPTSRmaW5kRE9NTm9kZTIgPSBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyksXG5cdCAgICAgICAgICBvd25lckRvY3VtZW50ID0gX1JlYWN0RE9NJGZpbmRET01Ob2RlMi5vd25lckRvY3VtZW50O1xuXHRcblx0ICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuXHQgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkob3duZXJEb2N1bWVudCwgZXZlbnRzRm9yLnRvdWNoLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IubW91c2Uuc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSAoMCwgX2RvbUZucy5yZW1vdmVVc2VyU2VsZWN0U3R5bGVzKShvd25lckRvY3VtZW50LmJvZHkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIFNhbWUgYXMgb25Nb3VzZURvd24gKHN0YXJ0IGRyYWcpLCBidXQgbm93IGNvbnNpZGVyIHRoaXMgYSB0b3VjaCBkZXZpY2UuXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3JlbmRlcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8YW55PiovIHtcblx0ICAgICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG5cdCAgICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG5cdCAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY2xvbmVFbGVtZW50KF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG5cdCAgICAgICAgc3R5bGU6ICgwLCBfZG9tRm5zLnN0eWxlSGFja3MpKHRoaXMucHJvcHMuY2hpbGRyZW4ucHJvcHMuc3R5bGUpLFxuXHRcblx0ICAgICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG5cdCAgICAgICAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyBxdWlja2x5IGFuZCBsZWF2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cblx0ICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5vbk1vdXNlRG93bixcblx0ICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMub25Ub3VjaFN0YXJ0LFxuXHQgICAgICAgIG9uTW91c2VVcDogdGhpcy5vbk1vdXNlVXAsXG5cdCAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5vblRvdWNoRW5kXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIERyYWdnYWJsZUNvcmU7XG5cdH0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cdFxuXHREcmFnZ2FibGVDb3JlLmRpc3BsYXlOYW1lID0gJ0RyYWdnYWJsZUNvcmUnO1xuXHREcmFnZ2FibGVDb3JlLnByb3BUeXBlcyA9IHtcblx0ICAvKipcblx0ICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG5cdCAgICogQnkgZGVmYXVsdCwgd2Ugb25seSBhY2NlcHQgdGhlIGxlZnQgYnV0dG9uLlxuXHQgICAqXG5cdCAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cblx0ICAgKi9cblx0ICBhbGxvd0FueUNsaWNrOiBfcmVhY3QuUHJvcFR5cGVzLmJvb2wsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGBkaXNhYmxlZGAsIGlmIHRydWUsIHN0b3BzIHRoZSA8RHJhZ2dhYmxlPiBmcm9tIGRyYWdnaW5nLiBBbGwgaGFuZGxlcnMsXG5cdCAgICogd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBvbk1vdXNlRG93bmAsIHdpbGwgbm90IGZpcmUuXG5cdCAgICovXG5cdCAgZGlzYWJsZWQ6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcblx0XG5cdCAgLyoqXG5cdCAgICogQnkgZGVmYXVsdCwgd2UgYWRkICd1c2VyLXNlbGVjdDpub25lJyBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBib2R5XG5cdCAgICogdG8gcHJldmVudCB1Z2x5IHRleHQgc2VsZWN0aW9uIGR1cmluZyBkcmFnLiBJZiB0aGlzIGlzIGNhdXNpbmcgcHJvYmxlbXNcblx0ICAgKiBmb3IgeW91ciBhcHAsIHNldCB0aGlzIHRvIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcblx0XG5cdCAgLyoqXG5cdCAgICogYG9mZnNldFBhcmVudGAsIGlmIHNldCwgdXNlcyB0aGUgcGFzc2VkIERPTSBub2RlIHRvIGNvbXB1dGUgZHJhZyBvZmZzZXRzXG5cdCAgICogaW5zdGVhZCBvZiB1c2luZyB0aGUgcGFyZW50IG5vZGUuXG5cdCAgICovXG5cdCAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiBvZmZzZXRQYXJlbnQocHJvcHMsIHByb3BOYW1lKSB7XG5cdCAgICBpZiAocHJvY2Vzcy5icm93c2VyICYmIHByb3BzW3Byb3BOYW1lXSAmJiBwcm9wc1twcm9wTmFtZV0ubm9kZVR5cGUgIT09IDEpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnZ2FibGVcXCdzIG9mZnNldFBhcmVudCBtdXN0IGJlIGEgRE9NIE5vZGUuJyk7XG5cdCAgICB9XG5cdCAgfSxcblx0XG5cdCAgLyoqXG5cdCAgICogYGdyaWRgIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IGRyYWdnaW5nIHNob3VsZCBzbmFwIHRvLlxuXHQgICAqL1xuXHQgIGdyaWQ6IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZihfcmVhY3QuUHJvcFR5cGVzLm51bWJlciksXG5cdFxuXHQgIC8qKlxuXHQgICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGhhbmRsZT1cIi5oYW5kbGVcIj5cblx0ICAgKiAgICAgICAgICAgICAgPGRpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGFuZGxlXCI+Q2xpY2sgbWUgdG8gZHJhZzwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgPGRpdj5UaGlzIGlzIHNvbWUgb3RoZXIgY29udGVudDwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICA8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG5cdCAgICogICAgICAgICApO1xuXHQgICAqICAgICAgIH1cblx0ICAgKiAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIGhhbmRsZTogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG5cdFxuXHQgIC8qKlxuXHQgICAqIGBjYW5jZWxgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgdG8gcHJldmVudCBkcmFnIGluaXRpYWxpemF0aW9uLlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgICAgcmV0dXJuKFxuXHQgICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG5cdCAgICogICAgICAgICAgICAgICAgICAgPGRpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FuY2VsXCI+WW91IGNhbid0IGRyYWcgZnJvbSBoZXJlPC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG5cdCAgICogICAgICAgICAgICk7XG5cdCAgICogICAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICogYGBgXG5cdCAgICovXG5cdCAgY2FuY2VsOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuXHQgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgZHJhZ2dpbmcgd2lsbCBiZSBjYW5jZWxlZC5cblx0ICAgKi9cblx0ICBvblN0YXJ0OiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG5cdFxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cblx0ICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG5cdCAgICovXG5cdCAgb25EcmFnOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG5cdFxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuXHQgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgdGhlIGRyYWcgd2lsbCByZW1haW4gYWN0aXZlLlxuXHQgICAqL1xuXHQgIG9uU3RvcDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuXHRcblx0ICAvKipcblx0ICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG5cdCAgICogc2luY2UgaXQnbGwgYWx3YXlzIGJlIGJsb2NrZWQgKGFzIHRoZXJlIGlzIGludGVybmFsIHVzZSBvZiBvbk1vdXNlRG93bilcblx0ICAgKi9cblx0ICBvbk1vdXNlRG93bjogX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuXHRcblx0ICAvKipcblx0ICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG5cdCAgICovXG5cdCAgY2xhc3NOYW1lOiBfc2hpbXMuZG9udFNldE1lLFxuXHQgIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuXHQgIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxuXHR9O1xuXHREcmFnZ2FibGVDb3JlLmRlZmF1bHRQcm9wcyA9IHtcblx0ICBhbGxvd0FueUNsaWNrOiBmYWxzZSwgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG5cdCAgY2FuY2VsOiBudWxsLFxuXHQgIGRpc2FibGVkOiBmYWxzZSxcblx0ICBlbmFibGVVc2VyU2VsZWN0SGFjazogdHJ1ZSxcblx0ICBvZmZzZXRQYXJlbnQ6IG51bGwsXG5cdCAgaGFuZGxlOiBudWxsLFxuXHQgIGdyaWQ6IG51bGwsXG5cdCAgdHJhbnNmb3JtOiBudWxsLFxuXHQgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcblx0ICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuXHQgIG9uU3RvcDogZnVuY3Rpb24gb25TdG9wKCkge30sXG5cdCAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKCkge31cblx0fTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlQ29yZTtcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTApKSlcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblx0dmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXHRcblx0Ly8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG5cdC8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuXHQvLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG5cdC8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cdFxuXHR2YXIgY2FjaGVkU2V0VGltZW91dDtcblx0dmFyIGNhY2hlZENsZWFyVGltZW91dDtcblx0XG5cdGZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcblx0fVxuXHRmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICB9XG5cdH0gKCkpXG5cdGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG5cdCAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9IGNhdGNoKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG5cdCAgICAgICAgfSBjYXRjaChlKXtcblx0ICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3Jcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdFxuXHR9XG5cdGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcblx0ICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblx0ICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0ICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3Ncblx0ICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9IGNhdGNoIChlKXtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cblx0ICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHRcblx0XG5cdH1cblx0dmFyIHF1ZXVlID0gW107XG5cdHZhciBkcmFpbmluZyA9IGZhbHNlO1xuXHR2YXIgY3VycmVudFF1ZXVlO1xuXHR2YXIgcXVldWVJbmRleCA9IC0xO1xuXHRcblx0ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuXHQgICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgfVxuXHQgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIGRyYWluUXVldWUoKTtcblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcblx0ICAgIGlmIChkcmFpbmluZykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuXHQgICAgZHJhaW5pbmcgPSB0cnVlO1xuXHRcblx0ICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB3aGlsZShsZW4pIHtcblx0ICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcblx0ICAgICAgICBxdWV1ZSA9IFtdO1xuXHQgICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0fVxuXHRcblx0cHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcblx0ICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG5cdCAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuXHQgICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG5cdCAgICB9XG5cdH07XG5cdFxuXHQvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cdGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuXHQgICAgdGhpcy5mdW4gPSBmdW47XG5cdCAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG5cdH1cblx0SXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG5cdH07XG5cdHByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5cdHByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5cdHByb2Nlc3MuZW52ID0ge307XG5cdHByb2Nlc3MuYXJndiA9IFtdO1xuXHRwcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcblx0cHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXHRcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdFxuXHRwcm9jZXNzLm9uID0gbm9vcDtcblx0cHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5cdHByb2Nlc3Mub25jZSA9IG5vb3A7XG5cdHByb2Nlc3Mub2ZmID0gbm9vcDtcblx0cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5cdHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcblx0cHJvY2Vzcy5lbWl0ID0gbm9vcDtcblx0XG5cdHByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdH07XG5cdFxuXHRwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xuXHRwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0cHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGxvZztcblx0XG5cdC8qZXNsaW50IG5vLWNvbnNvbGU6MCovXG5cdGZ1bmN0aW9uIGxvZygpIHtcblx0ICB2YXIgX2NvbnNvbGU7XG5cdFxuXHQgIGlmICgodW5kZWZpbmVkKSkgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xuXHR9XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWRyYWdnYWJsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3QnXSA6IG51bGwpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9TbGlkZXIgPSByZXF1aXJlKCcuL1NsaWRlcicpO1xuXG52YXIgX1NsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TbGlkZXIpO1xuXG52YXIgX1RyYWNrID0gcmVxdWlyZSgnLi9UcmFjaycpO1xuXG52YXIgX1RyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RyYWNrKTtcblxudmFyIF9MYWJlbCA9IHJlcXVpcmUoJy4vTGFiZWwnKTtcblxudmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbnZhciBfZGVmYXVsdENsYXNzTmFtZXMgPSByZXF1aXJlKCcuL2RlZmF1bHRDbGFzc05hbWVzJyk7XG5cbnZhciBfZGVmYXVsdENsYXNzTmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdENsYXNzTmFtZXMpO1xuXG52YXIgX3ZhbHVlVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL3ZhbHVlVHJhbnNmb3JtZXInKTtcblxudmFyIF92YWx1ZVRyYW5zZm9ybWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlVHJhbnNmb3JtZXIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCcuL3Byb3BUeXBlcycpO1xuXG4vKipcbiAqIEEgbWFwIGZvciBzdG9yaW5nIGludGVybmFsIG1lbWJlcnNcbiAqIEBjb25zdCB7V2Vha01hcH1cbiAqL1xudmFyIGludGVybmFscyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQW4gb2JqZWN0IHN0b3Jpbmcga2V5Ym9hcmQga2V5IGNvZGVzXG4gKiBAY29uc3Qge09iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICovXG52YXIgS2V5Q29kZSA9IHtcbiAgRE9XTl9BUlJPVzogNDAsXG4gIExFRlRfQVJST1c6IDM3LFxuICBSSUdIVF9BUlJPVzogMzksXG4gIFVQX0FSUk9XOiAzOFxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgbWF4IGFuZCBtaW4gcmFuZ2Ugb2YgaW5wdXRSYW5nZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtIHtSYW5nZX0gdmFsdWVzIC0gTWluL21heCB2YWx1ZSBvZiBzbGlkZXJzXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHdpdGhpbiByYW5nZVxuICovXG5mdW5jdGlvbiBpc1dpdGhpblJhbmdlKGlucHV0UmFuZ2UsIHZhbHVlcykge1xuICB2YXIgcHJvcHMgPSBpbnB1dFJhbmdlLnByb3BzO1xuXG4gIGlmIChpbnB1dFJhbmdlLmlzTXVsdGlWYWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZXMubWluID49IHByb3BzLm1pblZhbHVlICYmIHZhbHVlcy5tYXggPD0gcHJvcHMubWF4VmFsdWUgJiYgdmFsdWVzLm1pbiA8IHZhbHVlcy5tYXg7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzLm1heCA+PSBwcm9wcy5taW5WYWx1ZSAmJiB2YWx1ZXMubWF4IDw9IHByb3BzLm1heFZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZXMgb2YgaW5wdXRSYW5nZVxuICogaXMgZ3JlYXRlciBvciBlcXVhbCB0byBpdHMgc3RlcCBhbW91bnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2UgLSBSZWFjdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmFuZ2V9IHZhbHVlcyAtIE1pbi9tYXggdmFsdWUgb2Ygc2xpZGVyc1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBkaWZmZXJlbmNlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gc3RlcCBhbW91bnRcbiAqL1xuZnVuY3Rpb24gaGFzU3RlcERpZmZlcmVuY2UoaW5wdXRSYW5nZSwgdmFsdWVzKSB7XG4gIHZhciBwcm9wcyA9IGlucHV0UmFuZ2UucHJvcHM7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS52YWx1ZXNGcm9tUHJvcHMoaW5wdXRSYW5nZSk7XG5cbiAgcmV0dXJuICgwLCBfdXRpbC5sZW5ndGgpKHZhbHVlcy5taW4sIGN1cnJlbnRWYWx1ZXMubWluKSA+PSBwcm9wcy5zdGVwIHx8ICgwLCBfdXRpbC5sZW5ndGgpKHZhbHVlcy5tYXgsIGN1cnJlbnRWYWx1ZXMubWF4KSA+PSBwcm9wcy5zdGVwO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGlucHV0UmFuZ2Ugc2hvdWxkIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2UgLSBSZWFjdCBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmFuZ2V9IHZhbHVlcyAtIE1pbi9tYXggdmFsdWUgb2Ygc2xpZGVyc1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbnB1dFJhbmdlIHNob3VsZCB1cGRhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlKGlucHV0UmFuZ2UsIHZhbHVlcykge1xuICByZXR1cm4gaXNXaXRoaW5SYW5nZShpbnB1dFJhbmdlLCB2YWx1ZXMpICYmIGhhc1N0ZXBEaWZmZXJlbmNlKGlucHV0UmFuZ2UsIHZhbHVlcyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvd25lciBkb2N1bWVudCBvZiBpbnB1dFJhbmdlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gRG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoaW5wdXRSYW5nZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGlucHV0UmFuZ2UucmVmcy5pbnB1dFJhbmdlLm93bmVyRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjbGFzcyBuYW1lKHMpIG9mIGlucHV0UmFuZ2UgYmFzZWQgb24gaXRzIHByb3BzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbGlzdCBvZiBjbGFzcyBuYW1lcyBkZWxpbWl0ZWQgd2l0aCBzcGFjZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xhc3NOYW1lKGlucHV0UmFuZ2UpIHtcbiAgdmFyIHByb3BzID0gaW5wdXRSYW5nZS5wcm9wcztcblxuICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHByb3BzLmNsYXNzTmFtZXMuY29tcG9uZW50O1xuICB9XG5cbiAgcmV0dXJuIHByb3BzLmNsYXNzTmFtZXMuY29tcG9uZW50ICsgJyBpcy1kaXNhYmxlZCc7XG59XG5cbi8qKlxuICogR2V0IHRoZSBrZXkgbmFtZSBvZiBhIHNsaWRlclxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtIHtTbGlkZXJ9IHNsaWRlciAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBLZXkgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRLZXlGcm9tU2xpZGVyKGlucHV0UmFuZ2UsIHNsaWRlcikge1xuICBpZiAoc2xpZGVyID09PSBpbnB1dFJhbmdlLnJlZnMuc2xpZGVyTWluKSB7XG4gICAgcmV0dXJuICdtaW4nO1xuICB9XG5cbiAgcmV0dXJuICdtYXgnO1xufVxuXG4vKipcbiAqIEdldCBhbGwgc2xpZGVyIGtleXMgb2YgaW5wdXRSYW5nZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEtleSBuYW1lc1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKGlucHV0UmFuZ2UpIHtcbiAgaWYgKGlucHV0UmFuZ2UuaXNNdWx0aVZhbHVlKSB7XG4gICAgcmV0dXJuIFsnbWluJywgJ21heCddO1xuICB9XG5cbiAgcmV0dXJuIFsnbWF4J107XG59XG5cbi8qKlxuICogR2V0IHRoZSBrZXkgbmFtZSBvZiBhIHNsaWRlciB0aGF0J3MgdGhlIGNsb3Nlc3QgdG8gYSBwb2ludFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB4L3lcbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5IG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5QnlQb3NpdGlvbihpbnB1dFJhbmdlLCBwb3NpdGlvbikge1xuICB2YXIgdmFsdWVzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVzRnJvbVByb3BzKGlucHV0UmFuZ2UpO1xuICB2YXIgcG9zaXRpb25zID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10ucG9zaXRpb25zRnJvbVZhbHVlcyhpbnB1dFJhbmdlLCB2YWx1ZXMpO1xuXG4gIGlmIChpbnB1dFJhbmdlLmlzTXVsdGlWYWx1ZSkge1xuICAgIHZhciBkaXN0YW5jZVRvTWluID0gKDAsIF91dGlsLmRpc3RhbmNlVG8pKHBvc2l0aW9uLCBwb3NpdGlvbnMubWluKTtcbiAgICB2YXIgZGlzdGFuY2VUb01heCA9ICgwLCBfdXRpbC5kaXN0YW5jZVRvKShwb3NpdGlvbiwgcG9zaXRpb25zLm1heCk7XG5cbiAgICBpZiAoZGlzdGFuY2VUb01pbiA8IGRpc3RhbmNlVG9NYXgpIHtcbiAgICAgIHJldHVybiAnbWluJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJ21heCc7XG59XG5cbi8qKlxuICogR2V0IGFuIGFycmF5IG9mIHNsaWRlciBIVE1MIGZvciByZW5kZXJpbmdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2UgLSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBBcnJheSBvZiBIVE1MXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsaWRlcnMoaW5wdXRSYW5nZSkge1xuICB2YXIgY2xhc3NOYW1lcyA9IGlucHV0UmFuZ2UucHJvcHMuY2xhc3NOYW1lcztcblxuICB2YXIgc2xpZGVycyA9IFtdO1xuICB2YXIga2V5cyA9IGdldEtleXMoaW5wdXRSYW5nZSk7XG4gIHZhciB2YWx1ZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS52YWx1ZXNGcm9tUHJvcHMoaW5wdXRSYW5nZSk7XG4gIHZhciBwZXJjZW50YWdlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnBlcmNlbnRhZ2VzRnJvbVZhbHVlcyhpbnB1dFJhbmdlLCB2YWx1ZXMpO1xuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlc1trZXldO1xuICAgICAgdmFyIHJlZiA9ICdzbGlkZXInICsgKDAsIF91dGlsLmNhcHRpYWxpemUpKGtleSk7XG5cbiAgICAgIHZhciBfaW5wdXRSYW5nZSRwcm9wcyA9IGlucHV0UmFuZ2UucHJvcHM7XG4gICAgICB2YXIgbWF4VmFsdWUgPSBfaW5wdXRSYW5nZSRwcm9wcy5tYXhWYWx1ZTtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IF9pbnB1dFJhbmdlJHByb3BzLm1pblZhbHVlO1xuXG4gICAgICBpZiAoa2V5ID09PSAnbWluJykge1xuICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlcy5tYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5WYWx1ZSA9IHZhbHVlcy5taW47XG4gICAgICB9XG5cbiAgICAgIHZhciBzbGlkZXIgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfU2xpZGVyMlsnZGVmYXVsdCddLCB7XG4gICAgICAgIGFyaWFMYWJlbGxlZGJ5OiBpbnB1dFJhbmdlLnByb3BzLmFyaWFMYWJlbGxlZGJ5LFxuICAgICAgICBhcmlhQ29udHJvbHM6IGlucHV0UmFuZ2UucHJvcHMuYXJpYUNvbnRyb2xzLFxuICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICBmb3JtYXRMYWJlbDogaW5wdXRSYW5nZS5mb3JtYXRMYWJlbCxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIG1heFZhbHVlOiBtYXhWYWx1ZSxcbiAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlLFxuICAgICAgICBvblNsaWRlcktleURvd246IGlucHV0UmFuZ2UuaGFuZGxlU2xpZGVyS2V5RG93bixcbiAgICAgICAgb25TbGlkZXJNb3VzZU1vdmU6IGlucHV0UmFuZ2UuaGFuZGxlU2xpZGVyTW91c2VNb3ZlLFxuICAgICAgICBwZXJjZW50YWdlOiBwZXJjZW50YWdlLFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgdHlwZToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUgfSk7XG5cbiAgICAgIHNsaWRlcnMucHVzaChzbGlkZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2xpZGVycztcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgaGlkZGVuIGlucHV0IEhUTUwgZm9yIHJlbmRlcmluZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEFycmF5IG9mIEhUTUxcbiAqL1xuZnVuY3Rpb24gcmVuZGVySGlkZGVuSW5wdXRzKGlucHV0UmFuZ2UpIHtcbiAgdmFyIGlucHV0cyA9IFtdO1xuICB2YXIga2V5cyA9IGdldEtleXMoaW5wdXRSYW5nZSk7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgIHZhciBfbmFtZSA9IGlucHV0UmFuZ2UuaXNNdWx0aVZhbHVlID8gJycgKyBpbnB1dFJhbmdlLnByb3BzLm5hbWUgKyAoMCwgX3V0aWwuY2FwdGlhbGl6ZSkoa2V5KSA6IGlucHV0UmFuZ2UucHJvcHMubmFtZTtcblxuICAgICAgdmFyIGlucHV0ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyB0eXBlOiAnaGlkZGVuJywgbmFtZTogX25hbWUgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3IyWydyZXR1cm4nXSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5wdXRzO1xufVxuXG4vKipcbiAqIElucHV0UmFuZ2UgUmVhY3QgY29tcG9uZW50XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUmVhY3QgY29tcG9uZW50IHByb3BzXG4gKi9cblxudmFyIElucHV0UmFuZ2UgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKElucHV0UmFuZ2UsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElucHV0UmFuZ2UocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRSYW5nZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihJbnB1dFJhbmdlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIGludGVybmFscy5zZXQodGhpcywge30pO1xuXG4gICAgLy8gQXV0by1iaW5kXG4gICAgKDAsIF91dGlsLmF1dG9iaW5kKShbJ2Zvcm1hdExhYmVsJywgJ2hhbmRsZUludGVyYWN0aW9uRW5kJywgJ2hhbmRsZUludGVyYWN0aW9uU3RhcnQnLCAnaGFuZGxlS2V5RG93bicsICdoYW5kbGVLZXlVcCcsICdoYW5kbGVNb3VzZURvd24nLCAnaGFuZGxlTW91c2VVcCcsICdoYW5kbGVTbGlkZXJLZXlEb3duJywgJ2hhbmRsZVNsaWRlck1vdXNlTW92ZScsICdoYW5kbGVUb3VjaFN0YXJ0JywgJ2hhbmRsZVRvdWNoRW5kJywgJ2hhbmRsZVRyYWNrTW91c2VEb3duJ10sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdGVkIHByb3BUeXBlcyBvZiBJbnB1dFJhbmdlXG4gICAqIEBzdGF0aWMge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gYXJpYUxhYmVsbGVkYnlcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gYXJpYUNvbnRyb2xzXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNsYXNzTmFtZXNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGVmYXVsdFZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRpc2FibGVkXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZvcm1hdExhYmVsXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxhYmVsUHJlZml4XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxhYmVsU3VmZml4XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG1heFZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG1pblZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG5hbWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25DaGFuZ2VcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25DaGFuZ2VDb21wbGV0ZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzdGVwXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHZhbHVlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNsaWVudFJlY3Qgb2YgdGhlIGNvbXBvbmVudCdzIHRyYWNrXG4gICAqIEBtZW1iZXIge0NsaWVudFJlY3R9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhJbnB1dFJhbmdlLCBbe1xuICAgIGtleTogJ3VwZGF0ZVBvc2l0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBzbGlkZXIgYnkga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIG1pbi9tYXhcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiB4L3lcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oa2V5LCBwb3NpdGlvbikge1xuICAgICAgdmFyIHZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyh0aGlzKTtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS5wb3NpdGlvbnNGcm9tVmFsdWVzKHRoaXMsIHZhbHVlcyk7XG5cbiAgICAgIHBvc2l0aW9uc1trZXldID0gcG9zaXRpb247XG5cbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKHBvc2l0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBzbGlkZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9ucy5taW5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbnMubWF4XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBtaW46IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlRnJvbVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9ucy5taW4pLFxuICAgICAgICBtYXg6IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlRnJvbVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9ucy5tYXgpXG4gICAgICB9O1xuXG4gICAgICB2YXIgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7XG4gICAgICAgIG1pbjogX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10uc3RlcFZhbHVlRnJvbVZhbHVlKHRoaXMsIHZhbHVlcy5taW4pLFxuICAgICAgICBtYXg6IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnN0ZXBWYWx1ZUZyb21WYWx1ZSh0aGlzLCB2YWx1ZXMubWF4KVxuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVWYWx1ZXModHJhbnNmb3JtZWRWYWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgYSBzbGlkZXIgYnkga2V5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIG1heC9taW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBOZXcgdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyh0aGlzKTtcblxuICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgdGhpcy51cGRhdGVWYWx1ZXModmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHZhbHVlcyBvZiBhbGwgc2xpZGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gdmFsdWVzIC0gT2JqZWN0IGlmIG11bHRpLXZhbHVlLCBudW1iZXIgaWYgc2luZ2xlLXZhbHVlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVWYWx1ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZXModmFsdWVzKSB7XG4gICAgICBpZiAoIXNob3VsZFVwZGF0ZSh0aGlzLCB2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNdWx0aVZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcywgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcywgdmFsdWVzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50IHRoZSB2YWx1ZSBvZiBhIHNsaWRlciBieSBrZXkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBtYXgvbWluXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpbmNyZW1lbnRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY3JlbWVudFZhbHVlKGtleSkge1xuICAgICAgdmFyIHZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyh0aGlzKTtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldICsgdGhpcy5wcm9wcy5zdGVwO1xuXG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCB0aGUgdmFsdWUgb2YgYSBzbGlkZXIgYnkga2V5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gbWF4L21pblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGVjcmVtZW50VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyZW1lbnRWYWx1ZShrZXkpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS52YWx1ZXNGcm9tUHJvcHModGhpcyk7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XSAtIHRoaXMucHJvcHMuc3RlcDtcblxuICAgICAgdGhpcy51cGRhdGVWYWx1ZShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxWYWx1ZSAtIExhYmVsIHZhbHVlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgbGFiZWwgdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdExhYmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGFiZWwobGFiZWxWYWx1ZSkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgZm9ybWF0TGFiZWwgPSBfcHJvcHMuZm9ybWF0TGFiZWw7XG4gICAgICB2YXIgbGFiZWxQcmVmaXggPSBfcHJvcHMubGFiZWxQcmVmaXg7XG4gICAgICB2YXIgbGFiZWxTdWZmaXggPSBfcHJvcHMubGFiZWxTdWZmaXg7XG5cbiAgICAgIGlmIChmb3JtYXRMYWJlbCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TGFiZWwobGFiZWxWYWx1ZSwgeyBsYWJlbFByZWZpeDogbGFiZWxQcmVmaXgsIGxhYmVsU3VmZml4OiBsYWJlbFN1ZmZpeCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnICsgbGFiZWxQcmVmaXggKyBsYWJlbFZhbHVlICsgbGFiZWxTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBtb3VzZW1vdmUgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIHNsaWRlclxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqIEBwYXJhbSB7U2xpZGVyfSBzbGlkZXIgLSBSZWFjdCBjb21wb25lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVNsaWRlck1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNsaWRlck1vdXNlTW92ZShldmVudCwgc2xpZGVyKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tU2xpZGVyKHRoaXMsIHNsaWRlcik7XG4gICAgICB2YXIgcG9zaXRpb24gPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS5wb3NpdGlvbkZyb21FdmVudCh0aGlzLCBldmVudCk7XG5cbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oa2V5LCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBrZXlkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBzbGlkZXJcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1NsaWRlcn0gc2xpZGVyIC0gUmVhY3QgY29tcG9uZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVTbGlkZXJLZXlEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2xpZGVyS2V5RG93bihldmVudCwgc2xpZGVyKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tU2xpZGVyKHRoaXMsIHNsaWRlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIEtleUNvZGUuTEVGVF9BUlJPVzpcbiAgICAgICAgY2FzZSBLZXlDb2RlLkRPV05fQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmRlY3JlbWVudFZhbHVlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBLZXlDb2RlLlJJR0hUX0FSUk9XOlxuICAgICAgICBjYXNlIEtleUNvZGUuVVBfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudFZhbHVlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IG1vdXNlZG93biBldmVudCByZWNlaXZlZCBieSB0aGUgdHJhY2tcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1NsaWRlcn0gc2xpZGVyIC0gUmVhY3QgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSBNb3VzZWRvd24gcG9zaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVRyYWNrTW91c2VEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVHJhY2tNb3VzZURvd24oZXZlbnQsIHRyYWNrLCBwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIga2V5ID0gZ2V0S2V5QnlQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oa2V5LCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhbnkgdXNlci10cmlnZ2VyZWQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUludGVyYWN0aW9uU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVJbnRlcmFjdGlvblN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzID0gaW50ZXJuYWxzLmdldCh0aGlzKTtcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLm9uQ2hhbmdlQ29tcGxldGUgfHwgKDAsIF91dGlsLmlzRGVmaW5lZCkoX3RoaXMuc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdGFydFZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZSB8fCB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGVuZCBvZiBhbnkgdXNlci10cmlnZ2VyZWQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUludGVyYWN0aW9uRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSW50ZXJhY3Rpb25FbmQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSBpbnRlcm5hbHMuZ2V0KHRoaXMpO1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMub25DaGFuZ2VDb21wbGV0ZSB8fCAhKDAsIF91dGlsLmlzRGVmaW5lZCkoX3RoaXMuc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuc3RhcnRWYWx1ZSAhPT0gdGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlQ29tcGxldGUodGhpcywgdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnN0YXJ0VmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkga2V5ZG93biBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVLZXlEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IGtleXVwIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUtleVVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlS2V5VXAoZXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2Vkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25TdGFydChldmVudCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2V1cCBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVNb3VzZVVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXZlbnQpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IHRvdWNoc3RhcnQgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlVG91Y2hTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IGdldERvY3VtZW50KHRoaXMpO1xuXG4gICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXZlbnQpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgdG91Y2hlbmQgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlVG91Y2hFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZChldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXZlbnQpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBtZXRob2Qgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29tcG9uZW50IEpTWFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLnByb3BzLmNsYXNzTmFtZXM7XG5cbiAgICAgIHZhciBjb21wb25lbnRDbGFzc05hbWUgPSBnZXRDb21wb25lbnRDbGFzc05hbWUodGhpcyk7XG4gICAgICB2YXIgdmFsdWVzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVzRnJvbVByb3BzKHRoaXMpO1xuICAgICAgdmFyIHBlcmNlbnRhZ2VzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10ucGVyY2VudGFnZXNGcm9tVmFsdWVzKHRoaXMsIHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHtcbiAgICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IHRoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgcmVmOiAnaW5wdXRSYW5nZScsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjb21wb25lbnRDbGFzc05hbWUsXG4gICAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICAgICAgb25LZXlVcDogdGhpcy5oYW5kbGVLZXlVcCxcbiAgICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5oYW5kbGVNb3VzZURvd24sXG4gICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX0xhYmVsMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbE1pbixcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgIGZvcm1hdExhYmVsOiB0aGlzLmZvcm1hdExhYmVsIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy5taW5WYWx1ZVxuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfVHJhY2syWydkZWZhdWx0J10sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lcyxcbiAgICAgICAgICAgIHJlZjogJ3RyYWNrJyxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VzOiBwZXJjZW50YWdlcyxcbiAgICAgICAgICAgIG9uVHJhY2tNb3VzZURvd246IHRoaXMuaGFuZGxlVHJhY2tNb3VzZURvd24gfSxcbiAgICAgICAgICByZW5kZXJTbGlkZXJzKHRoaXMpXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9MYWJlbDJbJ2RlZmF1bHQnXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMubGFiZWxNYXgsXG4gICAgICAgICAgICBjb250YWluZXJDbGFzc05hbWU6IGNsYXNzTmFtZXMubGFiZWxDb250YWluZXIsXG4gICAgICAgICAgICBmb3JtYXRMYWJlbDogdGhpcy5mb3JtYXRMYWJlbCB9LFxuICAgICAgICAgIHRoaXMucHJvcHMubWF4VmFsdWVcbiAgICAgICAgKSxcbiAgICAgICAgcmVuZGVySGlkZGVuSW5wdXRzKHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyYWNrQ2xpZW50UmVjdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnJlZnMudHJhY2s7XG5cbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suY2xpZW50UmVjdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHdpZHRoOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBjb21wb25lbnQgYWNjZXB0cyBhIHJhbmdlIG9mIHZhbHVlc1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpc011bHRpVmFsdWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfdXRpbC5pc09iamVjdCkodGhpcy5wcm9wcy52YWx1ZSkgfHwgKDAsIF91dGlsLmlzT2JqZWN0KSh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElucHV0UmFuZ2U7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW5wdXRSYW5nZTtcbklucHV0UmFuZ2UucHJvcFR5cGVzID0ge1xuICBhcmlhTGFiZWxsZWRieTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGFyaWFDb250cm9sczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICBkZWZhdWx0VmFsdWU6IF9wcm9wVHlwZXMubWF4TWluVmFsdWVQcm9wVHlwZSxcbiAgZGlzYWJsZWQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCxcbiAgZm9ybWF0TGFiZWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgbGFiZWxQcmVmaXg6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbFN1ZmZpeDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIG1heFZhbHVlOiBfcHJvcFR5cGVzLm1heE1pblZhbHVlUHJvcFR5cGUsXG4gIG1pblZhbHVlOiBfcHJvcFR5cGVzLm1heE1pblZhbHVlUHJvcFR5cGUsXG4gIG5hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBvbkNoYW5nZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uQ2hhbmdlQ29tcGxldGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgc3RlcDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsXG4gIHZhbHVlOiBfcHJvcFR5cGVzLm1heE1pblZhbHVlUHJvcFR5cGVcbn07XG5cbi8qKlxuICogRGVmYXVsdCBwcm9wcyBvZiBJbnB1dFJhbmdlXG4gKiBAc3RhdGljIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fSBkZWZhdWx0Q2xhc3NOYW1lc1xuICogQHByb3BlcnR5IHtSYW5nZXxudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBkaXNhYmxlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsUHJlZml4XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxTdWZmaXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RlcFxuICogQHByb3BlcnR5IHtSYW5nZXxudW1iZXJ9IHZhbHVlXG4gKi9cbklucHV0UmFuZ2UuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWVzOiBfZGVmYXVsdENsYXNzTmFtZXMyWydkZWZhdWx0J10sXG4gIGRlZmF1bHRWYWx1ZTogMCxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBsYWJlbFByZWZpeDogJycsXG4gIGxhYmVsU3VmZml4OiAnJyxcbiAgbWF4VmFsdWU6IDEwLFxuICBtaW5WYWx1ZTogMCxcbiAgc3RlcDogMSxcbiAgdmFsdWU6IG51bGxcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZS9MYWJlbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3QnXSA6IG51bGwpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuLyoqXG4gKiBMYWJlbCBSZWFjdCBjb21wb25lbnRcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBSZWFjdCBjb21wb25lbnQgcHJvcHNcbiAqL1xuXG52YXIgTGFiZWwgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExhYmVsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMYWJlbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWwpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGFiZWwucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRlZCBwcm9wVHlwZXMgb2YgTGFiZWxcbiAgICogQHN0YXRpYyB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjaGlsZHJlblxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjbGFzc05hbWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY29udGFpbmVyQ2xhc3NOYW1lXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZvcm1hdExhYmVsXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhMYWJlbCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG1ldGhvZCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb21wb25lbnQgSlNYXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IF9wcm9wcy5jbGFzc05hbWU7XG4gICAgICB2YXIgY29udGFpbmVyQ2xhc3NOYW1lID0gX3Byb3BzLmNvbnRhaW5lckNsYXNzTmFtZTtcblxuICAgICAgdmFyIGxhYmVsVmFsdWUgPSB0aGlzLnByb3BzLmZvcm1hdExhYmVsID8gdGhpcy5wcm9wcy5mb3JtYXRMYWJlbCh0aGlzLnByb3BzLmNoaWxkcmVuKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3NwYW4nLFxuICAgICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lIH0sXG4gICAgICAgICAgbGFiZWxWYWx1ZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYWJlbDtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMYWJlbDtcbkxhYmVsLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubm9kZSxcbiAgY2xhc3NOYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGFpbmVyQ2xhc3NOYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9ybWF0TGFiZWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL1NsaWRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3QnXSA6IG51bGwpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9MYWJlbCA9IHJlcXVpcmUoJy4vTGFiZWwnKTtcblxudmFyIF9MYWJlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYWJlbCk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIEdldCB0aGUgb3duZXIgZG9jdW1lbnQgb2Ygc2xpZGVyXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTbGlkZXJ9IHNsaWRlciAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7RG9jdW1lbnR9IERvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldERvY3VtZW50KHNsaWRlcikge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IHNsaWRlci5yZWZzLnNsaWRlci5vd25lckRvY3VtZW50O1xuXG4gIHJldHVybiBvd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2Ygc2xpZGVyIGJhc2VkIG9uIGl0cyBwcm9wc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U2xpZGVyfSBzbGlkZXIgLSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHN0eWxlc1xuICovXG5mdW5jdGlvbiBnZXRTdHlsZShzbGlkZXIpIHtcbiAgdmFyIHBlcmMgPSAoc2xpZGVyLnByb3BzLnBlcmNlbnRhZ2UgfHwgMCkgKiAxMDA7XG4gIHZhciBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiBwZXJjICsgJyUnXG4gIH07XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIFNsaWRlciBSZWFjdCBjb21wb25lbnRcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBSZWFjdCBjb21wb25lbnQgcHJvcHNcbiAqL1xuXG52YXIgU2xpZGVyID0gKGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNsaWRlcihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2xpZGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgLy8gQXV0by1iaW5kXG4gICAgKDAsIF91dGlsLmF1dG9iaW5kKShbJ2hhbmRsZUNsaWNrJywgJ2hhbmRsZU1vdXNlRG93bicsICdoYW5kbGVNb3VzZVVwJywgJ2hhbmRsZU1vdXNlTW92ZScsICdoYW5kbGVUb3VjaFN0YXJ0JywgJ2hhbmRsZVRvdWNoRW5kJywgJ2hhbmRsZVRvdWNoTW92ZScsICdoYW5kbGVLZXlEb3duJ10sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdGVkIHByb3BUeXBlcyBvZiBTbGlkZXJcbiAgICogQHN0YXRpYyB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhcmlhTGFiZWxsZWRieVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhcmlhQ29udHJvbHNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2xhc3NOYW1lXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZvcm1hdExhYmVsXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG1heFZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG1pblZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2xpZGVyS2V5RG93blxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblNsaWRlck1vdXNlTW92ZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwZXJjZW50YWdlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHR5cGVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkgY2xpY2sgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFNsaWRlciwgW3tcbiAgICBrZXk6ICdoYW5kbGVDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2Vkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bigpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IGdldERvY3VtZW50KHRoaXMpO1xuXG4gICAgICAvLyBFdmVudFxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBtb3VzZXVwIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIC8vIEV2ZW50XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IG1vdXNlbW92ZSBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVNb3VzZU1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMucHJvcHMub25TbGlkZXJNb3VzZU1vdmUoZXZlbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgdG91Y2hzdGFydCBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaFN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSB0b3VjaG1vdmUgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlVG91Y2hNb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICB0aGlzLnByb3BzLm9uU2xpZGVyTW91c2VNb3ZlKGV2ZW50LCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IHRvdWNoZW5kIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVRvdWNoRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IGdldERvY3VtZW50KHRoaXMpO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkga2V5ZG93biBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVLZXlEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgdGhpcy5wcm9wcy5vblNsaWRlcktleURvd24oZXZlbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBtZXRob2Qgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29tcG9uZW50IEpTWFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLnByb3BzLmNsYXNzTmFtZXM7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSh0aGlzKTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuc2xpZGVyQ29udGFpbmVyLFxuICAgICAgICAgIHJlZjogJ3NsaWRlcicsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9MYWJlbDJbJ2RlZmF1bHQnXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMubGFiZWxWYWx1ZSxcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgIGZvcm1hdExhYmVsOiB0aGlzLnByb3BzLmZvcm1hdExhYmVsIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy52YWx1ZVxuICAgICAgICApLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnYScsIHtcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5wcm9wcy5hcmlhTGFiZWxsZWRieSxcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRoaXMucHJvcHMuYXJpYUNvbnRyb2xzLFxuICAgICAgICAgICdhcmlhLXZhbHVlbWF4JzogdGhpcy5wcm9wcy5tYXhWYWx1ZSxcbiAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6IHRoaXMucHJvcHMubWluVmFsdWUsXG4gICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiB0aGlzLnByb3BzLmZvcm1hdExhYmVsID8gdGhpcy5wcm9wcy5mb3JtYXRMYWJlbCh0aGlzLnByb3BzLnZhbHVlKSA6IHRoaXMucHJvcHMudmFsdWUsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnNsaWRlcixcbiAgICAgICAgICBkcmFnZ2FibGU6ICdmYWxzZScsXG4gICAgICAgICAgaHJlZjogJyMnLFxuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxuICAgICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuICAgICAgICAgIHJvbGU6ICdzbGlkZXInIH0pXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGlkZXI7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2xpZGVyO1xuU2xpZGVyLnByb3BUeXBlcyA9IHtcbiAgYXJpYUxhYmVsbGVkYnk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBhcmlhQ29udHJvbHM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWVzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdE9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgZm9ybWF0TGFiZWw6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcbiAgbWF4VmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLFxuICBtaW5WYWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsXG4gIG9uU2xpZGVyS2V5RG93bjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uU2xpZGVyTW91c2VNb3ZlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcGVyY2VudGFnZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdHlwZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgdmFsdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZS9UcmFja1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZWFjdCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3QnXSA6IG51bGwpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogR2V0IHRoZSBDU1Mgc3R5bGVzIGZvciBhbiBhY3RpdmUgdHJhY2tcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1RyYWNrfSB0cmFjayBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHN0eWxlc1xuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVUcmFja1N0eWxlKHRyYWNrKSB7XG4gIHZhciBwcm9wcyA9IHRyYWNrLnByb3BzO1xuXG4gIHZhciB3aWR0aCA9IChwcm9wcy5wZXJjZW50YWdlcy5tYXggLSBwcm9wcy5wZXJjZW50YWdlcy5taW4pICogMTAwICsgJyUnO1xuICB2YXIgbGVmdCA9IHByb3BzLnBlcmNlbnRhZ2VzLm1pbiAqIDEwMCArICclJztcblxuICB2YXIgYWN0aXZlVHJhY2tTdHlsZSA9IHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHdpZHRoOiB3aWR0aFxuICB9O1xuXG4gIHJldHVybiBhY3RpdmVUcmFja1N0eWxlO1xufVxuXG4vKipcbiAqIFRyYWNrIFJlYWN0IGNvbXBvbmVudFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFJlYWN0IGNvbXBvbmVudCBwcm9wc1xuICovXG5cbnZhciBUcmFjayA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVHJhY2ssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYWNrKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyYWNrLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgLy8gQXV0by1iaW5kXG4gICAgKDAsIF91dGlsLmF1dG9iaW5kKShbJ2hhbmRsZU1vdXNlRG93bicsICdoYW5kbGVUb3VjaFN0YXJ0J10sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdGVkIHByb3BUeXBlcyBvZiBUcmFja1xuICAgKiBAc3RhdGljIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNoaWxkcmVuXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNsYXNzTmFtZXNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25UcmFja01vdXNlRG93blxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwZXJjZW50YWdlc1xuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjbGllbnRSZWN0IG9mIHRoZSBjb21wb25lbnRcbiAgICogQG1lbWJlciB7Q2xpZW50UmVjdH1cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFRyYWNrLCBbe1xuICAgIGtleTogJ2hhbmRsZU1vdXNlRG93bicsXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IG1vdXNlZG93biBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgICAgdmFyIHRyYWNrQ2xpZW50UmVjdCA9IHRoaXMuY2xpZW50UmVjdDtcblxuICAgICAgdmFyIF9yZWYgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuXG4gICAgICB2YXIgY2xpZW50WCA9IF9yZWYuY2xpZW50WDtcblxuICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICB4OiBjbGllbnRYIC0gdHJhY2tDbGllbnRSZWN0LmxlZnQsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucHJvcHMub25UcmFja01vdXNlRG93bihldmVudCwgdGhpcywgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgdG91Y2hzdGFydCBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaFN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBtZXRob2Qgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29tcG9uZW50IEpTWFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGFjdGl2ZVRyYWNrU3R5bGUgPSBnZXRBY3RpdmVUcmFja1N0eWxlKHRoaXMpO1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLnByb3BzLmNsYXNzTmFtZXM7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMudHJhY2tDb250YWluZXIsXG4gICAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxuICAgICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuICAgICAgICAgIHJlZjogJ3RyYWNrJyB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgIHN0eWxlOiBhY3RpdmVUcmFja1N0eWxlLFxuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy50cmFja0FjdGl2ZSB9KSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGllbnRSZWN0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMucmVmcy50cmFjaztcblxuICAgICAgdmFyIGNsaWVudFJlY3QgPSB0cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYWNrO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRyYWNrO1xuVHJhY2sucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ub2RlLFxuICBjbGFzc05hbWVzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdE9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nKSxcbiAgb25UcmFja01vdXNlRG93bjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBlcmNlbnRhZ2VzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdE9mKF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyKS5pc1JlcXVpcmVkXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLyoqXG4gKiBAbW9kdWxlIElucHV0UmFuZ2UvZGVmYXVsdENsYXNzTmFtZXNcbiAqL1xuXG4vKipcbiogQW4gb2JqZWN0IGNvbnRhaW5pbmcgY2xhc3MgbmFtZXNcbiogQGNvbnN0IHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb21wb25lbnRcbiogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsQ29udGFpbmVyXG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbE1heFxuKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxNaW5cbiogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsVmFsdWVcbiogQHByb3BlcnR5IHtzdHJpbmd9IHNsaWRlclxuKiBAcHJvcGVydHkge3N0cmluZ30gc2xpZGVyQ29udGFpbmVyXG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSB0cmFja0FjdGl2ZVxuKiBAcHJvcGVydHkge3N0cmluZ30gdHJhY2tDb250YWluZXJcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBjb21wb25lbnQ6ICdJbnB1dFJhbmdlJyxcbiAgbGFiZWxDb250YWluZXI6ICdJbnB1dFJhbmdlLWxhYmVsQ29udGFpbmVyJyxcbiAgbGFiZWxNYXg6ICdJbnB1dFJhbmdlLWxhYmVsIElucHV0UmFuZ2UtbGFiZWwtLW1heCcsXG4gIGxhYmVsTWluOiAnSW5wdXRSYW5nZS1sYWJlbCBJbnB1dFJhbmdlLWxhYmVsLS1taW4nLFxuICBsYWJlbFZhbHVlOiAnSW5wdXRSYW5nZS1sYWJlbCBJbnB1dFJhbmdlLWxhYmVsLS12YWx1ZScsXG4gIHNsaWRlcjogJ0lucHV0UmFuZ2Utc2xpZGVyJyxcbiAgc2xpZGVyQ29udGFpbmVyOiAnSW5wdXRSYW5nZS1zbGlkZXJDb250YWluZXInLFxuICB0cmFja0FjdGl2ZTogJ0lucHV0UmFuZ2UtdHJhY2sgSW5wdXRSYW5nZS10cmFjay0tYWN0aXZlJyxcbiAgdHJhY2tDb250YWluZXI6ICdJbnB1dFJhbmdlLXRyYWNrIElucHV0UmFuZ2UtdHJhY2stLWNvbnRhaW5lcidcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9JbnB1dFJhbmdlID0gcmVxdWlyZSgnLi9JbnB1dFJhbmdlJyk7XG5cbnZhciBfSW5wdXRSYW5nZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbnB1dFJhbmdlKTtcblxuLyoqXG4gKiBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgcG9zaXRpb24gb2YgYSBwb2ludFxuICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCB2YWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IHZhbHVlXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVzY3JpYmluZyBhIHJhbmdlIG9mIHZhbHVlc1xuICogQHR5cGVkZWYge09iamVjdH0gUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gLSBNaW4gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXggLSBNYXggdmFsdWVcbiAqL1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfSW5wdXRSYW5nZTJbJ2RlZmF1bHQnXTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL21heE1pblZhbHVlUHJvcFR5cGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXhNaW5WYWx1ZVByb3BUeXBlID0gbWF4TWluVmFsdWVQcm9wVHlwZTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogQSBwcm9wIHR5cGUgYWNjZXB0aW5nIGEgcmFuZ2Ugb2YgbnVtZXJpYyB2YWx1ZXMgb3IgYSBzaW5nbGUgbnVtZXJpYyB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUmVhY3QgY29tcG9uZW50IHByb3BzXG4gKiBAcmV0dXJuIHs/RXJyb3J9IFJldHVybiBFcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzXG4gKi9cblxuZnVuY3Rpb24gbWF4TWluVmFsdWVQcm9wVHlwZShwcm9wcykge1xuICB2YXIgbWF4VmFsdWUgPSBwcm9wcy5tYXhWYWx1ZTtcbiAgdmFyIG1pblZhbHVlID0gcHJvcHMubWluVmFsdWU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgaXNWYWx1ZU51bWJlciA9ICgwLCBfdXRpbC5pc051bWJlcikodmFsdWUpO1xuICB2YXIgaXNEZWZhdWx0VmFsdWVOdW1iZXIgPSAoMCwgX3V0aWwuaXNOdW1iZXIpKGRlZmF1bHRWYWx1ZSk7XG4gIHZhciBpc1ZhbHVlTnVtYmVyT2JqZWN0ID0gKDAsIF91dGlsLm9iamVjdE9mKSh2YWx1ZSwgX3V0aWwuaXNOdW1iZXIpO1xuICB2YXIgaXNEZWZhdWx0VmFsdWVOdW1iZXJPYmplY3QgPSAoMCwgX3V0aWwub2JqZWN0T2YpKGRlZmF1bHRWYWx1ZSwgX3V0aWwuaXNOdW1iZXIpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignYHZhbHVlYCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuXG4gIGlmICghaXNWYWx1ZU51bWJlciAmJiAhaXNEZWZhdWx0VmFsdWVOdW1iZXIgJiYgIWlzVmFsdWVOdW1iZXJPYmplY3QgJiYgIWlzRGVmYXVsdFZhbHVlTnVtYmVyT2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignYHZhbHVlYCBvciBgZGVmYXVsdFZhbHVlYCBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5Jyk7XG4gIH1cblxuICBpZiAobWluVmFsdWUgPj0gbWF4VmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdgbWluVmFsdWVgIG11c3QgYmUgc21hbGxlciB0aGFuIGBtYXhWYWx1ZWAnKTtcbiAgfVxuXG4gIGlmIChtYXhWYWx1ZSA8PSBtaW5WYWx1ZSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ2BtYXhWYWx1ZWAgbXVzdCBiZSBsYXJnZXIgdGhhbiBgbWluVmFsdWVgJyk7XG4gIH1cblxuICBpZiAodmFsdWUgPCBtaW5WYWx1ZSB8fCB2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignYHZhbHVlYCBtdXN0IGJlIHdpdGhpbiBgbWluVmFsdWVgIGFuZCBgbWF4VmFsdWVgJyk7XG4gIH1cbn0iLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZS91dGlsXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgcHJlZGljYXRlRm5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuLyoqXG4gKiBDbGFtcCBhIHZhbHVlIGJldHdlZW4gYSBtaW4gYW5kIG1heCB2YWx1ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuaW5jbHVkZXMgPSBpbmNsdWRlcztcbmV4cG9ydHMub21pdCA9IG9taXQ7XG5leHBvcnRzLmNhcHRpYWxpemUgPSBjYXB0aWFsaXplO1xuZXhwb3J0cy5kaXN0YW5jZVRvID0gZGlzdGFuY2VUbztcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc0RlZmluZWQgPSBpc0RlZmluZWQ7XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbmV4cG9ydHMub2JqZWN0T2YgPSBvYmplY3RPZjtcbmV4cG9ydHMuYXV0b2JpbmQgPSBhdXRvYmluZDtcblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW4gT2JqZWN0XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyAtIFNvdXJjZSBvYmplY3RzXG4gKiBAcmV0dXJuIHtPYmplY3R9IERlc3RpbmF0aW9uIG9iamVjdCwgZXh0ZW5kZWQgd2l0aCBtZW1iZXJzIGZyb20gc291cmNlc1xuICovXG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgaW5jbHVkZWQgaW4gYW4gYXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyBvYmplY3Qgd2l0aG91dCB0aGUgc3BlY2lmaWVkIGtleXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IG9taXRLZXlzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gb21pdChvYmosIG9taXRLZXlzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIG91dHB1dE9iaiA9IHt9O1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpbmNsdWRlcyhvbWl0S2V5cywga2V5KSkge1xuICAgICAgb3V0cHV0T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXRPYmo7XG59XG5cbi8qKlxuICogQ2FwdGlhbGl6ZSBhIHN0cmluZ1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGNhcHRpYWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50QSBhbmQgcG9pbnRCXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludEFcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50QlxuICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIGRpc3RhbmNlVG8ocG9pbnRBLCBwb2ludEIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludEIueCAtIHBvaW50QS54LCAyKSArIE1hdGgucG93KHBvaW50Qi55IC0gcG9pbnRBLnksIDIpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gbnVtYmVyc1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG51bUFcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuZ3RoKG51bUEsIG51bUIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKG51bUEgLSBudW1CKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZGVmaW5lZFxuICogQHN0YXRpY1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGVtcHR5XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYWxsIGl0ZW1zIGluIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtwcmVkaWNhdGVGbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGFycmF5T2YoYXJyYXksIHByZWRpY2F0ZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYWxsIGl0ZW1zIGluIGFuIG9iamVjdCBtYXRjaCBhIHByZWRpY2F0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtwcmVkaWNhdGVGbn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBrZXlzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG9iamVjdE9mKG9iamVjdCwgcHJlZGljYXRlLCBrZXlzKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGtleXMgfHwgT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgaWYgKCFwcmVkaWNhdGUob2JqZWN0W3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEJpbmQgYWxsIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIGl0c2VsZlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBtZXRob2ROYW1lc1xuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gYXV0b2JpbmQobWV0aG9kTmFtZXMsIGluc3RhbmNlKSB7XG4gIG1ldGhvZE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBpbnN0YW5jZVttZXRob2ROYW1lXSA9IGluc3RhbmNlW21ldGhvZE5hbWVdLmJpbmQoaW5zdGFuY2UpO1xuICB9KTtcbn0iLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZS92YWx1ZVRyYW5zZm9ybWVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogQ29udmVydCBwb3NpdGlvbiBpbnRvIHBlcmNlbnRhZ2UgdmFsdWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb25cbiAqIEByZXR1cm4ge251bWJlcn0gUGVyY2VudGFnZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBwZXJjZW50YWdlRnJvbVBvc2l0aW9uKGlucHV0UmFuZ2UsIHBvc2l0aW9uKSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dFJhbmdlLnRyYWNrQ2xpZW50UmVjdC53aWR0aDtcbiAgdmFyIHNpemVQZXJjID0gcG9zaXRpb24ueCAvIGxlbmd0aDtcblxuICByZXR1cm4gc2l6ZVBlcmMgfHwgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHBvc2l0aW9uIGludG8gbW9kZWwgdmFsdWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb25cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kZWwgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmFsdWVGcm9tUG9zaXRpb24oaW5wdXRSYW5nZSwgcG9zaXRpb24pIHtcbiAgdmFyIHNpemVQZXJjID0gcGVyY2VudGFnZUZyb21Qb3NpdGlvbihpbnB1dFJhbmdlLCBwb3NpdGlvbik7XG4gIHZhciB2YWx1ZURpZmYgPSBpbnB1dFJhbmdlLnByb3BzLm1heFZhbHVlIC0gaW5wdXRSYW5nZS5wcm9wcy5taW5WYWx1ZTtcbiAgdmFyIHZhbHVlID0gaW5wdXRSYW5nZS5wcm9wcy5taW5WYWx1ZSArIHZhbHVlRGlmZiAqIHNpemVQZXJjO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHZhbHVlcyBmcm9tIHByb3BzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2VcbiAqIEBwYXJhbSB7UG9pbnR9IFtwcm9wcz1pbnB1dFJhbmdlLnByb3BzXVxuICogQHJldHVybiB7UmFuZ2V9IFJhbmdlIHZhbHVlc1xuICovXG5mdW5jdGlvbiB2YWx1ZXNGcm9tUHJvcHMoaW5wdXRSYW5nZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGlucHV0UmFuZ2UgOiBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHByb3BzID0gX3JlZi5wcm9wcztcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlucHV0UmFuZ2UuaXNNdWx0aVZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVzID0gcHJvcHMudmFsdWU7XG5cbiAgICAgIGlmICgoMCwgX3V0aWwuaXNFbXB0eSkodmFsdWVzKSB8fCAhKDAsIF91dGlsLm9iamVjdE9mKSh2YWx1ZXMsIF91dGlsLmlzTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZXMgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHZhbHVlcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gKDAsIF91dGlsLmlzTnVtYmVyKShwcm9wcy52YWx1ZSkgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IHByb3BzLm1pblZhbHVlLFxuICAgICAgbWF4OiB2YWx1ZVxuICAgIH07XG4gIH0pKCk7XG59XG5cbi8qKlxuICogQ29udmVydCB2YWx1ZSBpbnRvIHBlcmNlbnRhZ2UgdmFsdWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBlcmNlbnRhZ2UgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcGVyY2VudGFnZUZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZSkge1xuICB2YXIgdmFsaWRWYWx1ZSA9ICgwLCBfdXRpbC5jbGFtcCkodmFsdWUsIGlucHV0UmFuZ2UucHJvcHMubWluVmFsdWUsIGlucHV0UmFuZ2UucHJvcHMubWF4VmFsdWUpO1xuICB2YXIgdmFsdWVEaWZmID0gaW5wdXRSYW5nZS5wcm9wcy5tYXhWYWx1ZSAtIGlucHV0UmFuZ2UucHJvcHMubWluVmFsdWU7XG4gIHZhciB2YWx1ZVBlcmMgPSAodmFsaWRWYWx1ZSAtIGlucHV0UmFuZ2UucHJvcHMubWluVmFsdWUpIC8gdmFsdWVEaWZmO1xuXG4gIHJldHVybiB2YWx1ZVBlcmMgfHwgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHZhbHVlcyBpbnRvIHBlcmNlbnRhZ2UgdmFsdWVzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2VcbiAqIEBwYXJhbSB7UmFuZ2V9IHZhbHVlc1xuICogQHJldHVybiB7UmFuZ2V9IFBlcmNlbnRhZ2UgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHBlcmNlbnRhZ2VzRnJvbVZhbHVlcyhpbnB1dFJhbmdlLCB2YWx1ZXMpIHtcbiAgdmFyIHBlcmNlbnRhZ2VzID0ge1xuICAgIG1pbjogcGVyY2VudGFnZUZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZXMubWluKSxcbiAgICBtYXg6IHBlcmNlbnRhZ2VGcm9tVmFsdWUoaW5wdXRSYW5nZSwgdmFsdWVzLm1heClcbiAgfTtcblxuICByZXR1cm4gcGVyY2VudGFnZXM7XG59XG5cbi8qKlxuICogQ29udmVydCB2YWx1ZSBpbnRvIHBvc2l0aW9uXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7UG9pbnR9IFBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uRnJvbVZhbHVlKGlucHV0UmFuZ2UsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dFJhbmdlLnRyYWNrQ2xpZW50UmVjdC53aWR0aDtcbiAgdmFyIHZhbHVlUGVyYyA9IHBlcmNlbnRhZ2VGcm9tVmFsdWUoaW5wdXRSYW5nZSwgdmFsdWUpO1xuICB2YXIgcG9zaXRpb25WYWx1ZSA9IHZhbHVlUGVyYyAqIGxlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHg6IHBvc2l0aW9uVmFsdWUsXG4gICAgeTogMFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSByYW5nZSBvZiB2YWx1ZXMgaW50byBwb3NpdGlvbnNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtSYW5nZX0gdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgUG9pbnQ+fVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbnNGcm9tVmFsdWVzKGlucHV0UmFuZ2UsIHZhbHVlcykge1xuICB2YXIgcG9zaXRpb25zID0ge1xuICAgIG1pbjogcG9zaXRpb25Gcm9tVmFsdWUoaW5wdXRSYW5nZSwgdmFsdWVzLm1pbiksXG4gICAgbWF4OiBwb3NpdGlvbkZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZXMubWF4KVxuICB9O1xuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIHBvc2l0aW9uIGZyb20gYW4gZXZlbnRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge1BvaW50fVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbkZyb21FdmVudChpbnB1dFJhbmdlLCBldmVudCkge1xuICB2YXIgdHJhY2tDbGllbnRSZWN0ID0gaW5wdXRSYW5nZS50cmFja0NsaWVudFJlY3Q7XG4gIHZhciBsZW5ndGggPSB0cmFja0NsaWVudFJlY3Qud2lkdGg7XG5cbiAgdmFyIF9yZWYyID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcblxuICB2YXIgY2xpZW50WCA9IF9yZWYyLmNsaWVudFg7XG5cbiAgdmFyIHBvc2l0aW9uID0ge1xuICAgIHg6ICgwLCBfdXRpbC5jbGFtcCkoY2xpZW50WCAtIHRyYWNrQ2xpZW50UmVjdC5sZWZ0LCAwLCBsZW5ndGgpLFxuICAgIHk6IDBcbiAgfTtcblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBzdGVwIHZhbHVlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfSBTdGVwIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHN0ZXBWYWx1ZUZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIGlucHV0UmFuZ2UucHJvcHMuc3RlcCkgKiBpbnB1dFJhbmdlLnByb3BzLnN0ZXA7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgcGVyY2VudGFnZUZyb21Qb3NpdGlvbjogcGVyY2VudGFnZUZyb21Qb3NpdGlvbixcbiAgcGVyY2VudGFnZUZyb21WYWx1ZTogcGVyY2VudGFnZUZyb21WYWx1ZSxcbiAgcGVyY2VudGFnZXNGcm9tVmFsdWVzOiBwZXJjZW50YWdlc0Zyb21WYWx1ZXMsXG4gIHBvc2l0aW9uRnJvbUV2ZW50OiBwb3NpdGlvbkZyb21FdmVudCxcbiAgcG9zaXRpb25Gcm9tVmFsdWU6IHBvc2l0aW9uRnJvbVZhbHVlLFxuICBwb3NpdGlvbnNGcm9tVmFsdWVzOiBwb3NpdGlvbnNGcm9tVmFsdWVzLFxuICBzdGVwVmFsdWVGcm9tVmFsdWU6IHN0ZXBWYWx1ZUZyb21WYWx1ZSxcbiAgdmFsdWVGcm9tUG9zaXRpb246IHZhbHVlRnJvbVBvc2l0aW9uLFxuICB2YWx1ZXNGcm9tUHJvcHM6IHZhbHVlc0Zyb21Qcm9wc1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUb29sdGlwIGZyb20gJy4uL3Rvb2x0aXAvd3YudG9vbHRpcCc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgQnVpbGRzIGEgcmF0aGVyIHNwZWNpZmljXG4gKiBpbnRlcmFjdGl2ZSB3aWRnZXRcbiAqXG4gKiBAY2xhc3MgQW5pbWF0aW9uV2lkZ2V0XG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgYW5pbVdpZGdldEhlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4oXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nd3YtYW5pbWF0aW9uLXdpZGdldC1oZWFkZXInPlxuICAgICAgICB7J0FuaW1hdGUgTWFwIGluICd9XG4gICAgICAgIDxUb29sdGlwIHRleHQ9e3RoaXMucHJvcHMudGV4dH0gb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfSBkYXRhQXJyYXk9e3RoaXMucHJvcHMudG9vbFRpcFRleHRBcnJheX0vPlxuICAgICAgICB7JyBJbmNyZW1lbnRzJ31cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSW5wdXRSYW5nZSBmcm9tICdyZWFjdC1pbnB1dC1yYW5nZSc7XG5pbXBvcnQgVGltZVNlbGVjdG9yIGZyb20gJy4uL2RhdGVzZWxlY3Rvci93di5kYXRlc2VsZWN0b3InO1xuaW1wb3J0IExvb3BCdXR0b24gZnJvbSAnLi93di5sb29wYnV0dG9uJztcbmltcG9ydCBQbGF5QnV0dG9uIGZyb20gJy4vd3YucGxheWJ1dHRvbic7XG5pbXBvcnQgQW5pbVdpZGdldEhlYWRlciBmcm9tICcuL3d2LmFuaW1hdGlvbi53aWRnZXQuaGVhZGVyJztcbmltcG9ydCBHQSBmcm9tICcuLi91dGlsL3d2Lmdvb2dsZUFuYWx5dGljcyc7XG5cblxuXG4vKlxuICogQSByZWFjdCBjb21wb25lbnQsIEJ1aWxkcyBhIHJhdGhlciBzcGVjaWZpY1xuICogaW50ZXJhY3RpdmUgd2lkZ2V0XG4gKlxuICogQGNsYXNzIEFuaW1hdGlvbldpZGdldFxuICogQGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbldpZGdldCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSAge1xuICAgICAgdmFsdWU6IHByb3BzLnNsaWRlclNwZWVkLFxuICAgICAgbG9vcGluZzogcHJvcHMubG9vcGluZyxcbiAgICAgIHN0YXJ0RGF0ZTogcHJvcHMuc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZTogcHJvcHMuZW5kRGF0ZSxcbiAgICAgIGhlYWRlcjogcHJvcHMuaGVhZGVyLFxuICAgICAgaW5jcmVtZW50QXJyYXk6IHByb3BzLmluY3JlbWVudEFycmF5LFxuICAgICAgaW5jcmVtZW50OiBwcm9wcy5pbmNyZW1lbnRcblxuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBTZXRzIGEgbmV3IHN0YXRlIHZhbHVlIHdoZW4gYVxuICAgKiB3aGVuIHRoZSBzbGlkZXIgaXMgYWRqdXN0ZWRcbiAgICpcbiAgICogQG1ldGhvZCBvblNsaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBzbGlkZXIgcmVhY3RcbiAgICogIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAqICBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIG9uU2xpZGUoY29tcG9uZW50LCB2YWx1ZSkge1xuICAgIHRoaXMucHJvcHMub25TbGlkZSh2YWx1ZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIGNhbGxzIHRoZSBjYWxsYmFjaywgcGFzc2luZyB0aGVcbiAgICogY3VycmVudCBzdGF0ZSBlbGVtZW50cyBhcyBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBtZXRob2QgcGxheVxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLnByb3BzLm9uUHVzaFBsYXkoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBsYXlpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnByb3BzLm9uUHVzaFBhdXNlKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwbGF5aW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qXG4gICAqIFNldHMgYSBuZXcgc3RhdGUgdG8gc2F5IHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3BcbiAgICpcbiAgICogQG1ldGhvZCBvbkxvb3BcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIHNsaWRlciByZWFjdFxuICAgKiAgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgb25Mb29wKCkge1xuICAgIHZhciBsb29wID0gdHJ1ZTtcbiAgICBpZih0aGlzLnN0YXRlLmxvb3BpbmcpIHtcbiAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBsb29waW5nOiBsb29wXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vblB1c2hMb29wKGxvb3ApO1xuICB9XG4gIG9uRGF0ZUNoYW5nZShpZCwgZGF0ZSkge1xuICAgIGlmKGlkID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhcnREYXRlOiBkYXRlXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcHMub25EYXRlQ2hhbmdlKFxuICAgICAgICBkYXRlLFxuICAgICAgICB0aGlzLnN0YXRlLmVuZERhdGVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBlbmREYXRlOiBkYXRlXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcHMub25EYXRlQ2hhbmdlKFxuICAgICAgICB0aGlzLnN0YXRlLnN0YXJ0RGF0ZSxcbiAgICAgICAgZGF0ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgIDxkaXYgaWQ9XCJ3di1hbmltYXRpb24td2lkZ2V0XCIgY2xhc3NOYW1lPVwid3YtYW5pbWF0aW9uLXdpZGdldFwiPlxuICAgICAgICA8QW5pbVdpZGdldEhlYWRlclxuICAgICAgICAgIHRleHQ9e3RoaXMuc3RhdGUuaW5jcmVtZW50fVxuICAgICAgICAgIHRvb2xUaXBUZXh0QXJyYXk9e3RoaXMuc3RhdGUuaW5jcmVtZW50QXJyYXl9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vblpvb21TZWxlY3R9Lz5cblxuICAgICAgICA8UGxheUJ1dHRvbiBwbGF5aW5nPXt0aGlzLnN0YXRlLnBsYXlpbmd9IHBsYXk9e3RoaXMucGxheS5iaW5kKHRoaXMpfSBwYXVzZT17dGhpcy5wYXVzZS5iaW5kKHRoaXMpfSAvPlxuICAgICAgICA8TG9vcEJ1dHRvbiBsb29waW5nPXt0aGlzLnN0YXRlLmxvb3Bpbmd9IG9uTG9vcD17dGhpcy5vbkxvb3AuYmluZCh0aGlzKX0vPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInd2LXNsaWRlci1jYXNlXCI+XG4gICAgICAgICAgPElucHV0UmFuZ2UgbWF4VmFsdWU9ezEwfSBtaW5WYWx1ZT17MX0gdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9IG9uQ2hhbmdlPXt0aGlzLm9uU2xpZGUuYmluZCh0aGlzKX0gLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ3di1zbGlkZXItbGFiZWxcIj57dGhpcy5wcm9wcy5zbGlkZXJMYWJlbH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQobnVsbClcIlxuICAgICAgICAgIHRpdGxlPVwiQ3JlYXRlIEFuaW1hdGVkIEdJRlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwid3YtaWNvbi1jYXNlXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLm9uUHVzaEdJRn1cbiAgICAgICAgPlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLWZpbGUtdmlkZW8tbyB3di1hbmltYXRpb24td2lkZ2V0LWljb25cIi8+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3d2LWFuaW0tZGF0ZXMtY2FzZSc+XG4gICAgICAgICAgPFRpbWVTZWxlY3RvclxuICAgICAgICAgICAgd2lkdGg9XCIxMjBcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMzBcIlxuICAgICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5zdGFydERhdGV9XG4gICAgICAgICAgICBpZD0nc3RhcnQnXG4gICAgICAgICAgICBvbkRhdGVDaGFuZ2U9e3RoaXMub25EYXRlQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBtYXhEYXRlPXt0aGlzLnN0YXRlLmVuZERhdGV9XG4gICAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndGhydS1sYWJlbCc+VG88L2Rpdj5cbiAgICAgICAgICA8VGltZVNlbGVjdG9yXG4gICAgICAgICAgICB3aWR0aD1cIjEyMFwiXG4gICAgICAgICAgICBoZWlnaHQ9XCIzMFwiXG4gICAgICAgICAgICBkYXRlPXt0aGlzLnN0YXRlLmVuZERhdGV9XG4gICAgICAgICAgICBpZD0nZW5kJ1xuICAgICAgICAgICAgb25EYXRlQ2hhbmdlPXt0aGlzLm9uRGF0ZUNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgICAgbWluRGF0ZT17dGhpcy5zdGF0ZS5zdGFydERhdGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlcbiAgICAgICAgICBjbGFzc05hbWU9XCJmYSBmYS1jbG9zZSB3di1jbG9zZVwiXG4gICAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsb3NlfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICApO1xuICB9XG5cbn1cbiIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBCdWlsZHMgYSByYXRoZXIgc3BlY2lmaWNcbiAqIGludGVyYWN0aXZlIHdpZGdldFxuICpcbiAqIEBjbGFzcyBBbmltYXRpb25XaWRnZXRcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb29wQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZChudWxsKVwiXG4gICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMubG9vcGluZyA/IFwiU3RvcCBMb29wXCIgOiBcIkxvb3AgdmlkZW9cIn1cbiAgICAgICAgICBjbGFzc05hbWU9e3RoaXMucHJvcHMubG9vcGluZyA/ICd3di1sb29wLWljb24tY2FzZSB3di1pY29uLWNhc2UgYWN0aXZlJyA6ICd3di1sb29wLWljb24tY2FzZSB3di1pY29uLWNhc2UnfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25Mb29wfVxuICAgICAgICA+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdmYSBmYS1yZXR3ZWV0IHd2LWFuaW1hdGlvbi13aWRnZXQtaWNvbicgLz5cbiAgICAgICAgPC9hPlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgQnVpbGRzIGEgcmF0aGVyIHNwZWNpZmljXG4gKiBpbnRlcmFjdGl2ZSB3aWRnZXRcbiAqXG4gKiBAY2xhc3MgQW5pbWF0aW9uV2lkZ2V0XG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheUJ1dHRvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4oXG4gICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKG51bGwpXCIgdGl0bGU9e3RoaXMucHJvcHMucGxheWluZyA/ICdQYXVzZSB2aWRlbycgOiAnUGxheSB2aWRlbyd9XG4gICAgICAgIGNsYXNzTmFtZT0nd3YtYW5pbS1wbGF5LWNhc2Ugd3YtaWNvbi1jYXNlJ1xuICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLnBsYXlpbmcgPyB0aGlzLnByb3BzLnBhdXNlIDogdGhpcy5wcm9wcy5wbGF5fVxuICAgICAgPlxuICAgICAgICA8aSBjbGFzc05hbWU9e3RoaXMucHJvcHMucGxheWluZyA/ICdmYSBmYS1wYXVzZSB3di1hbmltYXRpb24td2lkZ2V0LWljb24nOiAnZmEgZmEtcGxheSB3di1hbmltYXRpb24td2lkZ2V0LWljb24nfSAvPlxuICAgICAgPC9hPlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRGF0ZUlucHV0Q29sdW1uIGZyb20gJy4vd3YuZGF0ZXNlbGVjdG9yLmlucHV0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlsL3d2LnV0aWxzJztcblxuY29uc3QgdXRpbCA9IG5ldyBVdGlscygpO1xuXG4vKlxuICogQSByZWFjdCBjb21wb25lbnQsIGlzIGEgZHJhZ2dhYmxlIHN2Z1xuICogZ3JvdXAuIEl0IGlzIGEgcGFyZW50IGNvbXBvbmVudCB0aGF0XG4gKiByZXJlbmRlcnMgd2hlbiBjaGlsZCBlbGVtZW50cyBhcmUgZHJhZ2dlZFxuICpcbiAqIEBjbGFzcyBUaW1lbGluZVJhbmdlU2VsZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZGF0ZVNlbGVjdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgbWF4RGF0ZTogcHJvcHMubWF4RGF0ZSxcbiAgICAgIG1pbkRhdGU6IHByb3BzLm1pbkRhdGUsXG4gICAgICB0YWI6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBtYXhEYXRlOiBwcm9wcy5tYXhEYXRlLFxuICAgICAgbWluRGF0ZTogcHJvcHMubWluRGF0ZSxcbiAgICB9KTtcbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe3RhYjogbnVsbH0pO1xuICB9XG4gIG5leHRUYWIoaW5kZXgpIHtcbiAgICB2YXIgbmV4dFRhYjtcbiAgICBpZihpbmRleCA8IDMpIHtcbiAgICAgIG5leHRUYWIgPSBpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRUYWIgPSAxO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHRhYjogbmV4dFRhYlxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdGUoZGF0ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGF0ZTogZGF0ZVxuICAgIH0pO1xuICAgIHRoaXMucHJvcHMub25EYXRlQ2hhbmdlKHRoaXMucHJvcHMuaWQsIGRhdGUpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3di1kYXRlLXNlbGVjdG9yLXdpZGdldFwiPlxuICAgICAgICA8RGF0ZUlucHV0Q29sdW1uIHN0YXJ0RGF0ZT17bmV3IERhdGUoMjAwMCl9XG4gICAgICAgICAgdG9kYXk9e25ldyBEYXRlKCl9XG4gICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDRnVsbFllYXIoKX1cbiAgICAgICAgICB0eXBlPVwieWVhclwiXG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy53aWR0aH1cbiAgICAgICAgICB1cGRhdGVEYXRlPXt0aGlzLnVwZGF0ZURhdGUuYmluZCh0aGlzKX1cbiAgICAgICAgICB0YWJJbmRleD17MX1cbiAgICAgICAgICBmb2N1c2VkPXsodGhpcy5zdGF0ZS50YWIgPT0gMSl9XG4gICAgICAgICAgbmV4dFRhYj17dGhpcy5uZXh0VGFiLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgIG1pbkRhdGU9e3RoaXMucHJvcHMubWluRGF0ZX1cbiAgICAgICAgICBibHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgICAvPlxuICAgICAgICA8RGF0ZUlucHV0Q29sdW1uXG4gICAgICAgICAgc3RhcnREYXRlPXtuZXcgRGF0ZSgyMDAwKX1cbiAgICAgICAgICB0b2RheT17bmV3IERhdGUoKX0gZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHR5cGU9XCJtb250aFwiIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgdXBkYXRlRGF0ZT17dGhpcy51cGRhdGVEYXRlLmJpbmQodGhpcyl9XG4gICAgICAgICAgdmFsdWU9e3V0aWwubW9udGhTdHJpbmdBcnJheVt0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDTW9udGgoKV19XG4gICAgICAgICAgdGFiSW5kZXg9ezJ9XG4gICAgICAgICAgZm9jdXNlZD17KHRoaXMuc3RhdGUudGFiID09IDIpfVxuICAgICAgICAgIG5leHRUYWI9e3RoaXMubmV4dFRhYi5iaW5kKHRoaXMpfVxuICAgICAgICAgIG1heERhdGU9e3RoaXMucHJvcHMubWF4RGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgYmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW5cbiAgICAgICAgICBzdGFydERhdGU9e25ldyBEYXRlKDIwMDApfVxuICAgICAgICAgIHRvZGF5PXtuZXcgRGF0ZSgpfVxuICAgICAgICAgIGRhdGU9e3RoaXMuc3RhdGUuZGF0ZX1cbiAgICAgICAgICB0eXBlPVwiZGF5XCJcbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLndpZHRofVxuICAgICAgICAgIHVwZGF0ZURhdGU9e3RoaXMudXBkYXRlRGF0ZS5iaW5kKHRoaXMpfVxuICAgICAgICAgIHZhbHVlPXt1dGlsLnBhZCh0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDRGF0ZSgpLCAyLCAnMCcpfVxuICAgICAgICAgIHRhYkluZGV4PXszfVxuICAgICAgICAgIGZvY3VzZWQ9eyh0aGlzLnN0YXRlLnRhYiA9PSAzKX1cbiAgICAgICAgICBuZXh0VGFiPXt0aGlzLm5leHRUYWIuYmluZCh0aGlzKX1cbiAgICAgICAgICBtYXhEYXRlPXt0aGlzLnByb3BzLm1heERhdGV9XG4gICAgICAgICAgbWluRGF0ZT17dGhpcy5wcm9wcy5taW5EYXRlfVxuICAgICAgICAgIGJsdXI9e3RoaXMuYmx1ci5iaW5kKHRoaXMpfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLypcbiAqIE5BU0EgV29ybGR2aWV3XG4gKlxuICogVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IGRldmVsb3BlZCBhdCBOQVNBL0dvZGRhcmQgU3BhY2UgRmxpZ2h0IENlbnRlciBmb3JcbiAqIHRoZSBFYXJ0aCBTY2llbmNlIERhdGEgYW5kIEluZm9ybWF0aW9uIFN5c3RlbSAoRVNESVMpIHByb2plY3QuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEzIC0gMjAxNiBVbml0ZWQgU3RhdGVzIEdvdmVybm1lbnQgYXMgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiBBZG1pbmlzdHJhdG9yIG9mIHRoZSBOYXRpb25hbCBBZXJvbmF1dGljcyBhbmQgU3BhY2UgQWRtaW5pc3RyYXRpb24uXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOQVNBIE9wZW4gU291cmNlIEFncmVlbWVudCwgVmVyc2lvbiAxLjNcbiAqIGh0dHA6Ly9vcGVuc291cmNlLmdzZmMubmFzYS5nb3Yvbm9zYS5waHBcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RG9tIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsL3d2LnV0aWxzJztcblxuY29uc3QgdXRpbCA9IG5ldyBVdGlsKCk7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlSW5wdXRDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZih0aGlzLnByb3BzLmZvY3VzZWQpIHtcbiAgICAgIFJlYWN0RG9tLmZpbmRET01Ob2RlKHRoaXMucmVmc1snaW5wdXQtJyArIHRoaXMucHJvcHMudGFiSW5kZXhdKS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIHNpemU7XG4gICAgdmFyIHR5cGU7XG4gICAgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcbiAgICBpZih0eXBlID09PSAneWVhcicpIHtcbiAgICAgIHNpemUgPSAnNCc7XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICdkYXknKSB7XG4gICAgICBzaXplID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IDM7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBwcm9wcy52YWx1ZX0pO1xuICB9XG4gIG9uS2V5UHJlc3MoZSkge1xuICAgIHZhciBrYyA9IGUua2V5Q29kZTtcbiAgICBpZihrYyA9PT0gOSB8fCAvLyB0YWJcbiAgICAgIGtjID09PSAxMykgeyAvL2VudGVyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICBvbktleVVwKGUpIHtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICB2YXIgZW50ZXJlZCA9IChrZXlDb2RlID09IDEzIHx8IGtleUNvZGUgPT0gOSk7XG4gICAgaWYoa2V5Q29kZSA9PT0gMzgpIHsgLy91cFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5vbkNsaWNrVXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYoa2V5Q29kZSA9PT0gNDApIHsvLyBkb3duXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm9uQ2xpY2tEb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnR5cGUgPT0gJ2ZvY3Vzb3V0JyB8fCBlbnRlcmVkKSB7XG4gICAgICBpZih0aGlzLnByb3BzLnR5cGUgPT0gJ3llYXInIHx8IHRoaXMucHJvcHMudHlwZSA9PSAnZGF5Jykge1xuICAgICAgICBpZighKChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpXG4gICAgICAgIHx8IGVudGVyZWRcbiAgICAgICAgfHwga2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoKHRoaXMucHJvcHMudHlwZSkge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy55ZWFyVmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF5VmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy5tb250aFZhbGlkYXRpb24odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYobmV3RGF0ZSkge1xuICAgICAgICB0aGlzLnByb3BzLnVwZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICAgIGlmKGVudGVyZWQpIHsgLy9pZiBlbmV0ZXJlZCBvciB0YWJiZWRcbiAgICAgICAgICB0aGlzLm5leHRUYWIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGVudGVyZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkNsaWNrVXAoKSB7XG4gICAgdGhpcy5yb2xsRGF0ZSgxKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG5cbiAgfVxuICBvbkNsaWNrRG93bigpIHtcbiAgICB0aGlzLnJvbGxEYXRlKC0xKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgeWVhclZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICBpZigoaW5wdXQgPiAxMDAwKSAmJiAoaW5wdXQgPCA5OTk5KSkge1xuICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKChuZXcgRGF0ZSh0aGlzLnByb3BzLmRhdGUpKS5zZXRVVENGdWxsWWVhcihpbnB1dCkpO1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgIH1cbiAgfVxuICBkYXlWYWxpZGF0aW9uKGlucHV0KSB7XG4gICAgdmFyIG5ld0RhdGU7XG4gICAgdmFyIG1heERhdGU7XG4gICAgdmFyIGN1cnJlbnREYXRlID0gdGhpcy5wcm9wcy5kYXRlO1xuXG4gICAgbWF4RGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlLmdldFllYXIoKSwgY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKTtcblxuICAgIGlmKGlucHV0ID4gMCAmJiBpbnB1dCA8PSBtYXhEYXRlKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKGN1cnJlbnREYXRlKSkuc2V0VVRDRGF0ZShpbnB1dCkpO1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgIH1cblxuICB9XG4gIHJvbGxEYXRlKGFtdCkge1xuICAgIHZhciBuZXdEYXRlID0gdXRpbC5yb2xsRGF0ZShcbiAgICAgIHRoaXMucHJvcHMuZGF0ZSxcbiAgICAgIHRoaXMucHJvcHMudHlwZSxcbiAgICAgIGFtdCxcbiAgICAgIHRoaXMucHJvcHMubWluRGF0ZSxcbiAgICAgIHRoaXMucHJvcHMubWF4RGF0ZVxuICAgICk7XG4gICAgdGhpcy5wcm9wcy51cGRhdGVEYXRlKG5ld0RhdGUpO1xuICB9XG5cbiAgbW9udGhWYWxpZGF0aW9uKGlucHV0KSB7XG4gICAgdmFyIG5ld0RhdGU7XG4gICAgaWYgKCghaXNOYU4oaW5wdXQpKSAmJiBpbnB1dCA8IDEzICYmIGlucHV0ID4gMCkge1xuICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKChuZXcgRGF0ZSh0aGlzLnByb3BzLmRhdGUpKS5zZXRVVENNb250aChpbnB1dCAtIDEpKTtcbiAgICAgIGlmKG5ld0RhdGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdmFsdWU6IHV0aWwubW9udGhTdHJpbmdBcnJheVtpbnB1dC0xXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVhbE1vbnRoO1xuICAgICAgcmVhbE1vbnRoID0gdXRpbC5zdHJpbmdJbkFycmF5KHV0aWwubW9udGhTdHJpbmdBcnJheSwgaW5wdXQpO1xuICAgICAgaWYocmVhbE1vbnRoICE9PSBmYWxzZSkge1xuICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ01vbnRoKHJlYWxNb250aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzLmJsdXIoKTtcbiAgfVxuICBvbkNoYW5nZShlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogZS50YXJnZXQudmFsdWUudG9VcHBlckNhc2UoKVxuICAgIH0pO1xuICB9XG4gIG5leHRUYWIoKSB7XG4gICAgdGhpcy5wcm9wcy5uZXh0VGFiKHRoaXMucHJvcHMudGFiSW5kZXgpO1xuICB9XG4gIHZhbGlkYXRlRGF0ZShkYXRlKSB7XG4gICAgaWYoZGF0ZSA+IHRoaXMucHJvcHMubWluRGF0ZSAmJiBkYXRlIDw9IHRoaXMucHJvcHMubWF4RGF0ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LXdyYXBwZXJcIiBzdHlsZT17KHRoaXMuc3RhdGUudmFsaWQpID8ge30gOiB7Ym9yZGVyQ29sb3I6ICcjZmYwMDAwJ319ID5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tVcC5iaW5kKHRoaXMpfSBjbGFzc05hbWU9XCJkYXRlLWFycm93cyBkYXRlLWFycm93LXVwXCIgZGF0YS1pbnRlcnZhbD17dGhpcy5wcm9wcy50eXBlfT5cbiAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjhcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0gMTIuNSwwIDI1LDggMCw4IHpcIiBjbGFzc05hbWU9XCJ1cGFycm93XCI+XG4gICAgICAgICAgICAgIDwvcGF0aD5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHJlZj17J2lucHV0LScgKyB0aGlzLnByb3BzLnRhYkluZGV4fVxuICAgICAgICAgIHNpemU9e3RoaXMuc2l6ZX1cbiAgICAgICAgICBtYXhMZW5ndGg9e3RoaXMuc2l6ZX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24taW5wdXQtZ3JvdXBcIlxuICAgICAgICAgIGlkPXt0aGlzLnByb3BzLnR5cGUgKyAnLWlucHV0LWdyb3VwJ31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cbiAgICAgICAgICBvbktleVVwPXt0aGlzLm9uS2V5VXAuYmluZCh0aGlzKX1cbiAgICAgICAgICBvbktleURvd249e3RoaXMub25LZXlQcmVzcy5iaW5kKHRoaXMpfSAvL2N1cnJlbnRseSBub3Qgd29ya2luZ1xuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgc3R5bGU9e3tmb250U2l6ZTogKCh0aGlzLnByb3BzLmhlaWdodCAvIDIpICsgJ3B4Jyl9fVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5vbkNsaWNrRG93bi5iaW5kKHRoaXMpfSBjbGFzc05hbWU9XCJkYXRlLWFycm93cyBkYXRlLWFycm93LWRvd25cIiBkYXRhLWludGVydmFsPXt0aGlzLnByb3BzLnR5cGV9PlxuICAgICAgICAgIDxzdmcgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjhcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNIDEyLjUsMCAyNSw4IDAsOCB6XCIgY2xhc3NOYW1lPVwiZG93bmFycm93XCI+PC9wYXRoPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3REb20gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwvd3YudXRpbHMnO1xuXG5jb25zdCB1dGlsID0gbmV3IFV0aWwoKTtcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBpcyBhIGRyYWdnYWJsZSBzdmdcbiAqIGdyb3VwLiBJdCBpcyBhIHBhcmVudCBjb21wb25lbnQgdGhhdFxuICogcmVyZW5kZXJzIHdoZW4gY2hpbGQgZWxlbWVudHMgYXJlIGRyYWdnZWRcbiAqXG4gKiBAY2xhc3MgVGltZWxpbmVSYW5nZVNlbGVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVJbnB1dENvbHVtbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLypcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUsXG4gICAgICB2YWxpZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmKHRoaXMucHJvcHMuZm9jdXNlZCkge1xuICAgICAgUmVhY3REb20uZmluZERPTU5vZGUodGhpcy5yZWZzWydpbnB1dC0nICsgdGhpcy5wcm9wcy50YWJJbmRleF0pLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgdHlwZTtcbiAgICB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIGlmKHR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgc2l6ZSA9ICc0JztcbiAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ2RheScpIHtcbiAgICAgIHNpemUgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gMztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHByb3BzLnZhbHVlfSk7XG4gIH1cbiAgb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGtjID0gZS5rZXlDb2RlO1xuICAgIGlmKGtjID09PSA5IHx8IC8vIHRhYlxuICAgICAga2MgPT09IDEzKSB7IC8vZW50ZXJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIG9uS2V5VXAoZSkge1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIHZhciBuZXdEYXRlO1xuICAgIHZhciBlbnRlcmVkID0gKGtleUNvZGUgPT0gMTMgfHwga2V5Q29kZSA9PSA5KTtcbiAgICBpZihrZXlDb2RlID09PSAzOCkgeyAvL3VwXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm9uQ2xpY2tVcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZihrZXlDb2RlID09PSA0MCkgey8vIGRvd25cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMub25DbGlja0Rvd24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUudHlwZSA9PSAnZm9jdXNvdXQnIHx8IGVudGVyZWQpIHtcbiAgICAgIGlmKHRoaXMucHJvcHMudHlwZSA9PSAneWVhcicgfHwgdGhpcy5wcm9wcy50eXBlID09ICdkYXknKSB7XG4gICAgICAgIGlmKCEoKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NylcbiAgICAgICAgfHwgZW50ZXJlZFxuICAgICAgICB8fCBrZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2godGhpcy5wcm9wcy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLnllYXJWYWxpZGF0aW9uKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy5kYXlWYWxpZGF0aW9uKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLm1vbnRoVmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZihuZXdEYXRlKSB7XG4gICAgICAgIHRoaXMucHJvcHMudXBkYXRlRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgaWYoZW50ZXJlZCkgeyAvL2lmIGVuZXRlcmVkIG9yIHRhYmJlZFxuICAgICAgICAgIHRoaXMubmV4dFRhYigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoZW50ZXJlZCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2YWxpZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQ2xpY2tVcCgpIHtcbiAgICB0aGlzLnJvbGxEYXRlKDEpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcblxuICB9XG4gIG9uQ2xpY2tEb3duKCkge1xuICAgIHRoaXMucm9sbERhdGUoLTEpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICB5ZWFyVmFsaWRhdGlvbihpbnB1dCkge1xuICAgIHZhciBuZXdEYXRlO1xuICAgIGlmKChpbnB1dCA+IDEwMDApICYmIChpbnB1dCA8IDk5OTkpKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ0Z1bGxZZWFyKGlucHV0KSk7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgfVxuICB9XG4gIGRheVZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICB2YXIgbWF4RGF0ZTtcbiAgICB2YXIgY3VycmVudERhdGUgPSB0aGlzLnByb3BzLmRhdGU7XG5cbiAgICBtYXhEYXRlID0gbmV3IERhdGUoY3VycmVudERhdGUuZ2V0WWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXG4gICAgaWYoaW5wdXQgPiAwICYmIGlucHV0IDw9IG1heERhdGUpIHtcbiAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSgobmV3IERhdGUoY3VycmVudERhdGUpKS5zZXRVVENEYXRlKGlucHV0KSk7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgfVxuXG4gIH1cbiAgcm9sbERhdGUoYW10KSB7XG4gICAgdmFyIG5ld0RhdGUgPSB1dGlsLnJvbGxEYXRlKFxuICAgICAgdGhpcy5wcm9wcy5kYXRlLFxuICAgICAgdGhpcy5wcm9wcy50eXBlLFxuICAgICAgYW10LFxuICAgICAgdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgdGhpcy5wcm9wcy5tYXhEYXRlXG4gICAgKTtcbiAgICB0aGlzLnByb3BzLnVwZGF0ZURhdGUobmV3RGF0ZSk7XG4gIH1cblxuICBtb250aFZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICBpZiAoKCFpc05hTihpbnB1dCkpICYmIGlucHV0IDwgMTMgJiYgaW5wdXQgPiAwKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ01vbnRoKGlucHV0IC0gMSkpO1xuICAgICAgaWYobmV3RGF0ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2YWx1ZTogdXRpbC5tb250aFN0cmluZ0FycmF5W2lucHV0LTFdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZWFsTW9udGg7XG4gICAgICByZWFsTW9udGggPSB1dGlsLnN0cmluZ0luQXJyYXkodXRpbC5tb250aFN0cmluZ0FycmF5LCBpbnB1dCk7XG4gICAgICBpZihyZWFsTW9udGggIT09IGZhbHNlKSB7XG4gICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSgobmV3IERhdGUodGhpcy5wcm9wcy5kYXRlKSkuc2V0VVRDTW9udGgocmVhbE1vbnRoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRGF0ZShuZXdEYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMucHJvcHMuYmx1cigpO1xuICB9XG4gIG9uQ2hhbmdlKGUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiBlLnRhcmdldC52YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbiAgbmV4dFRhYigpIHtcbiAgICB0aGlzLnByb3BzLm5leHRUYWIodGhpcy5wcm9wcy50YWJJbmRleCk7XG4gIH1cbiAgdmFsaWRhdGVEYXRlKGRhdGUpIHtcbiAgICBpZihkYXRlID4gdGhpcy5wcm9wcy5taW5EYXRlICYmIGRhdGUgPD0gdGhpcy5wcm9wcy5tYXhEYXRlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtd3JhcHBlclwiIHN0eWxlPXsodGhpcy5zdGF0ZS52YWxpZCkgPyB7fSA6IHtib3JkZXJDb2xvcjogJyNmZjAwMDAnfX0gPlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub25DbGlja1VwLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cImRhdGUtYXJyb3dzIGRhdGUtYXJyb3ctdXBcIiBkYXRhLWludGVydmFsPXt0aGlzLnByb3BzLnR5cGV9PlxuICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiOFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTSAxMi41LDAgMjUsOCAwLDggelwiIGNsYXNzTmFtZT1cInVwYXJyb3dcIj5cbiAgICAgICAgICAgICAgPC9wYXRoPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgcmVmPXsnaW5wdXQtJyArIHRoaXMucHJvcHMudGFiSW5kZXh9XG4gICAgICAgICAgc2l6ZT17dGhpcy5zaXplfVxuICAgICAgICAgIG1heExlbmd0aD17dGhpcy5zaXplfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImJ1dHRvbi1pbnB1dC1ncm91cFwiXG4gICAgICAgICAgaWQ9e3RoaXMucHJvcHMudHlwZSArICctaW5wdXQtZ3JvdXAnfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuICAgICAgICAgIG9uS2V5VXA9e3RoaXMub25LZXlVcC5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5vbktleVByZXNzLmJpbmQodGhpcyl9IC8vY3VycmVudGx5IG5vdCB3b3JraW5nXG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICBzdHlsZT17e2ZvbnRTaXplOiAoKHRoaXMucHJvcHMuaGVpZ2h0IC8gMikgKyAncHgnKX19XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tEb3duLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cImRhdGUtYXJyb3dzIGRhdGUtYXJyb3ctZG93blwiIGRhdGEtaW50ZXJ2YWw9e3RoaXMucHJvcHMudHlwZX0+XG4gICAgICAgICAgPHN2ZyB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiOFwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0gMTIuNSwwIDI1LDggMCw4IHpcIiBjbGFzc05hbWU9XCJkb3duYXJyb3dcIj48L3BhdGg+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBEYXRlSW5wdXRDb2x1bW4gZnJvbSAnLi93di5kYXRlc2VsZWN0b3IuaW5wdXQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWwvd3YudXRpbHMnO1xuXG5jb25zdCB1dGlsID0gbmV3IFV0aWxzKCk7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBkYXRlU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBtYXhEYXRlOiBwcm9wcy5tYXhEYXRlLFxuICAgICAgbWluRGF0ZTogcHJvcHMubWluRGF0ZSxcbiAgICAgIHRhYjogbnVsbFxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgIG1heERhdGU6IHByb3BzLm1heERhdGUsXG4gICAgICBtaW5EYXRlOiBwcm9wcy5taW5EYXRlLFxuICAgIH0pO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dGFiOiBudWxsfSk7XG4gIH1cbiAgbmV4dFRhYihpbmRleCkge1xuICAgIHZhciBuZXh0VGFiO1xuICAgIGlmKGluZGV4IDwgMykge1xuICAgICAgbmV4dFRhYiA9IGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRhYiA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdGFiOiBuZXh0VGFiXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlRGF0ZShkYXRlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkYXRlOiBkYXRlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkRhdGVDaGFuZ2UodGhpcy5wcm9wcy5pZCwgZGF0ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInd2LWRhdGUtc2VsZWN0b3Itd2lkZ2V0XCI+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW4gc3RhcnREYXRlPXtuZXcgRGF0ZSgyMDAwKX1cbiAgICAgICAgICB0b2RheT17bmV3IERhdGUoKX1cbiAgICAgICAgICBkYXRlPXt0aGlzLnN0YXRlLmRhdGV9XG4gICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZGF0ZS5nZXRVVENGdWxsWWVhcigpfVxuICAgICAgICAgIHR5cGU9XCJ5ZWFyXCJcbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLndpZHRofVxuICAgICAgICAgIHVwZGF0ZURhdGU9e3RoaXMudXBkYXRlRGF0ZS5iaW5kKHRoaXMpfVxuICAgICAgICAgIHRhYkluZGV4PXsxfVxuICAgICAgICAgIGZvY3VzZWQ9eyh0aGlzLnN0YXRlLnRhYiA9PSAxKX1cbiAgICAgICAgICBuZXh0VGFiPXt0aGlzLm5leHRUYWIuYmluZCh0aGlzKX1cbiAgICAgICAgICBtYXhEYXRlPXt0aGlzLnByb3BzLm1heERhdGV9XG4gICAgICAgICAgbWluRGF0ZT17dGhpcy5wcm9wcy5taW5EYXRlfVxuICAgICAgICAgIGJsdXI9e3RoaXMuYmx1ci5iaW5kKHRoaXMpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW5cbiAgICAgICAgICBzdGFydERhdGU9e25ldyBEYXRlKDIwMDApfVxuICAgICAgICAgIHRvZGF5PXtuZXcgRGF0ZSgpfSBkYXRlPXt0aGlzLnN0YXRlLmRhdGV9XG4gICAgICAgICAgdHlwZT1cIm1vbnRoXCIgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy53aWR0aH1cbiAgICAgICAgICB1cGRhdGVEYXRlPXt0aGlzLnVwZGF0ZURhdGUuYmluZCh0aGlzKX1cbiAgICAgICAgICB2YWx1ZT17dXRpbC5tb250aFN0cmluZ0FycmF5W3RoaXMuc3RhdGUuZGF0ZS5nZXRVVENNb250aCgpXX1cbiAgICAgICAgICB0YWJJbmRleD17Mn1cbiAgICAgICAgICBmb2N1c2VkPXsodGhpcy5zdGF0ZS50YWIgPT0gMil9XG4gICAgICAgICAgbmV4dFRhYj17dGhpcy5uZXh0VGFiLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgIG1pbkRhdGU9e3RoaXMucHJvcHMubWluRGF0ZX1cbiAgICAgICAgICBibHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgLz5cbiAgICAgICAgPERhdGVJbnB1dENvbHVtblxuICAgICAgICAgIHN0YXJ0RGF0ZT17bmV3IERhdGUoMjAwMCl9XG4gICAgICAgICAgdG9kYXk9e25ldyBEYXRlKCl9XG4gICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHR5cGU9XCJkYXlcIlxuICAgICAgICAgIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgdXBkYXRlRGF0ZT17dGhpcy51cGRhdGVEYXRlLmJpbmQodGhpcyl9XG4gICAgICAgICAgdmFsdWU9e3V0aWwucGFkKHRoaXMuc3RhdGUuZGF0ZS5nZXRVVENEYXRlKCksIDIsICcwJyl9XG4gICAgICAgICAgdGFiSW5kZXg9ezN9XG4gICAgICAgICAgZm9jdXNlZD17KHRoaXMuc3RhdGUudGFiID09IDMpfVxuICAgICAgICAgIG5leHRUYWI9e3RoaXMubmV4dFRhYi5iaW5kKHRoaXMpfVxuICAgICAgICAgIG1heERhdGU9e3RoaXMucHJvcHMubWF4RGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgYmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ3JlYWN0LWRyYWdnYWJsZSc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cFxuICpcbiAqIEBjbGFzcyBUaW1lbGluZURyYWdnZXJcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZURyYWdnZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgY2hlY2tWaXNpYmlsaXR5KCkge1xuICAgIHZhciB2aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGlmKHRoaXMucHJvcHMucG9zaXRpb24gPCAwIHx8IHRoaXMucHJvcHMucG9zaXRpb24gPiB0aGlzLnByb3BzLm1heCkge1xuICAgICAgdmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eVxuICAgIH07XG4gIH1cbiAgLypcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gcGFzc2VzIHRoZSBpZFxuICAgKiBhbmQgY2hhbmdlLWluLXggb2YgdGhlIGRyYWdcbiAgICogdG8gb25EcmFnIGNhbGxiYWNrXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRHJhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgaGFuZGxlRHJhZyhlLCBkKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLnByb3BzLm9uRHJhZyhkLmRlbHRhWCwgdGhpcy5wcm9wcy5pZCk7XG4gIH1cblxuICAvKlxuICAgKiBAbWV0aG9kIHJlbmRlclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY2hlY2tWaXNpYmlsaXR5KCk7XG4gICAgcmV0dXJuKFxuICAgICAgPERyYWdnYWJsZVxuICAgICAgICBvbkRyYWc9e3RoaXMuaGFuZGxlRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICBwb3NpdGlvbj17e3g6dGhpcy5wcm9wcy5wb3NpdGlvbiwgeTowfX1cbiAgICAgICAgb25TdG9wPXt0aGlzLnByb3BzLm9uU3RvcH1cbiAgICAgICAgYXhpcz1cInhcIlxuICAgICAgPlxuICAgICAgICA8Zz5cbiAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZmlsbDp0aGlzLnByb3BzLmNvbG9yLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLnN0YXRlLnZpc2liaWxpdHlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIHRoaXMgcG9seWdvbiBlbGVtZW50IGJ1aWxkcyBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAqIGJhc2VkIG9uIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZVxuICAgICAgICAgICAgKiByZWN0YW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICB9XG4gICAgICAgICAgPHBvbHlnb25cbiAgICAgICAgICAgIHBvaW50cz17JzAsMCwnICsgdGhpcy5wcm9wcy5oZWlnaHQgLyAxLjUgKyAnLDAgJyArIHRoaXMucHJvcHMuaGVpZ2h0IC8gMyArICcsICcgK3RoaXMucHJvcHMuaGVpZ2h0IC8gMS41IH1cbiAgICAgICAgICAgIHRyYW5zZm9ybT17J3RyYW5zbGF0ZSgnICsgKC0odGhpcy5wcm9wcy53aWR0aCAqIDIuNDUpKSArICcsICcgKyAoLSh0aGlzLnByb3BzLmhlaWdodCAvIDIpKSArJyknfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZmlsbDogdGhpcy5wcm9wcy50cmlhbmdsZUNvbG9yLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLnN0YXRlLnZpc2liaWxpdHksXG4gICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L0RyYWdnYWJsZT5cbiAgICApO1xuICB9XG59XG5UaW1lbGluZURyYWdnZXIuZGVmYXVsdFByb3BzID0ge1xuICB2aXNpYmxlOiB0cnVlXG59OyIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiByZWN0IGVsZW1lbnRcbiAqXG4gKiBAY2xhc3MgVGltZWxpbmVEcmFnZ2VyUmFuZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmVEcmFnZ2VyUmFuZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5vcGFjaXR5ID0ge1xuICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcHMub3BhY2l0eVxuICAgIH07XG4gIH1cbiAgY2hlY2tXaWR0aCgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnByb3BzLnN0YXJ0TG9jYXRpb247XG4gICAgdmFyIGVuZCA9IHRoaXMucHJvcHMuZW5kTG9jYXRpb247XG4gICAgdmFyIG1heCA9IHRoaXMucHJvcHMubWF4O1xuICAgIHZhciB3aWR0aDtcblxuICAgIGlmKHN0YXJ0IDwgMCl7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmKGVuZCA+IG1heCl7XG4gICAgICBlbmQgPSBtYXg7XG4gICAgfVxuICAgIHdpZHRoID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYod2lkdGggPCAwKSB7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBzdGFydExvY2F0aW9uOiBzdGFydFxuICAgIH07XG4gIH1cbiAgLypcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gcGFzc2VzIHRoZSBpZFxuICAgKiBhbmQgY2hhbmdlIGluIHggb2YgdGhlIGRyYWdcbiAgICogdG8gb25EcmFnIHByb3BlcnR5XG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRHJhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgaGFuZGxlRHJhZyhlLCBkKXtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMucHJvcHMub25EcmFnKGQuZGVsdGFYKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBtZXRob2QgcmVuZGVyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jaGVja1dpZHRoKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxyZWN0XG4gICAgICAgIHg9e3RoaXMuc3RhdGUuc3RhcnRMb2NhdGlvbn1cbiAgICAgICAgZmlsbD17dGhpcy5wcm9wcy5jb2xvcn1cbiAgICAgICAgd2lkdGg9e3RoaXMuc3RhdGUud2lkdGh9XG4gICAgICAgIHN0eWxlPXt0aGlzLm9wYWNpdHl9XG4gICAgICAgIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgIGNsYXNzTmFtZT0nZHJhZ2dlci1yYW5nZSdcbiAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dlciBmcm9tICcuL3d2LnRpbWVsaW5lLmRyYWdnZXIuanMnO1xuaW1wb3J0IERyYWdnZXJSYW5nZSBmcm9tICcuL3d2LnRpbWVsaW5lLmRyYWdnZXJyYW5nZS5qcyc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZVJhbmdlU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9ICB7XG4gICAgICBzdGFydExvY2F0aW9uOiBwcm9wcy5zdGFydExvY2F0aW9uLFxuICAgICAgZW5kTG9jYXRpb246IHByb3BzLmVuZExvY2F0aW9uLFxuICAgICAgbWF4OiBwcm9wcy5tYXgsXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydExvY2F0aW9uOiBwcm9wcy5zdGFydExvY2F0aW9uLFxuICAgICAgZW5kTG9jYXRpb246IHByb3BzLmVuZExvY2F0aW9uLFxuICAgICAgbWF4OiBwcm9wcy5tYXhcbiAgICB9KTtcbiAgfVxuICAvKlxuICAgKiBXaGVuIGEgY2hpbGQgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGRldGVybWluZVxuICAgKiB0aGUgY29ycmVjdCBsb2NhdGlvbiBmb3IgZWFjaCBvZiB0aGVcbiAgICogY2hpbGQgZWxlbWVudHMgYWZ0ZXIgdGhlIGRyYWdcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVEcmFnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggLSBjaGFuZ2UgaW4geFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBJZGVudGlmaWVyIHVzZWQgdG9cbiAgICogIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGNoaWxkIGVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBvbkl0ZW1EcmFnKGRlbHRhWCwgaWQpIHtcbiAgICB2YXIgc3RhcnRYO1xuICAgIHZhciBlbmRYO1xuXG4gICAgaWYoaWQgPT09ICdzdGFydCcpIHtcbiAgICAgIHN0YXJ0WCA9IGRlbHRhWCArIHRoaXMuc3RhdGUuc3RhcnRMb2NhdGlvbjtcbiAgICAgIGVuZFggPSB0aGlzLnN0YXRlLmVuZExvY2F0aW9uO1xuICAgICAgaWYoc3RhcnRYIDwgMCB8fCBzdGFydFggPiBlbmRYKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHN0YXJ0WCArICgyICogdGhpcy5wcm9wcy5waW5XaWR0aCkgPj0gZW5kWCkge1xuICAgICAgICBlbmRYID0gc3RhcnRYICsgdGhpcy5wcm9wcy5waW5XaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoaWQgPT09ICdlbmQnKSB7XG4gICAgICBzdGFydFggPSB0aGlzLnN0YXRlLnN0YXJ0TG9jYXRpb247XG4gICAgICBlbmRYID0gZGVsdGFYICsgdGhpcy5zdGF0ZS5lbmRMb2NhdGlvbjtcbiAgICAgIGlmKGVuZFggPiB0aGlzLnN0YXRlLm1heCB8fCBzdGFydFggPiBlbmRYKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHN0YXJ0WCArICgyICogdGhpcy5wcm9wcy5waW5XaWR0aCkgPj0gZW5kWCkge1xuICAgICAgICBzdGFydFggPSBlbmRYIC0gdGhpcy5wcm9wcy5waW5XaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRYID0gZGVsdGFYICsgdGhpcy5zdGF0ZS5zdGFydExvY2F0aW9uIDtcbiAgICAgIGVuZFggPSBkZWx0YVggKyB0aGlzLnN0YXRlLmVuZExvY2F0aW9uO1xuICAgICAgaWYoZW5kWCA+PSB0aGlzLnN0YXRlLm1heCB8fCBzdGFydFggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkRyYWcoc3RhcnRYLCBlbmRYKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RhcnRMb2NhdGlvbjogc3RhcnRYLFxuICAgICAgZW5kTG9jYXRpb246IGVuZFhcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIFNlbmQgY2FsbGJhY2sgd2l0aCBuZXcgbG9jYXRpb25zIG9uXG4gICAqIERyYWcgU3RvcFxuICAgKlxuICAgKiBAbWV0aG9kIG9uRHJhZ1N0b3BcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIG9uRHJhZ1N0b3AoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkRyYWcodGhpcy5zdGF0ZS5zdGFydExvY2F0aW9uLCB0aGlzLnN0YXRlLmVuZExvY2F0aW9uKTtcbiAgfVxuICBvblJhbmdlQ2xpY2soZCkge1xuICAgIHRoaXMucHJvcHMub25SYW5nZUNsaWNrKGQubmF0aXZlRXZlbnQpO1xuICB9XG4gIC8qXG4gICAqIEBtZXRob2QgcmVuZGVyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuKFxuICAgICAgPHN2ZyBpZD1cInd2LXRpbWVsaW5lLXJhbmdlLXNlbGVjdG9yXCIgY2xhc3NOYW1lPVwid3YtdGltZWxpbmUtcmFuZ2Utc2VsZWN0b3JcIj5cbiAgICAgICAgPERyYWdnZXJSYW5nZVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLnBpbldpZHRofVxuICAgICAgICAgIGVuZExvY2F0aW9uPXt0aGlzLnN0YXRlLmVuZExvY2F0aW9ufVxuICAgICAgICAgIG9wYWNpdHk9e3RoaXMucHJvcHMucmFuZ2VPcGFjaXR5fVxuICAgICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnJhbmdlQ29sb3J9XG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICBzdGFydExvY2F0aW9uPXt0aGlzLnN0YXRlLnN0YXJ0TG9jYXRpb24gKyB0aGlzLnByb3BzLnBpbldpZHRofVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25SYW5nZUNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICBpZD0ncmFuZ2UnLz5cbiAgICAgICAgPERyYWdnZXJcbiAgICAgICAgICBwb3NpdGlvbj17dGhpcy5zdGF0ZS5zdGFydExvY2F0aW9ufVxuICAgICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnN0YXJ0Q29sb3J9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMucGluV2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMub25JdGVtRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5vbkRyYWdTdG9wLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICB0cmlhbmdsZUNvbG9yPXt0aGlzLnByb3BzLnN0YXJ0VHJpYW5nbGVDb2xvcn1cbiAgICAgICAgICBmaXJzdD17dHJ1ZX1cbiAgICAgICAgICBpZD0nc3RhcnQnIC8+XG4gICAgICAgIDxEcmFnZ2VyXG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICBwb3NpdGlvbj17dGhpcy5zdGF0ZS5lbmRMb2NhdGlvbn1cbiAgICAgICAgICBjb2xvcj17dGhpcy5wcm9wcy5lbmRDb2xvcn1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy5waW5XaWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIGZpcnN0PXtmYWxzZX1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMub25JdGVtRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5vbkRyYWdTdG9wLmJpbmQodGhpcyl9XG4gICAgICAgICAgdHJpYW5nbGVDb2xvcj17dGhpcy5wcm9wcy5lbmRUcmlhbmdsZUNvbG9yfVxuICAgICAgICAgIGlkPSdlbmQnLz5cbiAgICAgIDwvc3ZnPlxuICAgICk7XG4gIH1cblxufSIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBCdWlsZHMgYSByYXRoZXIgc3BlY2lmaWNcbiAqIGludGVyYWN0aXZlIHdpZGdldFxuICpcbiAqIEBjbGFzcyBBbmltYXRpb25XaWRnZXRcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sdGlwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhvdmVyZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBtb3VzZU92ZXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbW91c2VPdXQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIG9uQ2xpY2soc3RyKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKHN0cik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgIDxkaXZcbiAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5tb3VzZU92ZXIuYmluZCh0aGlzKX1cbiAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5tb3VzZU91dC5iaW5kKHRoaXMpfVxuICAgICAgY2xhc3NOYW1lPVwid3YtdG9vbHRpcC1jYXNlXCI+XG4gICAgICAgIDxzcGFuPnt0aGlzLnByb3BzLnRleHR9PC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInd2LXRvb2x0aXBcIiBzdHlsZT17KHRoaXMuc3RhdGUuaG92ZXJlZCkgPyB7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSA6IHt9fSA+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuZGF0YUFycmF5Lm1hcCgoZGF0YUVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiA8bGkga2V5PXsndG9vbHRpcC0nK2RhdGFFbCArICctJyArIGl9IGlkPXtkYXRhRWx9IG9uQ2xpY2s9e3RoaXMub25DbGljay5iaW5kKHRoaXMsIGRhdGFFbCl9PntkYXRhRWx9PC9saT47XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIGdhOnRydWUgKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBHQSB0cmFja2luZyBpZiB0cmFja2luZ1xuICAgKiBjb2RlIGlzIHByZXNlbnRcbiAgICpcbiAgICogQGZ1bmMgaW5pdFxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBwYXJhbSBDYXRlZ29yeSB7aWR9IEdBIHRyYWNraW5nIGNvZGVcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGluaXQoaWQpIHtcbiAgICBpZihpZCkge1xuICAgICAgKGZ1bmN0aW9uKGksIHMsIG8sIGcsIHIsIGEsIG0pIHtcbiAgICAgICAgaVsnR29vZ2xlQW5hbHl0aWNzT2JqZWN0J109cjtcbiAgICAgICAgaVtyXT1pW3JdfHxmdW5jdGlvbigpIHtcbiAgICAgICAgICAoaVtyXS5xPWlbcl0ucXx8W10pLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaVtyXS5sPTEqbmV3IERhdGUoKTtcbiAgICAgICAgYT1zLmNyZWF0ZUVsZW1lbnQobyksXG4gICAgICAgIG09cy5nZXRFbGVtZW50c0J5VGFnTmFtZShvKVswXTtcbiAgICAgICAgYS5hc3luYz0xO1xuICAgICAgICBhLnNyYz1nO1xuICAgICAgICBtLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsIG0pO1xuICAgICAgfSkod2luZG93LCBkb2N1bWVudCwgJ3NjcmlwdCcsICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCAnZ2EnKTtcbiAgICAgIGdhKCdjcmVhdGUnLCBpZCwgJ2F1dG8nKTtcbiAgICAgIGdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XG4gICAgfVxuICB9LFxuXHQvKipcblx0ICogQGZ1bmMgVHJhY2tFdmVudEdBXG5cdCAqIEBzdGF0aWNcblx0ICpcblx0ICogQHBhcmFtIENhdGVnb3J5IHtzdHJpbmd9IEV2ZW50IGdyb3VwIG5hbWVcblx0ICogQHBhcmFtIEFjdGlvbiB7c3RyaW5nfSBUeXBlIG9mIHVzZXIgaW50ZXJhY3Rpb25cblx0ICogQHBhcmFtIExhYmVsIHtzdHJpbmd9IE9wdGlvbmFsIHN0cmluZyBmb3IgYmV0dGVyXG5cdCAqICAgICB2ZXJpZmljYXRpb24gb2YgdGhlIGV2ZW50XG5cdCAqIEBwYXJhbSBWYWx1ZSB7bnVtYmVyfSBPcHRpb25hbCBudW1iZXIgdG8gYXNzb2NpYXRlXG5cdCAqICAgICB3aXRoIGV2ZW50XG5cdCAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG5cdCAqL1xuICBldmVudChjYXRlZ29yeSwgYWN0aW9uLCBsYWJlbCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIChnYSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgY2F0ZWdvcnksIGFjdGlvbiwgbGFiZWwsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbiIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbHMge1xuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9udGhTdHJpbmdBcnJheT0gWyBcIkpBTlwiLCBcIkZFQlwiLCBcIk1BUlwiLCBcIkFQUlwiLCBcIk1BWVwiLCBcIkpVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkpVTFwiLCBcIkFVR1wiLCBcIlNFUFwiLCBcIk9DVFwiLCBcIk5PVlwiLCBcIkRFQ1wiIF07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgZGF5LiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHRoZSBEYXRlIG1ldGhvZHMgdG8gYWxsb3dcbiAgICogZGVidWdnaW5nIGFsdGVybmF0ZSBcIm5vd1wiIHRpbWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIHRvZGF5XG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RGF0ZX0gVGhlIGN1cnJlbnQgdGltZSB3aXRoIHRoZSBVVEMgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzXG4gICAqIGZpZWxkcyBzZXQgdG8gemVybyBvciBhbiBvdmVycmlkZW4gdmFsdWUuXG4gICAqL1xuICB0b2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhclRpbWVVVEModGhpcy5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGRhdGUgdG8gVVRDIG1pZG5pZ2h0LlxuICAgKlxuICAgKiBAbWV0aG9kIGNsZWFyVGltZVVUQ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSBkYXRlIHtEYXRlfSBkYXRlIHRvIHNldCB0aGUgVVRDIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kc1xuICAgKiB0byB6ZXJvLlxuICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZSBvYmplY3RcbiAgICovXG4gIGNsZWFyVGltZVVUQyhkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwKTtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCk7XG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKDApO1xuICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsIDwgbWluKSB7IHJldHVybiBtaW47IH1cbiAgICBpZiAodmFsID4gbWF4KSB7IHJldHVybiBtYXg7IH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGRheXNJbk1vbnRoKGQpIHtcbiAgICB2YXIgeTtcbiAgICB2YXIgbTtcbiAgICBpZihkLmdldFVUQ0Z1bGxZZWFyKSB7XG4gICAgICB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgbSA9IGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IGQueWVhcjtcbiAgICAgIG0gPSBkLm1vbnRoO1xuICAgIH1cbiAgICB2YXIgbGFzdERheSA9IG5ldyBEYXRlKERhdGUuVVRDKHksIG0gKyAxLCAwKSk7XG4gICAgcmV0dXJuIGxhc3REYXkuZ2V0VVRDRGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUuIFVzZSB0aGlzIGluc3RlYWQgb2YgdGhlIERhdGUgbWV0aG9kcyB0byBhbGxvd1xuICAgKiBkZWJ1Z2dpbmcgYWx0ZXJuYXRlIFwibm93XCIgdGltZXMuXG4gICAqXG4gICAqIEBtZXRob2Qgbm93XG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RGF0ZX0gVGhlIGN1cnJlbnQgdGltZSBvciBhbiBvdmVycmlkZW4gdmFsdWUuXG4gICAqL1xuICBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgc3RyaW5nSW5BcnJheShhcnJhLCB2YWx1ZSkge1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFycmEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmKGFycmFbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWluRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTAwMCwgMCwgMSkpO1xuICB9XG5cbiAgbWF4RGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMzAwMCwgMTEsIDMxKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFVUQyBJU08gODYwMSBkYXRlLlxuICAgKlxuICAgKiBAbWV0aG9kIHBhcnNlRGF0ZVVUQ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSBzdHIge3N0cmluZ30gRGF0ZSB0byBwYXJzZSBpbiB0aGUgZm9ybSBvZiBgYFlZWVktTU0tRERgYC5cbiAgICogQHJldHVybiB7RGF0ZX0gY29udmVydGVkIHN0cmluZyBhcyBhIGRhdGUgb2JqZWN0LCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmXG4gICAqIHRoZSBzdHJpbmcgaXMgaW52YWxpZFxuICAgKi9cbiAgICAvLyBOT1RFOiBPbGRlciBTYWZhcmkgZG9lc24ndCBsaWtlIERhdGUucGFyc2VcbiAgcGFyc2VEYXRlVVRDKGRhdGVBc1N0cmluZykge1xuICAgIHZhciBkYXRlVGltZUFyciA9IGRhdGVBc1N0cmluZy5zcGxpdCgvVC8pO1xuICAgIHZhciB5eXl5bW1kZCA9IGRhdGVUaW1lQXJyWzBdLnNwbGl0KCctJyk7XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50cyBvZiBkYXRlIGFuZCB0aW1lXG4gICAgdmFyIHllYXIgPSB5eXl5bW1kZFswXTtcbiAgICB2YXIgbW9udGggPSB5eXl5bW1kZFsxXSAtIDE7XG4gICAgdmFyIGRheSA9IHl5eXltbWRkWzJdO1xuXG4gICAgdmFyIGhvdXIgPSAwO1xuICAgIHZhciBtaW51dGUgPSAwO1xuICAgIHZhciBzZWNvbmQgPSAwO1xuICAgIHZhciBtaWxsaXNlY29uZCA9IDA7XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBvZiBtaWRuaWdodCBpZiB0aW1lIGlzIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAoZGF0ZVRpbWVBcnIubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGhobW1zcyA9IGRhdGVUaW1lQXJyWzFdLnNwbGl0KC9bOlxcLlpdLyk7XG4gICAgICBob3VyID0gaGhtbXNzWzBdIHx8IDA7XG4gICAgICBtaW51dGUgPSBoaG1tc3NbMV0gfHwgMDtcbiAgICAgIHNlY29uZCA9IGhobW1zc1syXSB8fCAwO1xuICAgICAgbWlsbGlzZWNvbmQgPSBoaG1tc3NbM10gfHwgMDtcbiAgICB9XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKTtcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0ZTogJyArIGRhdGVBc1N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJlcGVhdCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcm9sbCh2YWwsIG1pbiwgbWF4KSB7XG4gICAgaWYodmFsIDwgbWluKSB7cmV0dXJuIG1heCAtIChtaW4gLSB2YWwpICsgMTt9XG4gICAgaWYodmFsID4gbWF4KSB7cmV0dXJuIG1pbiArICh2YWwgLSBtYXgpIC0gMTt9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByb2xsUmFuZ2UoZGF0ZSwgaW50ZXJ2YWwsIG1pbkRhdGUsIG1heERhdGUpIHtcbiAgICB2YXIgeSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB2YXIgbSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICB2YXIgZmlyc3QsIGxhc3Q7XG4gICAgc3dpdGNoIChpbnRlcnZhbCkge1xuICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICB2YXIgZmlyc3REYXkgPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCBtLCAxKSk7XG4gICAgICAgIHZhciBsYXN0RGF5ID0gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgdGhpcy5kYXlzSW5Nb250aChkYXRlKSkpO1xuICAgICAgICBmaXJzdCA9IG5ldyBEYXRlKE1hdGgubWF4KGZpcnN0RGF5LCBtaW5EYXRlKSkuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICBsYXN0ID0gbmV3IERhdGUoTWF0aC5taW4obGFzdERheSwgbWF4RGF0ZSkpLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgdmFyIGZpcnN0TW9udGggPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCAwLCAxKSk7XG4gICAgICAgIHZhciBsYXN0TW9udGggPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCAxMSwgMzEpKTtcbiAgICAgICAgZmlyc3QgPSBuZXcgRGF0ZShNYXRoLm1heChmaXJzdE1vbnRoLCBtaW5EYXRlKSkuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgbGFzdCA9IG5ldyBEYXRlKE1hdGgubWluKGxhc3RNb250aCwgbWF4RGF0ZSkpLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgdmFyIGZpcnN0WWVhciA9IHRoaXMubWluRGF0ZSgpO1xuICAgICAgICB2YXIgbGFzdFllYXIgPSB0aGlzLm1heERhdGUoKTtcbiAgICAgICAgZmlyc3QgPSBuZXcgRGF0ZShNYXRoLm1heChmaXJzdFllYXIsIG1pbkRhdGUpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBsYXN0ID0gbmV3IERhdGUoTWF0aC5taW4obGFzdFllYXIsIG1heERhdGUpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBsYXN0IH07XG4gIH1cbiAgcm9sbERhdGUoZGF0ZSwgaW50ZXJ2YWwsIGFtb3VudCwgbWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIG1pbkRhdGUgPSBtaW5EYXRlIHx8IHRoaXMubWluRGF0ZSgpO1xuICAgIG1heERhdGUgPSBtYXhEYXRlIHx8IHRoaXMubWF4RGF0ZSgpO1xuICAgIHZhciByYW5nZSA9IHRoaXMucm9sbFJhbmdlKGRhdGUsIGludGVydmFsLCBtaW5EYXRlLCBtYXhEYXRlKTtcbiAgICB2YXIgbWluID0gcmFuZ2UuZmlyc3Q7XG4gICAgdmFyIG1heCA9IHJhbmdlLmxhc3Q7XG4gICAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICBzd2l0Y2ggKGludGVydmFsKSB7XG4gICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgIGRheSA9IHRoaXMucm9sbChkYXkgKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgbW9udGggPSB0aGlzLnJvbGwobW9udGggKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICB5ZWFyID0gdGhpcy5yb2xsKHllYXIgKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbcm9sbERhdGVdIEludmFsaWQgaW50ZXJ2YWw6IFwiICsgaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB2YXIgZGF5c0luTW9udGggPSB0aGlzLmRheXNJbk1vbnRoKHt5ZWFyOiB5ZWFyLCBtb250aDogbW9udGh9KTtcbiAgICBpZihkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgZGF5ID0gZGF5c0luTW9udGg7XG4gICAgfVxuICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmNsYW1wKG5ld0RhdGUsIG1pbkRhdGUsIG1heERhdGUpKTtcbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuICBwYWQodmFsdWUsIHdpZHRoLCBwYWRkaW5nKSB7XG4gICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgaWYodmFsdWUubGVuZ3RoIDwgd2lkdGgpIHtcbiAgICAgIHZhciBhZGQgPSB3aWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgICAgIHZhbHVlID0gdGhpcy5yZXBlYXQocGFkZGluZywgYWRkKSArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE0IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIEFuaW1hdGlvbldpZGdldH0gZnJvbSAnLi9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5hbmltYXRpb24ud2lkZ2V0LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSYW5nZVNlbGVjdG9yfSBmcm9tICcuL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUucmFuZ2VzZWxlY3Rpb24uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERhdGVTZWxlY3Rvcn0gZnJvbSAnLi9jb21wb25lbnRzL2RhdGVTZWxlY3Rvci93di5kYXRlU2VsZWN0b3IuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRvb2xUaXB9IGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwL3d2LnRvb2x0aXAuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFV0aWxzfSBmcm9tICcuL2NvbXBvbmVudHMvdXRpbC93di51dGlscy5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgR0F9IGZyb20gJy4vY29tcG9uZW50cy91dGlsL3d2Lmdvb2dsZUFuYWx5dGljcy5qcyc7XG4iXX0=