(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WVC = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null), (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDraggable"] = factory((typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null), (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null));
	else
		root["ReactDraggable"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(1).default;
	module.exports.DraggableCore = __webpack_require__(9).default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _classnames = __webpack_require__(4);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _domFns = __webpack_require__(5);
	
	var _positionFns = __webpack_require__(8);
	
	var _shims = __webpack_require__(6);
	
	var _DraggableCore = __webpack_require__(9);
	
	var _DraggableCore2 = _interopRequireDefault(_DraggableCore);
	
	var _log = __webpack_require__(11);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	// $FlowIgnore
	
	
	/*:: import type {DraggableEventHandler} from './utils/types';*/
	/*:: type DraggableState = {
	  dragging: boolean,
	  dragged: boolean,
	  x: number, y: number,
	  slackX: number, slackY: number,
	  isElementSVG: boolean
	};*/
	
	
	//
	// Define <Draggable>
	//
	
	/*:: type ConstructorProps = {
	  position: { x: number, y: number },
	  defaultPosition: { x: number, y: number }
	};*/
	
	var Draggable = function (_React$Component) {
	  _inherits(Draggable, _React$Component);
	
	  function Draggable(props /*: ConstructorProps*/) {
	    _classCallCheck(this, Draggable);
	
	    var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));
	
	    _this.onDragStart = function (e, coreData) {
	      (0, _log2.default)('Draggable: onDragStart: %j', coreData);
	
	      // Short-circuit if user's callback killed it.
	      var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      // Kills start event on core as well, so move handlers are never bound.
	      if (shouldStart === false) return false;
	
	      _this.setState({ dragging: true, dragged: true });
	    };
	
	    _this.onDrag = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	      (0, _log2.default)('Draggable: onDrag: %j', coreData);
	
	      var uiData = (0, _positionFns.createDraggableData)(_this, coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        x: uiData.x,
	        y: uiData.y
	      };
	
	      // Keep within bounds.
	      if (_this.props.bounds) {
	        // Save original x and y.
	        var _x = newState.x,
	            _y = newState.y;
	
	        // Add slack to the values used to calculate bound position. This will ensure that if
	        // we start removing slack, the element won't react to it right away until it's been
	        // completely removed.
	
	        newState.x += _this.state.slackX;
	        newState.y += _this.state.slackY;
	
	        // Get bound position. This will ceil/floor the x and y within the boundaries.
	        // $FlowBug
	
	        // Recalculate slack by noting how much was shaved by the boundPosition handler.
	        var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);
	
	        var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);
	
	        newState.x = _getBoundPosition2[0];
	        newState.y = _getBoundPosition2[1];
	        newState.slackX = _this.state.slackX + (_x - newState.x);
	        newState.slackY = _this.state.slackY + (_y - newState.y);
	
	        // Update the event we fire to reflect what really happened after bounds took effect.
	        uiData.x = _x;
	        uiData.y = _y;
	        uiData.deltaX = newState.x - _this.state.x;
	        uiData.deltaY = newState.y - _this.state.y;
	      }
	
	      // Short-circuit if user's callback killed it.
	      var shouldUpdate = _this.props.onDrag(e, uiData);
	      if (shouldUpdate === false) return false;
	
	      _this.setState(newState);
	    };
	
	    _this.onDragStop = function (e, coreData) {
	      if (!_this.state.dragging) return false;
	
	      // Short-circuit if user's callback killed it.
	      var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
	      if (shouldStop === false) return false;
	
	      (0, _log2.default)('Draggable: onDragStop: %j', coreData);
	
	      var newState /*: $Shape<DraggableState>*/ = {
	        dragging: false,
	        slackX: 0,
	        slackY: 0
	      };
	
	      // If this is a controlled component, the result of this operation will be to
	      // revert back to the old position. We expect a handler on `onDragStop`, at the least.
	      var controlled = Boolean(_this.props.position);
	      if (controlled) {
	        var _this$props$position = _this.props.position,
	            _x2 = _this$props$position.x,
	            _y2 = _this$props$position.y;
	
	        newState.x = _x2;
	        newState.y = _y2;
	      }
	
	      _this.setState(newState);
	    };
	
	    _this.state = {
	      // Whether or not we are currently dragging.
	      dragging: false,
	
	      // Whether or not we have been dragged before.
	      dragged: false,
	
	      // Current transform x and y.
	      x: props.position ? props.position.x : props.defaultPosition.x,
	      y: props.position ? props.position.y : props.defaultPosition.y,
	
	      // Used for compensating for out-of-bounds drags
	      slackX: 0, slackY: 0,
	
	      // Can only determine if SVG after mounting
	      isElementSVG: false
	    };
	    return _this;
	  }
	
	  _createClass(Draggable, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
	        // eslint-disable-next-line
	        console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      // Check to see if the element passed is an instanceof SVGElement
	      if (typeof SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof SVGElement) {
	        this.setState({ isElementSVG: true });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps /*: Object*/) {
	      // Set x/y if position has changed
	      if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
	        this.setState({ x: nextProps.position.x, y: nextProps.position.y });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
	    }
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      var _classNames;
	
	      var style = {},
	          svgTransform = null;
	
	      // If this is controlled, we don't want to move it - unless it's dragging.
	      var controlled = Boolean(this.props.position);
	      var draggable = !controlled || this.state.dragging;
	
	      var position = this.props.position || this.props.defaultPosition;
	      var transformOpts = {
	        // Set left if horizontal drag is enabled
	        x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,
	
	        // Set top if vertical drag is enabled
	        y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
	      };
	
	      // If this element was SVG, we use the `transform` attribute.
	      if (this.state.isElementSVG) {
	        svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
	      } else {
	        // Add a CSS transform to move the element around. This allows us to move the element around
	        // without worrying about whether or not it is relatively or absolutely positioned.
	        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
	        // has a clean slate.
	        style = (0, _domFns.createCSSTransform)(transformOpts);
	      }
	
	      var _props = this.props,
	          defaultClassName = _props.defaultClassName,
	          defaultClassNameDragging = _props.defaultClassNameDragging,
	          defaultClassNameDragged = _props.defaultClassNameDragged;
	
	      // Mark with class while dragging
	
	      var className = (0, _classnames2.default)(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));
	
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.createElement(
	        _DraggableCore2.default,
	        _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
	        _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	          className: className,
	          style: _extends({}, this.props.children.props.style, style),
	          transform: svgTransform
	        })
	      );
	    }
	  }]);
	
	  return Draggable;
	}(_react2.default.Component);
	
	Draggable.displayName = 'Draggable';
	Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {
	
	  /**
	   * `axis` determines which axis the draggable can move.
	   *
	   *  Note that all callbacks will still return data as normal. This only
	   *  controls flushing to the DOM.
	   *
	   * 'both' allows movement horizontally and vertically.
	   * 'x' limits movement to horizontal axis.
	   * 'y' limits movement to vertical axis.
	   * 'none' limits all movement.
	   *
	   * Defaults to 'both'.
	   */
	  axis: _react.PropTypes.oneOf(['both', 'x', 'y', 'none']),
	
	  /**
	   * `bounds` determines the range of movement available to the element.
	   * Available values are:
	   *
	   * 'parent' restricts movement within the Draggable's parent node.
	   *
	   * Alternatively, pass an object with the following properties, all of which are optional:
	   *
	   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
	   *
	   * All values are in px.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable bounds={{right: 300, bottom: 300}}>
	   *              <div>Content</div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  bounds: _react.PropTypes.oneOfType([_react.PropTypes.shape({
	    left: _react.PropTypes.number,
	    right: _react.PropTypes.number,
	    top: _react.PropTypes.number,
	    bottom: _react.PropTypes.number
	  }), _react.PropTypes.string, _react.PropTypes.oneOf([false])]),
	
	  defaultClassName: _react.PropTypes.string,
	  defaultClassNameDragging: _react.PropTypes.string,
	  defaultClassNameDragged: _react.PropTypes.string,
	
	  /**
	   * `defaultPosition` specifies the x and y that the dragged item should start at
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  defaultPosition: _react.PropTypes.shape({
	    x: _react.PropTypes.number,
	    y: _react.PropTypes.number
	  }),
	
	  /**
	   * `position`, if present, defines the current position of the element.
	   *
	   *  This is similar to how form elements in React work - if no `position` is supplied, the component
	   *  is uncontrolled.
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable position={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  position: _react.PropTypes.shape({
	    x: _react.PropTypes.number,
	    y: _react.PropTypes.number
	  }),
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	});
	Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {
	  axis: 'both',
	  bounds: false,
	  defaultClassName: 'react-draggable',
	  defaultClassNameDragging: 'react-draggable-dragging',
	  defaultClassNameDragged: 'react-draggable-dragged',
	  defaultPosition: { x: 0, y: 0 },
	  position: null
	});
	exports.default = Draggable;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.matchesSelector = matchesSelector;
	exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
	exports.addEvent = addEvent;
	exports.removeEvent = removeEvent;
	exports.outerHeight = outerHeight;
	exports.outerWidth = outerWidth;
	exports.innerHeight = innerHeight;
	exports.innerWidth = innerWidth;
	exports.offsetXYFromParent = offsetXYFromParent;
	exports.createCSSTransform = createCSSTransform;
	exports.createSVGTransform = createSVGTransform;
	exports.getTouch = getTouch;
	exports.getTouchIdentifier = getTouchIdentifier;
	exports.addUserSelectStyles = addUserSelectStyles;
	exports.removeUserSelectStyles = removeUserSelectStyles;
	exports.styleHacks = styleHacks;
	
	var _shims = __webpack_require__(6);
	
	var _getPrefix = __webpack_require__(7);
	
	var _getPrefix2 = _interopRequireDefault(_getPrefix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	/*:: import type {ControlPosition} from './types';*/
	
	
	var matchesSelectorFunc = '';
	function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
	  if (!matchesSelectorFunc) {
	    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
	      // $FlowIgnore: Doesn't think elements are indexable
	      return (0, _shims.isFunction)(el[method]);
	    });
	  }
	
	  // $FlowIgnore: Doesn't think elements are indexable
	  return el[matchesSelectorFunc].call(el, selector);
	}
	
	// Works up the tree to the draggable itself attempting to match selector.
	function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
	  var node = el;
	  do {
	    if (matchesSelector(node, selector)) return true;
	    if (node === baseNode) return false;
	    node = node.parentNode;
	  } while (node);
	
	  return false;
	}
	
	function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.attachEvent) {
	    el.attachEvent('on' + event, handler);
	  } else if (el.addEventListener) {
	    el.addEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = handler;
	  }
	}
	
	function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.detachEvent) {
	    el.detachEvent('on' + event, handler);
	  } else if (el.removeEventListener) {
	    el.removeEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = null;
	  }
	}
	
	function outerHeight(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetTop which is including margin. See getBoundPosition
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height += (0, _shims.int)(computedStyle.borderTopWidth);
	  height += (0, _shims.int)(computedStyle.borderBottomWidth);
	  return height;
	}
	
	function outerWidth(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetLeft which is including margin. See getBoundPosition
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width += (0, _shims.int)(computedStyle.borderLeftWidth);
	  width += (0, _shims.int)(computedStyle.borderRightWidth);
	  return width;
	}
	function innerHeight(node /*: HTMLElement*/) /*: number*/ {
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height -= (0, _shims.int)(computedStyle.paddingTop);
	  height -= (0, _shims.int)(computedStyle.paddingBottom);
	  return height;
	}
	
	function innerWidth(node /*: HTMLElement*/) /*: number*/ {
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width -= (0, _shims.int)(computedStyle.paddingLeft);
	  width -= (0, _shims.int)(computedStyle.paddingRight);
	  return width;
	}
	
	// Get from offsetParent
	function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
	  var isBody = offsetParent === offsetParent.ownerDocument.body;
	  var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();
	
	  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
	  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
	
	  return { x: x, y: y };
	}
	
	function createCSSTransform(_ref) /*: Object*/ {
	  var x = _ref.x,
	      y = _ref.y;
	
	  // Replace unitless items with px
	  return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
	}
	
	function createSVGTransform(_ref3) /*: string*/ {
	  var x = _ref3.x,
	      y = _ref3.y;
	
	  return 'translate(' + x + ',' + y + ')';
	}
	
	function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
	  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
	    return identifier === t.identifier;
	  }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
	    return identifier === t.identifier;
	  });
	}
	
	function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
	  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
	  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
	}
	
	// User-select Hacks:
	//
	// Useful for preventing blue highlights all over everything when dragging.
	var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');
	var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);
	var userSelectStyle = ';' + userSelect + ': none;';
	var userSelectReplaceRegExp = new RegExp(';?' + userSelect + ': none;'); // leading ; not present on IE
	
	// Note we're passing `document` b/c we could be iframed
	function addUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  body.setAttribute('style', style + userSelectStyle);
	}
	
	function removeUserSelectStyles(body /*: HTMLElement*/) {
	  var style = body.getAttribute('style') || '';
	  body.setAttribute('style', style.replace(userSelectReplaceRegExp, ''));
	}
	
	function styleHacks() /*: Object*/ {
	  var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  // Workaround IE pointer events; see #51
	  // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
	  return _extends({
	    touchAction: 'none'
	  }, childStyle);
	}

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.findInArray = findInArray;
	exports.isFunction = isFunction;
	exports.isNum = isNum;
	exports.int = int;
	exports.dontSetMe = dontSetMe;
	
	// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
	function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
	  for (var i = 0, length = array.length; i < length; i++) {
	    if (callback.apply(callback, [array[i], i, array])) return array[i];
	  }
	}
	
	function isFunction(func /*: any*/) /*: boolean*/ {
	  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
	}
	
	function isNum(num /*: any*/) /*: boolean*/ {
	  return typeof num === 'number' && !isNaN(num);
	}
	
	function int(a /*: string*/) /*: number*/ {
	  return parseInt(a, 10);
	}
	
	function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
	  if (props[propName]) {
	    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
	  }
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrefix = getPrefix;
	exports.browserPrefixToKey = browserPrefixToKey;
	exports.browserPrefixToStyle = browserPrefixToStyle;
	var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	function getPrefix() /*: string*/ {
	  var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
	
	  // Checking specifically for 'window.document' is for pseudo-browser server-side
	  // environments that define 'window' as the global context.
	  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
	  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';
	
	  var style = window.document.documentElement.style;
	
	  if (prop in style) return '';
	
	  for (var i = 0; i < prefixes.length; i++) {
	    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
	  }
	
	  return '';
	}
	
	function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
	}
	
	function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
	}
	
	function kebabToTitleCase(str /*: string*/) /*: string*/ {
	  var out = '';
	  var shouldCapitalize = true;
	  for (var i = 0; i < str.length; i++) {
	    if (shouldCapitalize) {
	      out += str[i].toUpperCase();
	      shouldCapitalize = false;
	    } else if (str[i] === '-') {
	      shouldCapitalize = true;
	    } else {
	      out += str[i];
	    }
	  }
	  return out;
	}
	
	// Default export is the prefix itself, like 'Moz', 'Webkit', etc
	// Note that you may have to re-test for certain things; for instance, Chrome 50
	// can handle unprefixed `transform`, but not unprefixed `user-select`
	exports.default = getPrefix();

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getBoundPosition = getBoundPosition;
	exports.snapToGrid = snapToGrid;
	exports.canDragX = canDragX;
	exports.canDragY = canDragY;
	exports.getControlPosition = getControlPosition;
	exports.createCoreData = createCoreData;
	exports.createDraggableData = createDraggableData;
	
	var _shims = __webpack_require__(6);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*:: import type Draggable from '../Draggable';*/
	/*:: import type {Bounds, ControlPosition, DraggableData} from './types';*/
	/*:: import type DraggableCore from '../DraggableCore';*/
	function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
	  // If no bounds, short-circuit and move on
	  if (!draggable.props.bounds) return [x, y];
	
	  // Clone new bounds
	  var bounds = draggable.props.bounds;
	
	  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
	  var node = _reactDom2.default.findDOMNode(draggable);
	
	  if (typeof bounds === 'string') {
	    var ownerDocument = node.ownerDocument;
	
	    var ownerWindow = ownerDocument.defaultView;
	    var boundNode = void 0;
	    if (bounds === 'parent') {
	      boundNode = node.parentNode;
	    } else {
	      boundNode = ownerDocument.querySelector(bounds);
	      if (!boundNode) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
	    }
	    var nodeStyle = ownerWindow.getComputedStyle(node);
	    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
	    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
	    bounds = {
	      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.borderLeftWidth) + (0, _shims.int)(nodeStyle.marginLeft),
	      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.borderTopWidth) + (0, _shims.int)(nodeStyle.marginTop),
	      right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft,
	      bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop
	    };
	  }
	
	  // Keep x and y below right and bottom limits...
	  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
	  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
	
	  // But above left and top limits.
	  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
	  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
	
	  return [x, y];
	}
	
	function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
	  var x = Math.round(pendingX / grid[0]) * grid[0];
	  var y = Math.round(pendingY / grid[1]) * grid[1];
	  return [x, y];
	}
	
	function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
	}
	
	function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
	}
	
	// Get {x, y} positions from event.
	function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
	  var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
	  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
	  var node = _reactDom2.default.findDOMNode(draggableCore);
	  // User can provide an offsetParent if desired.
	  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
	  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
	}
	
	// Create an data object exposed by <DraggableCore>'s events
	function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
	  var state = draggable.state;
	  var isStart = !(0, _shims.isNum)(state.lastX);
	
	  if (isStart) {
	    // If this is our first move, use the x and y as last coords.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: 0, deltaY: 0,
	      lastX: x, lastY: y,
	      x: x, y: y
	    };
	  } else {
	    // Otherwise calculate proper values.
	    return {
	      node: _reactDom2.default.findDOMNode(draggable),
	      deltaX: x - state.lastX, deltaY: y - state.lastY,
	      lastX: state.lastX, lastY: state.lastY,
	      x: x, y: y
	    };
	  }
	}
	
	// Create an data exposed by <Draggable>'s events
	function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
	  return {
	    node: coreData.node,
	    x: draggable.state.x + coreData.deltaX,
	    y: draggable.state.y + coreData.deltaY,
	    deltaX: coreData.deltaX,
	    deltaY: coreData.deltaY,
	    lastX: draggable.state.x,
	    lastY: draggable.state.y
	  };
	}
	
	// A lot faster than stringify/parse
	function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
	  return {
	    left: bounds.left,
	    top: bounds.top,
	    right: bounds.right,
	    bottom: bounds.bottom
	  };
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(3);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _domFns = __webpack_require__(5);
	
	var _positionFns = __webpack_require__(8);
	
	var _shims = __webpack_require__(6);
	
	var _log = __webpack_require__(11);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Simple abstraction for dragging events names.
	/*:: import type {EventHandler} from './utils/types';*/
	var eventsFor = {
	  touch: {
	    start: 'touchstart',
	    move: 'touchmove',
	    stop: 'touchend'
	  },
	  mouse: {
	    start: 'mousedown',
	    move: 'mousemove',
	    stop: 'mouseup'
	  }
	};
	
	// Default to mouse events.
	var dragEventFor = eventsFor.mouse;
	
	//
	// Define <DraggableCore>.
	//
	// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
	// work well with libraries that require more control over the element.
	//
	
	/*:: type CoreState = {
	  dragging: boolean,
	  lastX: number,
	  lastY: number,
	  touchIdentifier: ?number
	};*/
	
	var DraggableCore = function (_React$Component) {
	  _inherits(DraggableCore, _React$Component);
	
	  function DraggableCore() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, DraggableCore);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      dragging: false,
	      // Used while dragging to determine deltas.
	      lastX: NaN, lastY: NaN,
	      touchIdentifier: null
	    }, _this.handleDragStart = function (e) {
	      // Make it possible to attach event handlers on top of this one.
	      _this.props.onMouseDown(e);
	
	      // Only accept left-clicks.
	      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;
	
	      // Get nodes. Be sure to grab relative document (could be iframed)
	      var domNode = _reactDom2.default.findDOMNode(_this);
	      var ownerDocument = domNode.ownerDocument;
	
	      // Short circuit if handle or cancel prop was provided and selector doesn't match.
	
	      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, domNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, domNode)) {
	        return;
	      }
	
	      // Set touch identifier in component state if this is a touch event. This allows us to
	      // distinguish between individual touches on multitouch screens by identifying which
	      // touchpoint was set to this element.
	      var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
	      _this.setState({ touchIdentifier: touchIdentifier });
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
	      if (position == null) return; // not possible but satisfies flow
	      var x = position.x,
	          y = position.y;
	
	      // Create an event object with all the data parents need to make a decision here.
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, cancel.
	      (0, _log2.default)('calling', _this.props.onStart);
	      var shouldUpdate = _this.props.onStart(e, coreEvent);
	      if (shouldUpdate === false) return;
	
	      // Add a style to the body to disable user-select. This prevents text from
	      // being selected all over the page.
	      if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument.body);
	
	      // Initiate dragging. Set the current x and y as offsets
	      // so we know how much we've moved during the drag. This allows us
	      // to drag elements around even if they have been moved, without issue.
	      _this.setState({
	        dragging: true,
	
	        lastX: x,
	        lastY: y
	      });
	
	      // Add events to the document directly so we catch when the user's mouse/touch moves outside of
	      // this element. We use different events depending on whether or not we have detected that this
	      // is a touch-capable device.
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.handleDrag = function (e) {
	
	      // Prevent scrolling on mobile devices, like ipad/iphone.
	      if (e.type === 'touchmove') e.preventDefault();
	
	      // Get the current drag point from the event. This is used as the offset.
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      // Snap to grid if prop has been provided
	
	      if (x !== x) debugger;
	
	      if (Array.isArray(_this.props.grid)) {
	        var deltaX = x - _this.state.lastX,
	            deltaY = y - _this.state.lastY;
	
	        var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
	
	        var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
	
	        deltaX = _snapToGrid2[0];
	        deltaY = _snapToGrid2[1];
	
	        if (!deltaX && !deltaY) return; // skip useless drag
	        x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
	      }
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);
	
	      // Call event handler. If it returns explicit false, trigger end.
	      var shouldUpdate = _this.props.onDrag(e, coreEvent);
	      if (shouldUpdate === false) {
	        try {
	          // $FlowIgnore
	          _this.handleDragStop(new MouseEvent('mouseup'));
	        } catch (err) {
	          // Old browsers
	          var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
	          // I see why this insanity was deprecated
	          // $FlowIgnore
	          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	          _this.handleDragStop(event);
	        }
	        return;
	      }
	
	      _this.setState({
	        lastX: x,
	        lastY: y
	      });
	    }, _this.handleDragStop = function (e) {
	      if (!_this.state.dragging) return;
	
	      var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;
	
	      var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	
	      var _ReactDOM$findDOMNode = _reactDom2.default.findDOMNode(_this),
	          ownerDocument = _ReactDOM$findDOMNode.ownerDocument;
	
	      // Remove user-select hack
	
	
	      if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	
	      (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);
	
	      // Reset the el.
	      _this.setState({
	        dragging: false,
	        lastX: NaN,
	        lastY: NaN
	      });
	
	      // Call event handler
	      _this.props.onStop(e, coreEvent);
	
	      // Remove event handlers
	      (0, _log2.default)('DraggableCore: Removing handlers');
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.onMouseDown = function (e) {
	      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse
	
	      return _this.handleDragStart(e);
	    }, _this.onMouseUp = function (e) {
	      dragEventFor = eventsFor.mouse;
	
	      return _this.handleDragStop(e);
	    }, _this.onTouchStart = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStart(e);
	    }, _this.onTouchEnd = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;
	
	      return _this.handleDragStop(e);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(DraggableCore, [{
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      // Remove any leftover event handlers. Remove both touch and mouse handlers in case
	      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
	      var _ReactDOM$findDOMNode2 = _reactDom2.default.findDOMNode(this),
	          ownerDocument = _ReactDOM$findDOMNode2.ownerDocument;
	
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
	      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
	      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	    }
	
	    // Same as onMouseDown (start drag), but now consider this a touch device.
	
	  }, {
	    key: 'render',
	    value: function render() /*: React.Element<any>*/ {
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
	        style: (0, _domFns.styleHacks)(this.props.children.props.style),
	
	        // Note: mouseMove handler is attached to document so it will still function
	        // when the user drags quickly and leaves the bounds of the element.
	        onMouseDown: this.onMouseDown,
	        onTouchStart: this.onTouchStart,
	        onMouseUp: this.onMouseUp,
	        onTouchEnd: this.onTouchEnd
	      });
	    }
	  }]);
	
	  return DraggableCore;
	}(_react2.default.Component);
	
	DraggableCore.displayName = 'DraggableCore';
	DraggableCore.propTypes = {
	  /**
	   * `allowAnyClick` allows dragging using any mouse button.
	   * By default, we only accept the left button.
	   *
	   * Defaults to `false`.
	   */
	  allowAnyClick: _react.PropTypes.bool,
	
	  /**
	   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
	   * with the exception of `onMouseDown`, will not fire.
	   */
	  disabled: _react.PropTypes.bool,
	
	  /**
	   * By default, we add 'user-select:none' attributes to the document body
	   * to prevent ugly text selection during drag. If this is causing problems
	   * for your app, set this to `false`.
	   */
	  enableUserSelectHack: _react.PropTypes.bool,
	
	  /**
	   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
	   * instead of using the parent node.
	   */
	  offsetParent: function offsetParent(props, propName) {
	    if (process.browser && props[propName] && props[propName].nodeType !== 1) {
	      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
	    }
	  },
	
	  /**
	   * `grid` specifies the x and y that dragging should snap to.
	   */
	  grid: _react.PropTypes.arrayOf(_react.PropTypes.number),
	
	  /**
	   * `handle` specifies a selector to be used as the handle that initiates drag.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable handle=".handle">
	   *              <div>
	   *                  <div className="handle">Click me to drag</div>
	   *                  <div>This is some other content</div>
	   *              </div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  handle: _react.PropTypes.string,
	
	  /**
	   * `cancel` specifies a selector to be used to prevent drag initialization.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *           return(
	   *               <Draggable cancel=".cancel">
	   *                   <div>
	   *                     <div className="cancel">You can't drag from here</div>
	   *                     <div>Dragging here works fine</div>
	   *                   </div>
	   *               </Draggable>
	   *           );
	   *       }
	   *   });
	   * ```
	   */
	  cancel: _react.PropTypes.string,
	
	  /**
	   * Called when dragging starts.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onStart: _react.PropTypes.func,
	
	  /**
	   * Called while dragging.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onDrag: _react.PropTypes.func,
	
	  /**
	   * Called when dragging stops.
	   * If this function returns the boolean false, the drag will remain active.
	   */
	  onStop: _react.PropTypes.func,
	
	  /**
	   * A workaround option which can be passed if onMouseDown needs to be accessed,
	   * since it'll always be blocked (as there is internal use of onMouseDown)
	   */
	  onMouseDown: _react.PropTypes.func,
	
	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: _shims.dontSetMe,
	  style: _shims.dontSetMe,
	  transform: _shims.dontSetMe
	};
	DraggableCore.defaultProps = {
	  allowAnyClick: false, // by default only accept left click
	  cancel: null,
	  disabled: false,
	  enableUserSelectHack: true,
	  offsetParent: null,
	  handle: null,
	  grid: null,
	  transform: null,
	  onStart: function onStart() {},
	  onDrag: function onDrag() {},
	  onStop: function onStop() {},
	  onMouseDown: function onMouseDown() {}
	};
	exports.default = DraggableCore;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = log;
	
	/*eslint no-console:0*/
	function log() {
	  var _console;
	
	  if ((undefined)) (_console = console).log.apply(_console, arguments);
	}

/***/ }
/******/ ])
});
;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
(function (global){
/**
 * @module InputRange
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _Slider = require('./Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Label = require('./Label');

var _Label2 = _interopRequireDefault(_Label);

var _defaultClassNames = require('./defaultClassNames');

var _defaultClassNames2 = _interopRequireDefault(_defaultClassNames);

var _valueTransformer = require('./valueTransformer');

var _valueTransformer2 = _interopRequireDefault(_valueTransformer);

var _util = require('./util');

var _propTypes = require('./propTypes');

/**
 * A map for storing internal members
 * @const {WeakMap}
 */
var internals = new WeakMap();

/**
 * An object storing keyboard key codes
 * @const {Object.<string, number>}
 */
var KeyCode = {
  DOWN_ARROW: 40,
  LEFT_ARROW: 37,
  RIGHT_ARROW: 39,
  UP_ARROW: 38
};

/**
 * Check if values are within the max and min range of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if within range
 */
function isWithinRange(inputRange, values) {
  var props = inputRange.props;

  if (inputRange.isMultiValue) {
    return values.min >= props.minValue && values.max <= props.maxValue && values.min < values.max;
  }

  return values.max >= props.minValue && values.max <= props.maxValue;
}

/**
 * Check if the difference between values and the current values of inputRange
 * is greater or equal to its step amount
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if difference is greater or equal to step amount
 */
function hasStepDifference(inputRange, values) {
  var props = inputRange.props;

  var currentValues = _valueTransformer2['default'].valuesFromProps(inputRange);

  return (0, _util.length)(values.min, currentValues.min) >= props.step || (0, _util.length)(values.max, currentValues.max) >= props.step;
}

/**
 * Check if inputRange should update with new values
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Range} values - Min/max value of sliders
 * @return {boolean} True if inputRange should update
 */
function shouldUpdate(inputRange, values) {
  return isWithinRange(inputRange, values) && hasStepDifference(inputRange, values);
}

/**
 * Get the owner document of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Document} Document
 */
function getDocument(inputRange) {
  var ownerDocument = inputRange.refs.inputRange.ownerDocument;

  return ownerDocument;
}

/**
 * Get the class name(s) of inputRange based on its props
 * @private
 * @param {InputRange} inputRange - React component
 * @return {string} A list of class names delimited with spaces
 */
function getComponentClassName(inputRange) {
  var props = inputRange.props;

  if (!props.disabled) {
    return props.classNames.component;
  }

  return props.classNames.component + ' is-disabled';
}

/**
 * Get the key name of a slider
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Slider} slider - React component
 * @return {string} Key name
 */
function getKeyFromSlider(inputRange, slider) {
  if (slider === inputRange.refs.sliderMin) {
    return 'min';
  }

  return 'max';
}

/**
 * Get all slider keys of inputRange
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Key names
 */
function getKeys(inputRange) {
  if (inputRange.isMultiValue) {
    return ['min', 'max'];
  }

  return ['max'];
}

/**
 * Get the key name of a slider that's the closest to a point
 * @private
 * @param {InputRange} inputRange - React component
 * @param {Point} position - x/y
 * @return {string} Key name
 */
function getKeyByPosition(inputRange, position) {
  var values = _valueTransformer2['default'].valuesFromProps(inputRange);
  var positions = _valueTransformer2['default'].positionsFromValues(inputRange, values);

  if (inputRange.isMultiValue) {
    var distanceToMin = (0, _util.distanceTo)(position, positions.min);
    var distanceToMax = (0, _util.distanceTo)(position, positions.max);

    if (distanceToMin < distanceToMax) {
      return 'min';
    }
  }

  return 'max';
}

/**
 * Get an array of slider HTML for rendering
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Array of HTML
 */
function renderSliders(inputRange) {
  var classNames = inputRange.props.classNames;

  var sliders = [];
  var keys = getKeys(inputRange);
  var values = _valueTransformer2['default'].valuesFromProps(inputRange);
  var percentages = _valueTransformer2['default'].percentagesFromValues(inputRange, values);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var value = values[key];
      var percentage = percentages[key];
      var ref = 'slider' + (0, _util.captialize)(key);

      var _inputRange$props = inputRange.props;
      var maxValue = _inputRange$props.maxValue;
      var minValue = _inputRange$props.minValue;

      if (key === 'min') {
        maxValue = values.max;
      } else {
        minValue = values.min;
      }

      var slider = _react2['default'].createElement(_Slider2['default'], {
        ariaLabelledby: inputRange.props.ariaLabelledby,
        ariaControls: inputRange.props.ariaControls,
        classNames: classNames,
        formatLabel: inputRange.formatLabel,
        key: key,
        maxValue: maxValue,
        minValue: minValue,
        onSliderKeyDown: inputRange.handleSliderKeyDown,
        onSliderMouseMove: inputRange.handleSliderMouseMove,
        percentage: percentage,
        ref: ref,
        type: key,
        value: value });

      sliders.push(slider);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return sliders;
}

/**
 * Get an array of hidden input HTML for rendering
 * @private
 * @param {InputRange} inputRange - React component
 * @return {Array.<string>} Array of HTML
 */
function renderHiddenInputs(inputRange) {
  var inputs = [];
  var keys = getKeys(inputRange);

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var key = _step2.value;

      var _name = inputRange.isMultiValue ? '' + inputRange.props.name + (0, _util.captialize)(key) : inputRange.props.name;

      var input = _react2['default'].createElement('input', { type: 'hidden', name: _name });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return inputs;
}

/**
 * InputRange React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var InputRange = (function (_React$Component) {
  _inherits(InputRange, _React$Component);

  function InputRange(props) {
    _classCallCheck(this, InputRange);

    _get(Object.getPrototypeOf(InputRange.prototype), 'constructor', this).call(this, props);

    // Private
    internals.set(this, {});

    // Auto-bind
    (0, _util.autobind)(['formatLabel', 'handleInteractionEnd', 'handleInteractionStart', 'handleKeyDown', 'handleKeyUp', 'handleMouseDown', 'handleMouseUp', 'handleSliderKeyDown', 'handleSliderMouseMove', 'handleTouchStart', 'handleTouchEnd', 'handleTrackMouseDown'], this);
  }

  /**
   * Accepted propTypes of InputRange
   * @static {Object}
   * @property {Function} ariaLabelledby
   * @property {Function} ariaControls
   * @property {Function} classNames
   * @property {Function} defaultValue
   * @property {Function} disabled
   * @property {Function} formatLabel
   * @property {Function} labelPrefix
   * @property {Function} labelSuffix
   * @property {Function} maxValue
   * @property {Function} minValue
   * @property {Function} name
   * @property {Function} onChange
   * @property {Function} onChangeComplete
   * @property {Function} step
   * @property {Function} value
   */

  /**
   * Return the clientRect of the component's track
   * @member {ClientRect}
   */

  _createClass(InputRange, [{
    key: 'updatePosition',

    /**
     * Update the position of a slider by key
     * @param {string} key - min/max
     * @param {Point} position x/y
     */
    value: function updatePosition(key, position) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var positions = _valueTransformer2['default'].positionsFromValues(this, values);

      positions[key] = position;

      this.updatePositions(positions);
    }

    /**
     * Update the position of sliders
     * @param {Object} positions
     * @param {Point} positions.min
     * @param {Point} positions.max
     */
  }, {
    key: 'updatePositions',
    value: function updatePositions(positions) {
      var values = {
        min: _valueTransformer2['default'].valueFromPosition(this, positions.min),
        max: _valueTransformer2['default'].valueFromPosition(this, positions.max)
      };

      var transformedValues = {
        min: _valueTransformer2['default'].stepValueFromValue(this, values.min),
        max: _valueTransformer2['default'].stepValueFromValue(this, values.max)
      };

      this.updateValues(transformedValues);
    }

    /**
     * Update the value of a slider by key
     * @param {string} key - max/min
     * @param {number} value - New value
     */
  }, {
    key: 'updateValue',
    value: function updateValue(key, value) {
      var values = _valueTransformer2['default'].valuesFromProps(this);

      values[key] = value;

      this.updateValues(values);
    }

    /**
     * Update the values of all sliders
     * @param {Object|number} values - Object if multi-value, number if single-value
     */
  }, {
    key: 'updateValues',
    value: function updateValues(values) {
      if (!shouldUpdate(this, values)) {
        return;
      }

      if (this.isMultiValue) {
        this.props.onChange(this, values);
      } else {
        this.props.onChange(this, values.max);
      }
    }

    /**
     * Increment the value of a slider by key name
     * @param {string} key - max/min
     */
  }, {
    key: 'incrementValue',
    value: function incrementValue(key) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var value = values[key] + this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Decrement the value of a slider by key name
     * @param {string} key - max/min
     */
  }, {
    key: 'decrementValue',
    value: function decrementValue(key) {
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var value = values[key] - this.props.step;

      this.updateValue(key, value);
    }

    /**
     * Format label
     * @param {number} labelValue - Label value
     * @return {string} Formatted label value
     */
  }, {
    key: 'formatLabel',
    value: function formatLabel(labelValue) {
      var _props = this.props;
      var formatLabel = _props.formatLabel;
      var labelPrefix = _props.labelPrefix;
      var labelSuffix = _props.labelSuffix;

      if (formatLabel) {
        return formatLabel(labelValue, { labelPrefix: labelPrefix, labelSuffix: labelSuffix });
      }

      return '' + labelPrefix + labelValue + labelSuffix;
    }

    /**
     * Handle any mousemove event received by the slider
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     */
  }, {
    key: 'handleSliderMouseMove',
    value: function handleSliderMouseMove(event, slider) {
      if (this.props.disabled) {
        return;
      }

      var key = getKeyFromSlider(this, slider);
      var position = _valueTransformer2['default'].positionFromEvent(this, event);

      this.updatePosition(key, position);
    }

    /**
     * Handle any keydown event received by the slider
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     */
  }, {
    key: 'handleSliderKeyDown',
    value: function handleSliderKeyDown(event, slider) {
      if (this.props.disabled) {
        return;
      }

      var key = getKeyFromSlider(this, slider);

      switch (event.keyCode) {
        case KeyCode.LEFT_ARROW:
        case KeyCode.DOWN_ARROW:
          event.preventDefault();
          this.decrementValue(key);
          break;

        case KeyCode.RIGHT_ARROW:
        case KeyCode.UP_ARROW:
          event.preventDefault();
          this.incrementValue(key);
          break;

        default:
          break;
      }
    }

    /**
     * Handle any mousedown event received by the track
     * @param {SyntheticEvent} event - User event
     * @param {Slider} slider - React component
     * @param {Point} position - Mousedown position
     */
  }, {
    key: 'handleTrackMouseDown',
    value: function handleTrackMouseDown(event, track, position) {
      if (this.props.disabled) {
        return;
      }

      event.preventDefault();

      var key = getKeyByPosition(this, position);

      this.updatePosition(key, position);
    }

    /**
     * Handle the start of any user-triggered event
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleInteractionStart',
    value: function handleInteractionStart() {
      var _this = internals.get(this);

      if (!this.props.onChangeComplete || (0, _util.isDefined)(_this.startValue)) {
        return;
      }

      _this.startValue = this.props.value || this.props.defaultValue;
    }

    /**
     * Handle the end of any user-triggered event
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleInteractionEnd',
    value: function handleInteractionEnd() {
      var _this = internals.get(this);

      if (!this.props.onChangeComplete || !(0, _util.isDefined)(_this.startValue)) {
        return;
      }

      if (_this.startValue !== this.props.value) {
        this.props.onChangeComplete(this, this.props.value);
      }

      _this.startValue = null;
    }

    /**
     * Handle any keydown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.handleInteractionStart(event);
    }

    /**
     * Handle any keyup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyUp',
    value: function handleKeyUp(event) {
      this.handleInteractionEnd(event);
    }

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      var document = getDocument(this);

      this.handleInteractionStart(event);

      document.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mouseup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp(event) {
      var document = getDocument(this);

      this.handleInteractionEnd(event);

      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      var document = getDocument(this);

      this.handleInteractionStart(event);

      document.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any touchend event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      var document = getDocument(this);

      this.handleInteractionEnd(event);

      document.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var classNames = this.props.classNames;

      var componentClassName = getComponentClassName(this);
      var values = _valueTransformer2['default'].valuesFromProps(this);
      var percentages = _valueTransformer2['default'].percentagesFromValues(this, values);

      return _react2['default'].createElement(
        'div',
        {
          'aria-disabled': this.props.disabled,
          ref: 'inputRange',
          className: componentClassName,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart },
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelMin,
            containerClassName: classNames.labelContainer,
            formatLabel: this.formatLabel },
          this.props.minValue
        ),
        _react2['default'].createElement(
          _Track2['default'],
          {
            classNames: classNames,
            ref: 'track',
            percentages: percentages,
            onTrackMouseDown: this.handleTrackMouseDown },
          renderSliders(this)
        ),
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelMax,
            containerClassName: classNames.labelContainer,
            formatLabel: this.formatLabel },
          this.props.maxValue
        ),
        renderHiddenInputs(this)
      );
    }
  }, {
    key: 'trackClientRect',
    get: function get() {
      var track = this.refs.track;

      if (track) {
        return track.clientRect;
      }

      return {
        height: 0,
        left: 0,
        top: 0,
        width: 0
      };
    }

    /**
     * Return true if the component accepts a range of values
     * @member {boolean}
     */
  }, {
    key: 'isMultiValue',
    get: function get() {
      return (0, _util.isObject)(this.props.value) || (0, _util.isObject)(this.props.defaultValue);
    }
  }]);

  return InputRange;
})(_react2['default'].Component);

exports['default'] = InputRange;
InputRange.propTypes = {
  ariaLabelledby: _react2['default'].PropTypes.string,
  ariaControls: _react2['default'].PropTypes.string,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  defaultValue: _propTypes.maxMinValuePropType,
  disabled: _react2['default'].PropTypes.bool,
  formatLabel: _react2['default'].PropTypes.func,
  labelPrefix: _react2['default'].PropTypes.string,
  labelSuffix: _react2['default'].PropTypes.string,
  maxValue: _propTypes.maxMinValuePropType,
  minValue: _propTypes.maxMinValuePropType,
  name: _react2['default'].PropTypes.string,
  onChange: _react2['default'].PropTypes.func.isRequired,
  onChangeComplete: _react2['default'].PropTypes.func,
  step: _react2['default'].PropTypes.number,
  value: _propTypes.maxMinValuePropType
};

/**
 * Default props of InputRange
 * @static {Object}
 * @property {Object.<string, string>} defaultClassNames
 * @property {Range|number} defaultValue
 * @property {boolean} disabled
 * @property {string} labelPrefix
 * @property {string} labelSuffix
 * @property {number} maxValue
 * @property {number} minValue
 * @property {number} step
 * @property {Range|number} value
 */
InputRange.defaultProps = {
  classNames: _defaultClassNames2['default'],
  defaultValue: 0,
  disabled: false,
  labelPrefix: '',
  labelSuffix: '',
  maxValue: 10,
  minValue: 0,
  step: 1,
  value: null
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Label":3,"./Slider":4,"./Track":5,"./defaultClassNames":6,"./propTypes":8,"./util":9,"./valueTransformer":10}],3:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Label
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

/**
 * Label React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Label = (function (_React$Component) {
  _inherits(Label, _React$Component);

  function Label() {
    _classCallCheck(this, Label);

    _get(Object.getPrototypeOf(Label.prototype), 'constructor', this).apply(this, arguments);
  }

  /**
   * Accepted propTypes of Label
   * @static {Object}
   * @property {Function} children
   * @property {Function} className
   * @property {Function} containerClassName
   * @property {Function} formatLabel
   */

  _createClass(Label, [{
    key: 'render',

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
    value: function render() {
      var _props = this.props;
      var className = _props.className;
      var containerClassName = _props.containerClassName;

      var labelValue = this.props.formatLabel ? this.props.formatLabel(this.props.children) : this.props.children;

      return _react2['default'].createElement(
        'span',
        { className: className },
        _react2['default'].createElement(
          'span',
          { className: containerClassName },
          labelValue
        )
      );
    }
  }]);

  return Label;
})(_react2['default'].Component);

exports['default'] = Label;
Label.propTypes = {
  children: _react2['default'].PropTypes.node,
  className: _react2['default'].PropTypes.string,
  containerClassName: _react2['default'].PropTypes.string,
  formatLabel: _react2['default'].PropTypes.func
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Slider
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _Label = require('./Label');

var _Label2 = _interopRequireDefault(_Label);

var _util = require('./util');

/**
 * Get the owner document of slider
 * @private
 * @param {Slider} slider - React component
 * @return {Document} Document
 */
function getDocument(slider) {
  var ownerDocument = slider.refs.slider.ownerDocument;

  return ownerDocument;
}

/**
 * Get the style of slider based on its props
 * @private
 * @param {Slider} slider - React component
 * @return {Object} CSS styles
 */
function getStyle(slider) {
  var perc = (slider.props.percentage || 0) * 100;
  var style = {
    position: 'absolute',
    left: perc + '%'
  };

  return style;
}

/**
 * Slider React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    // Auto-bind
    (0, _util.autobind)(['handleClick', 'handleMouseDown', 'handleMouseUp', 'handleMouseMove', 'handleTouchStart', 'handleTouchEnd', 'handleTouchMove', 'handleKeyDown'], this);
  }

  /**
   * Accepted propTypes of Slider
   * @static {Object}
   * @property {Function} ariaLabelledby
   * @property {Function} ariaControls
   * @property {Function} className
   * @property {Function} formatLabel
   * @property {Function} maxValue
   * @property {Function} minValue
   * @property {Function} onSliderKeyDown
   * @property {Function} onSliderMouseMove
   * @property {Function} percentage
   * @property {Function} type
   * @property {Function} value
   */

  /**
   * Handle any click event received by the component
   * @param {SyntheticEvent} event - User event
   */

  _createClass(Slider, [{
    key: 'handleClick',
    value: function handleClick(event) {
      event.preventDefault();
    }

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown() {
      var document = getDocument(this);

      // Event
      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mouseup event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseUp',
    value: function handleMouseUp() {
      var document = getDocument(this);

      // Event
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    }

    /**
     * Handle any mousemove event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleMouseMove',
    value: function handleMouseMove(event) {
      this.props.onSliderMouseMove(event, this);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      var document = getDocument(this);

      event.preventDefault();

      document.addEventListener('touchmove', this.handleTouchMove);
      document.addEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any touchmove event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchMove',
    value: function handleTouchMove(event) {
      this.props.onSliderMouseMove(event, this);
    }

    /**
     * Handle any touchend event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchEnd',
    value: function handleTouchEnd(event) {
      var document = getDocument(this);

      event.preventDefault();

      document.removeEventListener('touchmove', this.handleTouchMove);
      document.removeEventListener('touchend', this.handleTouchEnd);
    }

    /**
     * Handle any keydown event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      this.props.onSliderKeyDown(event, this);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var classNames = this.props.classNames;
      var style = getStyle(this);

      return _react2['default'].createElement(
        'span',
        {
          className: classNames.sliderContainer,
          ref: 'slider',
          style: style },
        _react2['default'].createElement(
          _Label2['default'],
          {
            className: classNames.labelValue,
            containerClassName: classNames.labelContainer,
            formatLabel: this.props.formatLabel },
          this.props.value
        ),
        _react2['default'].createElement('a', {
          'aria-labelledby': this.props.ariaLabelledby,
          'aria-controls': this.props.ariaControls,
          'aria-valuemax': this.props.maxValue,
          'aria-valuemin': this.props.minValue,
          'aria-valuenow': this.props.formatLabel ? this.props.formatLabel(this.props.value) : this.props.value,
          className: classNames.slider,
          draggable: 'false',
          href: '#',
          onClick: this.handleClick,
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          role: 'slider' })
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

exports['default'] = Slider;
Slider.propTypes = {
  ariaLabelledby: _react2['default'].PropTypes.string,
  ariaControls: _react2['default'].PropTypes.string,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  formatLabel: _react2['default'].PropTypes.func,
  maxValue: _react2['default'].PropTypes.number,
  minValue: _react2['default'].PropTypes.number,
  onSliderKeyDown: _react2['default'].PropTypes.func.isRequired,
  onSliderMouseMove: _react2['default'].PropTypes.func.isRequired,
  percentage: _react2['default'].PropTypes.number.isRequired,
  type: _react2['default'].PropTypes.string.isRequired,
  value: _react2['default'].PropTypes.number.isRequired
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Label":3,"./util":9}],5:[function(require,module,exports){
(function (global){
/**
 * @module InputRange/Track
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _util = require('./util');

/**
 * Get the CSS styles for an active track
 * @private
 * @param {Track} track React component
 * @return {Object} CSS styles
 */
function getActiveTrackStyle(track) {
  var props = track.props;

  var width = (props.percentages.max - props.percentages.min) * 100 + '%';
  var left = props.percentages.min * 100 + '%';

  var activeTrackStyle = {
    left: left,
    width: width
  };

  return activeTrackStyle;
}

/**
 * Track React component
 * @class
 * @extends React.Component
 * @param {Object} props - React component props
 */

var Track = (function (_React$Component) {
  _inherits(Track, _React$Component);

  function Track(props) {
    _classCallCheck(this, Track);

    _get(Object.getPrototypeOf(Track.prototype), 'constructor', this).call(this, props);

    // Auto-bind
    (0, _util.autobind)(['handleMouseDown', 'handleTouchStart'], this);
  }

  /**
   * Accepted propTypes of Track
   * @static {Object}
   * @property {Function} children
   * @property {Function} classNames
   * @property {Function} onTrackMouseDown
   * @property {Function} percentages
   */

  /**
   * Return the clientRect of the component
   * @member {ClientRect}
   */

  _createClass(Track, [{
    key: 'handleMouseDown',

    /**
     * Handle any mousedown event received by the component
     * @param {SyntheticEvent} event - User event
     */
    value: function handleMouseDown(event) {
      var trackClientRect = this.clientRect;

      var _ref = event.touches ? event.touches[0] : event;

      var clientX = _ref.clientX;

      var position = {
        x: clientX - trackClientRect.left,
        y: 0
      };

      this.props.onTrackMouseDown(event, this, position);
    }

    /**
     * Handle any touchstart event received by the component
     * @param {SyntheticEvent} event - User event
     */
  }, {
    key: 'handleTouchStart',
    value: function handleTouchStart(event) {
      event.preventDefault();

      this.handleMouseDown(event);
    }

    /**
     * Render method of the component
     * @return {string} Component JSX
     */
  }, {
    key: 'render',
    value: function render() {
      var activeTrackStyle = getActiveTrackStyle(this);
      var classNames = this.props.classNames;

      return _react2['default'].createElement(
        'div',
        {
          className: classNames.trackContainer,
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          ref: 'track' },
        _react2['default'].createElement('div', {
          style: activeTrackStyle,
          className: classNames.trackActive }),
        this.props.children
      );
    }
  }, {
    key: 'clientRect',
    get: function get() {
      var track = this.refs.track;

      var clientRect = track.getBoundingClientRect();

      return clientRect;
    }
  }]);

  return Track;
})(_react2['default'].Component);

exports['default'] = Track;
Track.propTypes = {
  children: _react2['default'].PropTypes.node,
  classNames: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.string),
  onTrackMouseDown: _react2['default'].PropTypes.func.isRequired,
  percentages: _react2['default'].PropTypes.objectOf(_react2['default'].PropTypes.number).isRequired
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./util":9}],6:[function(require,module,exports){
/**
 * @module InputRange/defaultClassNames
 */

/**
* An object containing class names
* @const {Object}
* @property {string} component
* @property {string} labelContainer
* @property {string} labelMax
* @property {string} labelMin
* @property {string} labelValue
* @property {string} slider
* @property {string} sliderContainer
* @property {string} trackActive
* @property {string} trackContainer
*/
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  component: 'InputRange',
  labelContainer: 'InputRange-labelContainer',
  labelMax: 'InputRange-label InputRange-label--max',
  labelMin: 'InputRange-label InputRange-label--min',
  labelValue: 'InputRange-label InputRange-label--value',
  slider: 'InputRange-slider',
  sliderContainer: 'InputRange-sliderContainer',
  trackActive: 'InputRange-track InputRange-track--active',
  trackContainer: 'InputRange-track InputRange-track--container'
};
module.exports = exports['default'];
},{}],7:[function(require,module,exports){
/**
 * @module InputRange
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _InputRange = require('./InputRange');

var _InputRange2 = _interopRequireDefault(_InputRange);

/**
 * An object describing the position of a point
 * @typedef {Object} Point
 * @property {number} x - x value
 * @property {number} y - y value
 */

/**
 * An object describing a range of values
 * @typedef {Object} Range
 * @property {number} min - Min value
 * @property {number} max - Max value
 */

exports['default'] = _InputRange2['default'];
module.exports = exports['default'];
},{"./InputRange":2}],8:[function(require,module,exports){
/**
 * @module InputRange/maxMinValuePropType
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.maxMinValuePropType = maxMinValuePropType;

var _util = require('./util');

/**
 * A prop type accepting a range of numeric values or a single numeric value
 * @param {Object} props - React component props
 * @return {?Error} Return Error if validation fails
 */

function maxMinValuePropType(props) {
  var maxValue = props.maxValue;
  var minValue = props.minValue;
  var value = props.value;
  var defaultValue = props.defaultValue;
  var isValueNumber = (0, _util.isNumber)(value);
  var isDefaultValueNumber = (0, _util.isNumber)(defaultValue);
  var isValueNumberObject = (0, _util.objectOf)(value, _util.isNumber);
  var isDefaultValueNumberObject = (0, _util.objectOf)(defaultValue, _util.isNumber);

  if (value === undefined) {
    return new Error('`value` must be defined');
  }

  if (!isValueNumber && !isDefaultValueNumber && !isValueNumberObject && !isDefaultValueNumberObject) {
    return new Error('`value` or `defaultValue` must be a number or an array');
  }

  if (minValue >= maxValue) {
    return new Error('`minValue` must be smaller than `maxValue`');
  }

  if (maxValue <= minValue) {
    return new Error('`maxValue` must be larger than `minValue`');
  }

  if (value < minValue || value > maxValue) {
    return new Error('`value` must be within `minValue` and `maxValue`');
  }
}
},{"./util":9}],9:[function(require,module,exports){
/**
 * @module InputRange/util
 */

/**
 * @callback predicateFn
 * @param {*} value
 * @return {boolean}
 */

/**
 * Clamp a value between a min and max value
 * @static
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.clamp = clamp;
exports.extend = extend;
exports.includes = includes;
exports.omit = omit;
exports.captialize = captialize;
exports.distanceTo = distanceTo;
exports.length = length;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isDefined = isDefined;
exports.isEmpty = isEmpty;
exports.arrayOf = arrayOf;
exports.objectOf = objectOf;
exports.autobind = autobind;

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Extend an Object
 * @static
 * @param {Object} object - Destination object
 * @param {...Object} sources - Source objects
 * @return {Object} Destination object, extended with members from sources
 */

function extend() {
  return Object.assign.apply(Object, arguments);
}

/**
 * Check if a value is included in an array
 * @static
 * @param {Array} array
 * @param {number} value
 * @return {boolean}
 */

function includes(array, value) {
  return array.indexOf(value) > -1;
}

/**
 * Return a new object without the specified keys
 * @static
 * @param {Object} obj
 * @param {Array.<string>} omitKeys
 * @return {Object}
 */

function omit(obj, omitKeys) {
  var keys = Object.keys(obj);
  var outputObj = {};

  keys.forEach(function (key) {
    if (!includes(omitKeys, key)) {
      outputObj[key] = obj[key];
    }
  });

  return outputObj;
}

/**
 * Captialize a string
 * @static
 * @param {string} string
 * @return {string}
 */

function captialize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Calculate the distance between pointA and pointB
 * @static
 * @param {Point} pointA
 * @param {Point} pointB
 * @return {number} Distance
 */

function distanceTo(pointA, pointB) {
  return Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2));
}

/**
 * Calculate the absolute difference between two numbers
 * @static
 * @param {number} numA
 * @param {number} numB
 * @return {number}
 */

function length(numA, numB) {
  return Math.abs(numA - numB);
}

/**
 * Check if a value is a number
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isNumber(value) {
  return typeof value === 'number';
}

/**
 * Check if a value is an object
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isObject(value) {
  return value !== null && typeof value === 'object';
}

/**
 * Check if a value is defined
 * @static
 * @param {*} value
 * @return {Boolean}
 */

function isDefined(value) {
  return value !== undefined && value !== null;
}

/**
 * Check if an object is empty
 * @static
 * @param {Object|Array} obj
 * @return {Boolean}
 */

function isEmpty(obj) {
  if (!obj) {
    return true;
  }

  if (Array.isArray(obj)) {
    return obj.length === 0;
  }

  return Object.keys(obj).length === 0;
}

/**
 * Check if all items in an array match a predicate
 * @static
 * @param {Array} array
 * @param {predicateFn} predicate
 * @return {Boolean}
 */

function arrayOf(array, predicate) {
  if (!Array.isArray(array)) {
    return false;
  }

  for (var i = 0, len = array.length; i < len; i++) {
    if (!predicate(array[i])) {
      return false;
    }
  }

  return true;
}

/**
 * Check if all items in an object match a predicate
 * @static
 * @param {Object} object
 * @param {predicateFn} predicate
 * @param {Array.<string>} keys
 * @return {Boolean}
 */

function objectOf(object, predicate, keys) {
  if (!isObject(object)) {
    return false;
  }

  var props = keys || Object.keys(object);

  for (var i = 0, len = props.length; i < len; i++) {
    var prop = props[i];

    if (!predicate(object[prop])) {
      return false;
    }
  }

  return true;
}

/**
 * Bind all methods of an object to itself
 * @static
 * @param {Array.<Function>} methodNames
 * @param {Object} instance
 */

function autobind(methodNames, instance) {
  methodNames.forEach(function (methodName) {
    instance[methodName] = instance[methodName].bind(instance);
  });
}
},{}],10:[function(require,module,exports){
/**
 * @module InputRange/valueTransformer
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _util = require('./util');

/**
 * Convert position into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Percentage value
 */
function percentageFromPosition(inputRange, position) {
  var length = inputRange.trackClientRect.width;
  var sizePerc = position.x / length;

  return sizePerc || 0;
}

/**
 * Convert position into model value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Model value
 */
function valueFromPosition(inputRange, position) {
  var sizePerc = percentageFromPosition(inputRange, position);
  var valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  var value = inputRange.props.minValue + valueDiff * sizePerc;

  return value;
}

/**
 * Extract values from props
 * @static
 * @param {InputRange} inputRange
 * @param {Point} [props=inputRange.props]
 * @return {Range} Range values
 */
function valuesFromProps(inputRange) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? inputRange : arguments[1];

  var props = _ref.props;
  return (function () {
    if (inputRange.isMultiValue) {
      var values = props.value;

      if ((0, _util.isEmpty)(values) || !(0, _util.objectOf)(values, _util.isNumber)) {
        values = props.defaultValue;
      }

      return Object.create(values);
    }

    var value = (0, _util.isNumber)(props.value) ? props.value : props.defaultValue;

    return {
      min: props.minValue,
      max: value
    };
  })();
}

/**
 * Convert value into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Percentage value
 */
function percentageFromValue(inputRange, value) {
  var validValue = (0, _util.clamp)(value, inputRange.props.minValue, inputRange.props.maxValue);
  var valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  var valuePerc = (validValue - inputRange.props.minValue) / valueDiff;

  return valuePerc || 0;
}

/**
 * Convert values into percentage values
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Range} Percentage values
 */
function percentagesFromValues(inputRange, values) {
  var percentages = {
    min: percentageFromValue(inputRange, values.min),
    max: percentageFromValue(inputRange, values.max)
  };

  return percentages;
}

/**
 * Convert value into position
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {Point} Position
 */
function positionFromValue(inputRange, value) {
  var length = inputRange.trackClientRect.width;
  var valuePerc = percentageFromValue(inputRange, value);
  var positionValue = valuePerc * length;

  return {
    x: positionValue,
    y: 0
  };
}

/**
 * Convert a range of values into positions
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Object.<string, Point>}
 */
function positionsFromValues(inputRange, values) {
  var positions = {
    min: positionFromValue(inputRange, values.min),
    max: positionFromValue(inputRange, values.max)
  };

  return positions;
}

/**
 * Extract a position from an event
 * @static
 * @param {InputRange} inputRange
 * @param {Event} event
 * @return {Point}
 */
function positionFromEvent(inputRange, event) {
  var trackClientRect = inputRange.trackClientRect;
  var length = trackClientRect.width;

  var _ref2 = event.touches ? event.touches[0] : event;

  var clientX = _ref2.clientX;

  var position = {
    x: (0, _util.clamp)(clientX - trackClientRect.left, 0, length),
    y: 0
  };

  return position;
}

/**
 * Convert a value into a step value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Step value
 */
function stepValueFromValue(inputRange, value) {
  return Math.round(value / inputRange.props.step) * inputRange.props.step;
}

exports['default'] = {
  percentageFromPosition: percentageFromPosition,
  percentageFromValue: percentageFromValue,
  percentagesFromValues: percentagesFromValues,
  positionFromEvent: positionFromEvent,
  positionFromValue: positionFromValue,
  positionsFromValues: positionsFromValues,
  stepValueFromValue: stepValueFromValue,
  valueFromPosition: valueFromPosition,
  valuesFromProps: valuesFromProps
};
module.exports = exports['default'];
},{"./util":9}],11:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wv = require('../tooltip/wv.tooltip');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var animWidgetHeader = function (_React$Component) {
  _inherits(animWidgetHeader, _React$Component);

  function animWidgetHeader(props) {
    _classCallCheck(this, animWidgetHeader);

    return _possibleConstructorReturn(this, (animWidgetHeader.__proto__ || Object.getPrototypeOf(animWidgetHeader)).call(this, props));
  }

  _createClass(animWidgetHeader, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-animation-widget-header' },
        'Animate Map in ',
        _react2.default.createElement(_wv2.default, { text: this.props.text, onClick: this.props.onClick, dataArray: this.props.toolTipTextArray }),
        ' Increments'
      );
    }
  }]);

  return animWidgetHeader;
}(_react2.default.Component);

exports.default = animWidgetHeader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../tooltip/wv.tooltip":22}],12:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactInputRange = require('react-input-range');

var _reactInputRange2 = _interopRequireDefault(_reactInputRange);

var _wv = require('../dateselector/wv.dateselector');

var _wv2 = _interopRequireDefault(_wv);

var _wv3 = require('./wv.loopbutton');

var _wv4 = _interopRequireDefault(_wv3);

var _wv5 = require('./wv.playbutton');

var _wv6 = _interopRequireDefault(_wv5);

var _wvAnimationWidget = require('./wv.animation.widget.header');

var _wvAnimationWidget2 = _interopRequireDefault(_wvAnimationWidget);

var _wv7 = require('../util/wv.googleAnalytics');

var _wv8 = _interopRequireDefault(_wv7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var AnimationWidget = function (_React$Component) {
  _inherits(AnimationWidget, _React$Component);

  function AnimationWidget(props) {
    _classCallCheck(this, AnimationWidget);

    var _this = _possibleConstructorReturn(this, (AnimationWidget.__proto__ || Object.getPrototypeOf(AnimationWidget)).call(this, props));

    _this.state = {
      value: props.sliderSpeed,
      looping: props.looping,
      startDate: props.startDate,
      endDate: props.endDate,
      header: props.header,
      incrementArray: props.incrementArray,
      increment: props.increment

    };
    return _this;
  }

  /*
   * Sets a new state value when a
   * when the slider is adjusted
   *
   * @method onSlide
   *
   * @param {Object} component - slider react
   *  component
   * @param {number} value - Value of the slider
   *  selection
   *
   * @return {void}
   */


  _createClass(AnimationWidget, [{
    key: 'onSlide',
    value: function onSlide(component, value) {
      this.props.onSlide(value);
      this.setState({
        value: value
      });
    }

    /*
     * calls the callback, passing the
     * current state elements as parameters
     *
     * @method play
     *
     * @return {void}
     */

  }, {
    key: 'play',
    value: function play() {
      this.props.onPushPlay();
      this.setState({
        playing: true
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.props.onPushPause();
      this.setState({
        playing: false
      });
    }
    /*
     * Sets a new state to say whether or not
     * the animation should loop
     *
     * @method onLoop
     *
     * @param {Object} component - slider react
     *  component
     * @param {number} value - Value of the slider
     *  selection
     *
     * @return {void}
     */

  }, {
    key: 'onLoop',
    value: function onLoop() {
      var loop = true;
      if (this.state.looping) {
        loop = false;
      }
      this.setState({
        looping: loop
      });
      this.props.onPushLoop(loop);
    }
  }, {
    key: 'onDateChange',
    value: function onDateChange(id, date) {
      if (id === 'start') {
        this.setState({
          startDate: date
        });
        this.props.onDateChange(date, this.state.endDate);
      } else {
        this.setState({
          endDate: date
        });
        this.props.onDateChange(this.state.startDate, date);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { id: 'wv-animation-widget', className: 'wv-animation-widget' },
        _react2.default.createElement(_wvAnimationWidget2.default, {
          text: this.state.increment,
          toolTipTextArray: this.state.incrementArray,
          onClick: this.props.onZoomSelect }),
        _react2.default.createElement(_wv6.default, { playing: this.state.playing, play: this.play.bind(this), pause: this.pause.bind(this) }),
        _react2.default.createElement(_wv4.default, { looping: this.state.looping, onLoop: this.onLoop.bind(this) }),
        _react2.default.createElement(
          'div',
          { className: 'wv-slider-case' },
          _react2.default.createElement(_reactInputRange2.default, { step: 0.5, maxValue: 10, minValue: 0.5, value: this.state.value, onChange: this.onSlide.bind(this) }),
          _react2.default.createElement(
            'span',
            { className: 'wv-slider-label' },
            this.props.sliderLabel
          )
        ),
        _react2.default.createElement(
          'a',
          { href: 'javascript:void(null)',
            title: 'Create Animated GIF',
            className: 'wv-icon-case',
            onClick: this.props.onPushGIF
          },
          _react2.default.createElement('i', { className: 'fa fa-file-video-o wv-animation-widget-icon' })
        ),
        _react2.default.createElement(
          'div',
          { className: 'wv-anim-dates-case' },
          _react2.default.createElement(_wv2.default, {
            width: '120',
            height: '30',
            date: this.state.startDate,
            id: 'start',
            onDateChange: this.onDateChange.bind(this),
            maxDate: this.state.endDate,
            minDate: this.props.minDate
          }),
          _react2.default.createElement(
            'div',
            { className: 'thru-label' },
            'To'
          ),
          _react2.default.createElement(_wv2.default, {
            width: '120',
            height: '30',
            date: this.state.endDate,
            id: 'end',
            onDateChange: this.onDateChange.bind(this),
            maxDate: this.props.maxDate,
            minDate: this.state.startDate
          })
        ),
        _react2.default.createElement('i', {
          className: 'fa fa-close wv-close',
          onClick: this.props.onClose
        })
      );
    }
  }]);

  return AnimationWidget;
}(_react2.default.Component);

exports.default = AnimationWidget;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../dateselector/wv.dateselector":18,"../util/wv.googleAnalytics":23,"./wv.animation.widget.header":11,"./wv.loopbutton":13,"./wv.playbutton":14,"react-input-range":7}],13:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var LoopButton = function (_React$Component) {
  _inherits(LoopButton, _React$Component);

  function LoopButton(props) {
    _classCallCheck(this, LoopButton);

    return _possibleConstructorReturn(this, (LoopButton.__proto__ || Object.getPrototypeOf(LoopButton)).call(this, props));
  }

  _createClass(LoopButton, [{
    key: "render",
    value: function render() {
      return _react2.default.createElement(
        "a",
        { href: "javascript:void(null)",
          title: this.props.looping ? "Stop Loop" : "Loop video",
          className: this.props.looping ? 'wv-loop-icon-case wv-icon-case active' : 'wv-loop-icon-case wv-icon-case',
          onClick: this.props.onLoop
        },
        _react2.default.createElement("i", { className: "fa fa-retweet wv-animation-widget-icon" })
      );
    }
  }]);

  return LoopButton;
}(_react2.default.Component);

exports.default = LoopButton;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var PlayButton = function (_React$Component) {
  _inherits(PlayButton, _React$Component);

  function PlayButton(props) {
    _classCallCheck(this, PlayButton);

    return _possibleConstructorReturn(this, (PlayButton.__proto__ || Object.getPrototypeOf(PlayButton)).call(this, props));
  }

  _createClass(PlayButton, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'a',
        { href: 'javascript:void(null)', title: this.props.playing ? 'Pause video' : 'Play video',
          className: 'wv-anim-play-case wv-icon-case',
          onClick: this.props.playing ? this.props.pause : this.props.play
        },
        _react2.default.createElement('i', { className: this.props.playing ? 'fa fa-pause wv-animation-widget-icon' : 'fa fa-play wv-animation-widget-icon' })
      );
    }
  }]);

  return PlayButton;
}(_react2.default.Component);

exports.default = PlayButton;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvDateselector = require('./wv.dateselector.input');

var _wvDateselector2 = _interopRequireDefault(_wvDateselector);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var dateSelector = function (_React$Component) {
  _inherits(dateSelector, _React$Component);

  /*
   * @constructor
   */
  function dateSelector(props) {
    _classCallCheck(this, dateSelector);

    var _this = _possibleConstructorReturn(this, (dateSelector.__proto__ || Object.getPrototypeOf(dateSelector)).call(this, props));

    _this.state = {
      date: props.date,
      maxDate: props.maxDate,
      minDate: props.minDate,
      tab: null
    };
    return _this;
  }

  _createClass(dateSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        date: props.date,
        maxDate: props.maxDate,
        minDate: props.minDate
      });
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({ tab: null });
    }
  }, {
    key: 'nextTab',
    value: function nextTab(index) {
      var nextTab;
      if (index < 3) {
        nextTab = index + 1;
      } else {
        nextTab = 1;
      }
      this.setState({
        tab: nextTab
      });
    }
  }, {
    key: 'updateDate',
    value: function updateDate(date) {
      this.setState({
        date: date
      });
      this.props.onDateChange(this.props.id, date);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-date-selector-widget' },
        _react2.default.createElement(_wvDateselector2.default, { startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          value: this.state.date.getUTCFullYear(),
          type: 'year',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          tabIndex: 1,
          focused: this.state.tab == 1,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(), date: this.state.date,
          type: 'month', height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.monthStringArray[this.state.date.getUTCMonth()],
          tabIndex: 2,
          focused: this.state.tab == 2,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          type: 'day',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.pad(this.state.date.getUTCDate(), 2, '0'),
          tabIndex: 3,
          focused: this.state.tab == 3,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        })
      );
    }
  }]);

  return dateSelector;
}(_react2.default.Component);

exports.default = dateSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24,"./wv.dateselector.input":16}],16:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var DateInputColumn = function (_React$Component) {
  _inherits(DateInputColumn, _React$Component);

  /*
   * @constructor
   */
  function DateInputColumn(props) {
    _classCallCheck(this, DateInputColumn);

    var _this = _possibleConstructorReturn(this, (DateInputColumn.__proto__ || Object.getPrototypeOf(DateInputColumn)).call(this, props));

    _this.state = {
      value: _this.props.value,
      valid: true
    };
    return _this;
  }

  _createClass(DateInputColumn, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.focused) {
        _reactDom2.default.findDOMNode(this.refs['input-' + this.props.tabIndex]).focus();
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      var size;
      var type;
      type = this.props.type;
      if (type === 'year') {
        size = '4';
      } else if (type === 'day') {
        size = 2;
      } else {
        size = 3;
      }
      this.size = size;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({ value: props.value });
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      var kc = e.keyCode;
      if (kc === 9 || // tab
      kc === 13) {
        //enter
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: 'onKeyUp',
    value: function onKeyUp(e) {
      var keyCode = e.keyCode;
      var value = e.target.value;
      var newDate;
      var entered = keyCode == 13 || keyCode == 9;
      if (keyCode === 38) {
        //up
        e.preventDefault();
        this.onClickUp();
        return;
      }
      if (keyCode === 40) {
        // down
        e.preventDefault();
        this.onClickDown();
        return;
      }
      if (e.type == 'focusout' || entered) {
        if (this.props.type == 'year' || this.props.type == 'day') {
          if (!(keyCode >= 48 && keyCode <= 57 || entered || keyCode == 8)) {
            return;
          }
        }
        switch (this.props.type) {
          case 'year':
            newDate = this.yearValidation(value);
            break;
          case 'day':
            newDate = this.dayValidation(value);
            break;
          case 'month':
            newDate = this.monthValidation(value);
            break;
        }
        if (newDate) {
          this.props.updateDate(newDate);
          if (entered) {
            //if enetered or tabbed
            this.nextTab();
          }
        } else if (entered) {
          this.setState({
            valid: false
          });
        }
      }
    }
  }, {
    key: 'onClickUp',
    value: function onClickUp() {
      this.rollDate(1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'onClickDown',
    value: function onClickDown() {
      this.rollDate(-1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'yearValidation',
    value: function yearValidation(input) {
      var newDate;
      if (input > 1000 && input < 9999) {
        newDate = new Date(new Date(this.props.date).setUTCFullYear(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'dayValidation',
    value: function dayValidation(input) {
      var newDate;
      var maxDate;
      var currentDate = this.props.date;

      maxDate = new Date(currentDate.getYear(), currentDate.getMonth() + 1, 0).getDate();

      if (input > 0 && input <= maxDate) {
        newDate = new Date(new Date(currentDate).setUTCDate(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'rollDate',
    value: function rollDate(amt) {
      var newDate = util.rollDate(this.props.date, this.props.type, amt, this.props.minDate, this.props.maxDate);
      this.props.updateDate(newDate);
    }
  }, {
    key: 'monthValidation',
    value: function monthValidation(input) {
      var newDate;
      if (!isNaN(input) && input < 13 && input > 0) {
        newDate = new Date(new Date(this.props.date).setUTCMonth(input - 1));
        if (newDate) {
          this.setState({
            value: util.monthStringArray[input - 1]
          });
          return this.validateDate(newDate);
        }
      } else {
        var realMonth = void 0;
        realMonth = util.stringInArray(util.monthStringArray, input);
        if (realMonth !== false) {
          newDate = new Date(new Date(this.props.date).setUTCMonth(realMonth));
          return this.validateDate(newDate);
        } else {
          return false;
        }
      }
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({
        value: this.props.value,
        valid: true
      });

      this.props.blur();
    }
  }, {
    key: 'onChange',
    value: function onChange(e) {
      this.setState({
        value: e.target.value.toUpperCase()
      });
    }
  }, {
    key: 'nextTab',
    value: function nextTab() {
      this.props.nextTab(this.props.tabIndex);
    }
  }, {
    key: 'validateDate',
    value: function validateDate(date) {
      if (date > this.props.minDate && date <= this.props.maxDate) {
        this.setState({
          valid: true
        });
        return date;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'input-wrapper', style: this.state.valid ? {} : { borderColor: '#ff0000' } },
        _react2.default.createElement(
          'div',
          { onClick: this.onClickUp.bind(this), className: 'date-arrows date-arrow-up', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'uparrow' })
          )
        ),
        _react2.default.createElement('input', {
          type: 'text',
          ref: 'input-' + this.props.tabIndex,
          size: this.size,
          maxLength: this.size,
          className: 'button-input-group',
          id: this.props.type + '-input-group',
          value: this.state.value,
          tabIndex: this.props.tabIndex,
          onKeyUp: this.onKeyUp.bind(this),
          onKeyDown: this.onKeyPress.bind(this) //currently not working
          , onChange: this.onChange.bind(this),
          style: { fontSize: this.props.height / 2 + 'px' },
          onBlur: this.blur.bind(this)
        }),
        _react2.default.createElement(
          'div',
          { onClick: this.onClickDown.bind(this), className: 'date-arrows date-arrow-down', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'downarrow' })
          )
        )
      );
    }
  }]);

  return DateInputColumn;
}(_react2.default.Component);

exports.default = DateInputColumn;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24}],17:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDom = (typeof window !== "undefined" ? window['ReactDOM'] : typeof global !== "undefined" ? global['ReactDOM'] : null);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var DateInputColumn = function (_React$Component) {
  _inherits(DateInputColumn, _React$Component);

  /*
   * @constructor
   */
  function DateInputColumn(props) {
    _classCallCheck(this, DateInputColumn);

    var _this = _possibleConstructorReturn(this, (DateInputColumn.__proto__ || Object.getPrototypeOf(DateInputColumn)).call(this, props));

    _this.state = {
      value: _this.props.value,
      valid: true
    };
    return _this;
  }

  _createClass(DateInputColumn, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.focused) {
        _reactDom2.default.findDOMNode(this.refs['input-' + this.props.tabIndex]).focus();
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      var size;
      var type;
      type = this.props.type;
      if (type === 'year') {
        size = '4';
      } else if (type === 'day') {
        size = 2;
      } else {
        size = 3;
      }
      this.size = size;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({ value: props.value });
    }
  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      var kc = e.keyCode;
      if (kc === 9 || // tab
      kc === 13) {
        //enter
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: 'onKeyUp',
    value: function onKeyUp(e) {
      var keyCode = e.keyCode;
      var value = e.target.value;
      var newDate;
      var entered = keyCode == 13 || keyCode == 9;
      if (keyCode === 38) {
        //up
        e.preventDefault();
        this.onClickUp();
        return;
      }
      if (keyCode === 40) {
        // down
        e.preventDefault();
        this.onClickDown();
        return;
      }
      if (e.type == 'focusout' || entered) {
        if (this.props.type == 'year' || this.props.type == 'day') {
          if (!(keyCode >= 48 && keyCode <= 57 || entered || keyCode == 8)) {
            return;
          }
        }
        switch (this.props.type) {
          case 'year':
            newDate = this.yearValidation(value);
            break;
          case 'day':
            newDate = this.dayValidation(value);
            break;
          case 'month':
            newDate = this.monthValidation(value);
            break;
        }
        if (newDate) {
          this.props.updateDate(newDate);
          if (entered) {
            //if enetered or tabbed
            this.nextTab();
          }
        } else if (entered) {
          this.setState({
            valid: false
          });
        }
      }
    }
  }, {
    key: 'onClickUp',
    value: function onClickUp() {
      this.rollDate(1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'onClickDown',
    value: function onClickDown() {
      this.rollDate(-1);
      this.setState({
        valid: true
      });
    }
  }, {
    key: 'yearValidation',
    value: function yearValidation(input) {
      var newDate;
      if (input > 1000 && input < 9999) {
        newDate = new Date(new Date(this.props.date).setUTCFullYear(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'dayValidation',
    value: function dayValidation(input) {
      var newDate;
      var maxDate;
      var currentDate = this.props.date;

      maxDate = new Date(currentDate.getYear(), currentDate.getMonth() + 1, 0).getDate();

      if (input > 0 && input <= maxDate) {
        newDate = new Date(new Date(currentDate).setUTCDate(input));
        return this.validateDate(newDate);
      }
    }
  }, {
    key: 'rollDate',
    value: function rollDate(amt) {
      var newDate = util.rollDate(this.props.date, this.props.type, amt, this.props.minDate, this.props.maxDate);
      this.props.updateDate(newDate);
    }
  }, {
    key: 'monthValidation',
    value: function monthValidation(input) {
      var newDate;
      if (!isNaN(input) && input < 13 && input > 0) {
        newDate = new Date(new Date(this.props.date).setUTCMonth(input - 1));
        if (newDate) {
          this.setState({
            value: util.monthStringArray[input - 1]
          });
          return this.validateDate(newDate);
        }
      } else {
        var realMonth = void 0;
        realMonth = util.stringInArray(util.monthStringArray, input);
        if (realMonth !== false) {
          newDate = new Date(new Date(this.props.date).setUTCMonth(realMonth));
          return this.validateDate(newDate);
        } else {
          return false;
        }
      }
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({
        value: this.props.value,
        valid: true
      });

      this.props.blur();
    }
  }, {
    key: 'onChange',
    value: function onChange(e) {
      this.setState({
        value: e.target.value.toUpperCase()
      });
    }
  }, {
    key: 'nextTab',
    value: function nextTab() {
      this.props.nextTab(this.props.tabIndex);
    }
  }, {
    key: 'validateDate',
    value: function validateDate(date) {
      if (date > this.props.minDate && date <= this.props.maxDate) {
        this.setState({
          valid: true
        });
        return date;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'input-wrapper', style: this.state.valid ? {} : { borderColor: '#ff0000' } },
        _react2.default.createElement(
          'div',
          { onClick: this.onClickUp.bind(this), className: 'date-arrows date-arrow-up', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'uparrow' })
          )
        ),
        _react2.default.createElement('input', {
          type: 'text',
          ref: 'input-' + this.props.tabIndex,
          size: this.size,
          maxLength: this.size,
          className: 'button-input-group',
          id: this.props.type + '-input-group',
          value: this.state.value,
          tabIndex: this.props.tabIndex,
          onKeyUp: this.onKeyUp.bind(this),
          onKeyDown: this.onKeyPress.bind(this) //currently not working
          , onChange: this.onChange.bind(this),
          style: { fontSize: this.props.height / 2 + 'px' },
          onBlur: this.blur.bind(this)
        }),
        _react2.default.createElement(
          'div',
          { onClick: this.onClickDown.bind(this), className: 'date-arrows date-arrow-down', 'data-interval': this.props.type },
          _react2.default.createElement(
            'svg',
            { width: '25', height: '8' },
            _react2.default.createElement('path', { d: 'M 12.5,0 25,8 0,8 z', className: 'downarrow' })
          )
        )
      );
    }
  }]);

  return DateInputColumn;
}(_react2.default.Component);

exports.default = DateInputColumn;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24}],18:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvDateselector = require('./wv.dateselector.input');

var _wvDateselector2 = _interopRequireDefault(_wvDateselector);

var _wv = require('../util/wv.utils');

var _wv2 = _interopRequireDefault(_wv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var util = new _wv2.default();

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */

var dateSelector = function (_React$Component) {
  _inherits(dateSelector, _React$Component);

  /*
   * @constructor
   */
  function dateSelector(props) {
    _classCallCheck(this, dateSelector);

    var _this = _possibleConstructorReturn(this, (dateSelector.__proto__ || Object.getPrototypeOf(dateSelector)).call(this, props));

    _this.state = {
      date: props.date,
      maxDate: props.maxDate,
      minDate: props.minDate,
      tab: null
    };
    return _this;
  }

  _createClass(dateSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        date: props.date,
        maxDate: props.maxDate,
        minDate: props.minDate
      });
    }
  }, {
    key: 'blur',
    value: function blur() {
      this.setState({ tab: null });
    }
  }, {
    key: 'nextTab',
    value: function nextTab(index) {
      var nextTab;
      if (index < 3) {
        nextTab = index + 1;
      } else {
        nextTab = 1;
      }
      this.setState({
        tab: nextTab
      });
    }
  }, {
    key: 'updateDate',
    value: function updateDate(date) {
      this.setState({
        date: date
      });
      this.props.onDateChange(this.props.id, date);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wv-date-selector-widget' },
        _react2.default.createElement(_wvDateselector2.default, { startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          value: this.state.date.getUTCFullYear(),
          type: 'year',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          tabIndex: 1,
          focused: this.state.tab == 1,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(), date: this.state.date,
          type: 'month', height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.monthStringArray[this.state.date.getUTCMonth()],
          tabIndex: 2,
          focused: this.state.tab == 2,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        }),
        _react2.default.createElement(_wvDateselector2.default, {
          startDate: new Date(2000),
          today: new Date(),
          date: this.state.date,
          type: 'day',
          height: this.props.height,
          width: this.props.width,
          updateDate: this.updateDate.bind(this),
          value: util.pad(this.state.date.getUTCDate(), 2, '0'),
          tabIndex: 3,
          focused: this.state.tab == 3,
          nextTab: this.nextTab.bind(this),
          maxDate: this.props.maxDate,
          minDate: this.props.minDate,
          blur: this.blur.bind(this)
        })
      );
    }
  }]);

  return dateSelector;
}(_react2.default.Component);

exports.default = dateSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/wv.utils":24,"./wv.dateselector.input":17}],19:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _reactDraggable = require('react-draggable');

var _reactDraggable2 = _interopRequireDefault(_reactDraggable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * group
 *
 * @class TimelineDragger
 * @extends React.Component
 */
var TimelineDragger = function (_React$Component) {
  _inherits(TimelineDragger, _React$Component);

  /*
   * @constructor
   */
  function TimelineDragger(props) {
    _classCallCheck(this, TimelineDragger);

    return _possibleConstructorReturn(this, (TimelineDragger.__proto__ || Object.getPrototypeOf(TimelineDragger)).call(this, props));
  }

  _createClass(TimelineDragger, [{
    key: 'checkVisibility',
    value: function checkVisibility() {
      var visibility = 'visible';
      if (this.props.position < 0 || this.props.position > this.props.max) {
        visibility = 'hidden';
      }
      this.state = {
        visibility: visibility
      };
    }
    /*
     * When the component is dragged,
     * this function passes the id
     * and change-in-x of the drag
     * to onDrag callback
     *
     * @method handleDrag
     *
     * @return {void}
     */

  }, {
    key: 'handleDrag',
    value: function handleDrag(e, d) {
      e.stopPropagation();
      this.props.onDrag(d.deltaX, this.props.id);
    }

    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      this.checkVisibility();
      return _react2.default.createElement(
        _reactDraggable2.default,
        {
          onDrag: this.handleDrag.bind(this),
          position: { x: this.props.position, y: 0 },
          onStop: this.props.onStop,
          axis: 'x'
        },
        _react2.default.createElement(
          'g',
          null,
          _react2.default.createElement('rect', {
            width: this.props.width,
            height: this.props.height,
            style: {
              fill: this.props.color,
              visibility: this.state.visibility
            }
          }),
          _react2.default.createElement('polygon', {
            points: '0,0,' + this.props.height / 1.5 + ',0 ' + this.props.height / 3 + ', ' + this.props.height / 1.5,
            transform: 'translate(' + -(this.props.width * 2.45) + ', ' + -(this.props.height / 2) + ')',
            style: {
              fill: this.props.triangleColor,
              visibility: this.state.visibility,
              stroke: '#000',
              cursor: 'pointer'
            }
          })
        )
      );
    }
  }]);

  return TimelineDragger;
}(_react2.default.Component);

exports.default = TimelineDragger;

TimelineDragger.defaultProps = {
  visible: true
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"react-draggable":1}],20:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * rect element
 *
 * @class TimelineDraggerRange
 */
var TimelineDraggerRange = function (_React$Component) {
  _inherits(TimelineDraggerRange, _React$Component);

  /*
   * @constructor
   */
  function TimelineDraggerRange(props) {
    _classCallCheck(this, TimelineDraggerRange);

    var _this = _possibleConstructorReturn(this, (TimelineDraggerRange.__proto__ || Object.getPrototypeOf(TimelineDraggerRange)).call(this, props));

    _this.opacity = {
      fillOpacity: _this.props.opacity
    };
    return _this;
  }

  _createClass(TimelineDraggerRange, [{
    key: 'checkWidth',
    value: function checkWidth() {
      var start = this.props.startLocation;
      var end = this.props.endLocation;
      var max = this.props.max;
      var width;

      if (start < 0) {
        start = 0;
      }
      if (end > max) {
        end = max;
      }
      width = end - start;
      if (width < 0) {
        width = 0;
      }
      this.state = {
        width: width,
        startLocation: start
      };
    }
    /*
     * When the component is dragged,
     * this function passes the id
     * and change in x of the drag
     * to onDrag property
     *
     * @method handleDrag
     *
     * @return {void}
     */

  }, {
    key: 'handleDrag',
    value: function handleDrag(e, d) {
      e.stopPropagation();
      this.props.onDrag(d.deltaX);
    }

    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      this.checkWidth();
      return _react2.default.createElement('rect', {
        x: this.state.startLocation,
        fill: this.props.color,
        width: this.state.width,
        style: this.opacity,
        height: this.props.height,
        className: 'dragger-range',
        onClick: this.props.onClick
      });
    }
  }]);

  return TimelineDraggerRange;
}(_react2.default.Component);

exports.default = TimelineDraggerRange;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],21:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

var _wvTimelineDragger = require('./wv.timeline.dragger.js');

var _wvTimelineDragger2 = _interopRequireDefault(_wvTimelineDragger);

var _wvTimelineDraggerrange = require('./wv.timeline.draggerrange.js');

var _wvTimelineDraggerrange2 = _interopRequireDefault(_wvTimelineDraggerrange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, is a draggable svg
 * group. It is a parent component that
 * rerenders when child elements are dragged
 *
 * @class TimelineRangeSelector
 */
var TimelineRangeSelector = function (_React$Component) {
  _inherits(TimelineRangeSelector, _React$Component);

  /*
   * @constructor
   */
  function TimelineRangeSelector(props) {
    _classCallCheck(this, TimelineRangeSelector);

    var _this = _possibleConstructorReturn(this, (TimelineRangeSelector.__proto__ || Object.getPrototypeOf(TimelineRangeSelector)).call(this, props));

    _this.state = {
      startLocation: props.startLocation,
      endLocation: props.endLocation,
      max: props.max
    };
    return _this;
  }

  _createClass(TimelineRangeSelector, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.setState({
        startLocation: props.startLocation,
        endLocation: props.endLocation,
        max: props.max
      });
    }
    /*
     * When a child component is dragged,
     * this function is called to determine
     * the correct location for each of the
     * child elements after the drag
     *
     * @method handleDrag
     *
     * @param {number} deltaX - change in x
     * @param {string} id - Identifier used to
     *  distinguish between the child elements
     *
     * @return {void}
     */

  }, {
    key: 'onItemDrag',
    value: function onItemDrag(deltaX, id) {
      var startX;
      var endX;

      if (id === 'start') {
        startX = deltaX + this.state.startLocation;
        endX = this.state.endLocation;
        if (startX < 0 || startX > endX) {
          return;
        }
        if (startX + 2 * this.props.pinWidth >= endX) {
          endX = startX + this.props.pinWidth;
        }
      } else if (id === 'end') {
        startX = this.state.startLocation;
        endX = deltaX + this.state.endLocation;
        if (endX > this.state.max || startX > endX) {
          return;
        }
        if (startX + 2 * this.props.pinWidth >= endX) {
          startX = endX - this.props.pinWidth;
        }
      } else {
        startX = deltaX + this.state.startLocation;
        endX = deltaX + this.state.endLocation;
        if (endX >= this.state.max || startX < 0) {
          return;
        }
      }
      this.props.onDrag(startX, endX);

      this.setState({
        startLocation: startX,
        endLocation: endX
      });
    }

    /*
     * Send callback with new locations on
     * Drag Stop
     *
     * @method onDragStop
     *
     * @return {void}
     */

  }, {
    key: 'onDragStop',
    value: function onDragStop() {
      this.props.onDrag(this.state.startLocation, this.state.endLocation);
    }
  }, {
    key: 'onRangeClick',
    value: function onRangeClick(d) {
      this.props.onRangeClick(d.nativeEvent);
    }
    /*
     * @method render
     */

  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'svg',
        { id: 'wv-timeline-range-selector', className: 'wv-timeline-range-selector' },
        _react2.default.createElement(_wvTimelineDraggerrange2.default, {
          width: this.props.pinWidth,
          endLocation: this.state.endLocation,
          opacity: this.props.rangeOpacity,
          color: this.props.rangeColor,
          height: this.props.height,
          startLocation: this.state.startLocation + this.props.pinWidth,
          onClick: this.onRangeClick.bind(this),
          max: this.state.max,
          id: 'range' }),
        _react2.default.createElement(_wvTimelineDragger2.default, {
          position: this.state.startLocation,
          color: this.props.startColor,
          width: this.props.pinWidth,
          height: this.props.height,
          onDrag: this.onItemDrag.bind(this),
          onStop: this.onDragStop.bind(this),
          max: this.state.max,
          triangleColor: this.props.startTriangleColor,
          first: true,
          id: 'start' }),
        _react2.default.createElement(_wvTimelineDragger2.default, {
          max: this.state.max,
          position: this.state.endLocation,
          color: this.props.endColor,
          width: this.props.pinWidth,
          height: this.props.height,
          first: false,
          onDrag: this.onItemDrag.bind(this),
          onStop: this.onDragStop.bind(this),
          triangleColor: this.props.endTriangleColor,
          id: 'end' })
      );
    }
  }]);

  return TimelineRangeSelector;
}(_react2.default.Component);

exports.default = TimelineRangeSelector;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./wv.timeline.dragger.js":19,"./wv.timeline.draggerrange.js":20}],22:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = (typeof window !== "undefined" ? window['React'] : typeof global !== "undefined" ? global['React'] : null);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * NASA Worldview
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This code was originally developed at NASA/Goddard Space Flight Center for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * the Earth Science Data and Information System (ESDIS) project.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (C) 2013 - 2016 United States Government as represented by the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Administrator of the National Aeronautics and Space Administration.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All Rights Reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the NASA Open Source Agreement, Version 1.3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * http://opensource.gsfc.nasa.gov/nosa.php
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/*
 * A react component, Builds a rather specific
 * interactive widget
 *
 * @class AnimationWidget
 * @extends React.Component
 */
var Tooltip = function (_React$Component) {
  _inherits(Tooltip, _React$Component);

  function Tooltip(props) {
    _classCallCheck(this, Tooltip);

    var _this = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, props));

    _this.state = {
      hovered: false
    };
    return _this;
  }

  _createClass(Tooltip, [{
    key: "mouseOver",
    value: function mouseOver() {
      this.setState({
        hovered: true
      });
    }
  }, {
    key: "mouseOut",
    value: function mouseOut() {
      this.setState({
        hovered: false
      });
    }
  }, {
    key: "onClick",
    value: function onClick(str) {
      this.props.onClick(str);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement(
        "div",
        {
          onMouseEnter: this.mouseOver.bind(this),
          onMouseLeave: this.mouseOut.bind(this),
          className: "wv-tooltip-case" },
        _react2.default.createElement(
          "span",
          null,
          this.props.text
        ),
        _react2.default.createElement(
          "div",
          { className: "wv-tooltip", style: this.state.hovered ? { visibility: 'visible' } : {} },
          _react2.default.createElement(
            "ul",
            null,
            this.props.dataArray.map(function (dataEl, i) {
              return _react2.default.createElement(
                "li",
                { key: 'tooltip-' + dataEl + '-' + i, id: dataEl, onClick: _this2.onClick.bind(_this2, dataEl) },
                dataEl
              );
            })
          )
        )
      );
    }
  }]);

  return Tooltip;
}(_react2.default.Component);

exports.default = Tooltip;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * NASA Worldview
 *
 * This code was originally developed at NASA/Goddard Space Flight Center for
 * the Earth Science Data and Information System (ESDIS) project.
 *
 * Copyright (C) 2013 - 2016 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 */

/* global ga:true */

exports.default = {
  /**
   * Initialize GA tracking if tracking
   * code is present
   *
   * @func init
   * @static
   *
   * @param Category {id} GA tracking code
   *
   * @return {void}
   */
  init: function init(id) {
    if (id) {
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments);
        }, i[r].l = 1 * new Date();
        a = s.createElement(o), m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
      ga('create', id, 'auto');
      ga('send', 'pageview');
    }
  },

  /**
   * @func TrackEventGA
   * @static
   *
   * @param Category {string} Event group name
   * @param Action {string} Type of user interaction
   * @param Label {string} Optional string for better
   *     verification of the event
   * @param Value {number} Optional number to associate
   *     with event
   *
    * @return {void}
   */
  event: function event(category, action, label, value) {
    if (typeof ga !== "undefined") {
      ga('send', 'event', category, action, label, value);
    }
  }
};

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * NASA Worldview
 *
 * This code was originally developed at NASA/Goddard Space Flight Center for
 * the Earth Science Data and Information System (ESDIS) project.
 *
 * Copyright (C) 2013 - 2016 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 *
 * Licensed under the NASA Open Source Agreement, Version 1.3
 * http://opensource.gsfc.nasa.gov/nosa.php
 */

var Utils = function () {
  /*
   * @constructor
   */
  function Utils() {
    _classCallCheck(this, Utils);

    this.monthStringArray = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
  }
  /**
   * Gets the current day. Use this instead of the Date methods to allow
   * debugging alternate "now" times.
   *
   * @method today
   * @static
   * @return {Date} The current time with the UTC hours, minutes, and seconds
   * fields set to zero or an overriden value.
   */


  _createClass(Utils, [{
    key: "today",
    value: function today() {
      return this.clearTimeUTC(this.now());
    }

    /**
     * Sets a date to UTC midnight.
     *
     * @method clearTimeUTC
     * @static
     * @param date {Date} date to set the UTC hours, minutes, and seconds
     * to zero.
     * @return {Date} the date object
     */

  }, {
    key: "clearTimeUTC",
    value: function clearTimeUTC(date) {
      date.setUTCHours(0);
      date.setUTCMinutes(0);
      date.setUTCSeconds(0);
      date.setUTCMilliseconds(0);
      return date;
    }
  }, {
    key: "clamp",
    value: function clamp(val, min, max) {
      if (val < min) {
        return min;
      }
      if (val > max) {
        return max;
      }
      return val;
    }
  }, {
    key: "daysInMonth",
    value: function daysInMonth(d) {
      var y;
      var m;
      if (d.getUTCFullYear) {
        y = d.getUTCFullYear();
        m = d.getUTCMonth();
      } else {
        y = d.year;
        m = d.month;
      }
      var lastDay = new Date(Date.UTC(y, m + 1, 0));
      return lastDay.getUTCDate();
    }
    /**
     * Gets the current time. Use this instead of the Date methods to allow
     * debugging alternate "now" times.
     *
     * @method now
     * @static
     * @return {Date} The current time or an overriden value.
     */

  }, {
    key: "now",
    value: function now() {
      return new Date();
    }
  }, {
    key: "stringInArray",
    value: function stringInArray(arra, value) {
      for (var i = 0, len = arra.length; i < len; i++) {
        if (arra[i] === value) {
          return i;
        }
      }
      return false;
    }
  }, {
    key: "minDate",
    value: function minDate() {
      return new Date(Date.UTC(1000, 0, 1));
    }
  }, {
    key: "maxDate",
    value: function maxDate() {
      return new Date(Date.UTC(3000, 11, 31));
    }
    /**
     * Parses a UTC ISO 8601 date.
     *
     * @method parseDateUTC
     * @static
     * @param str {string} Date to parse in the form of ``YYYY-MM-DD``.
     * @return {Date} converted string as a date object, throws an exception if
     * the string is invalid
     */
    // NOTE: Older Safari doesn't like Date.parse

  }, {
    key: "parseDateUTC",
    value: function parseDateUTC(dateAsString) {
      var dateTimeArr = dateAsString.split(/T/);
      var yyyymmdd = dateTimeArr[0].split('-');

      // Parse elements of date and time
      var year = yyyymmdd[0];
      var month = yyyymmdd[1] - 1;
      var day = yyyymmdd[2];

      var hour = 0;
      var minute = 0;
      var second = 0;
      var millisecond = 0;

      // Use default of midnight if time is not specified
      if (dateTimeArr.length > 1) {
        var hhmmss = dateTimeArr[1].split(/[:\.Z]/);
        hour = hhmmss[0] || 0;
        minute = hhmmss[1] || 0;
        second = hhmmss[2] || 0;
        millisecond = hhmmss[3] || 0;
      }
      var date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      if (isNaN(date.getTime())) {
        throw new Error('Invalid date: ' + dateAsString);
      }
      return date;
    }
  }, {
    key: "repeat",
    value: function repeat(value, length) {
      var result = "";
      for (var i = 0; i < length; i++) {
        result += value;
      }
      return result;
    }
  }, {
    key: "roll",
    value: function roll(val, min, max) {
      if (val < min) {
        return max - (min - val) + 1;
      }
      if (val > max) {
        return min + (val - max) - 1;
      }
      return val;
    }
  }, {
    key: "rollRange",
    value: function rollRange(date, interval, minDate, maxDate) {
      var y = date.getUTCFullYear();
      var m = date.getUTCMonth();
      var first, last;
      switch (interval) {
        case "day":
          var firstDay = new Date(Date.UTC(y, m, 1));
          var lastDay = new Date(Date.UTC(y, m, this.daysInMonth(date)));
          first = new Date(Math.max(firstDay, minDate)).getUTCDate();
          last = new Date(Math.min(lastDay, maxDate)).getUTCDate();
          break;
        case "month":
          var firstMonth = new Date(Date.UTC(y, 0, 1));
          var lastMonth = new Date(Date.UTC(y, 11, 31));
          first = new Date(Math.max(firstMonth, minDate)).getUTCMonth();
          last = new Date(Math.min(lastMonth, maxDate)).getUTCMonth();
          break;
        case "year":
          var firstYear = this.minDate();
          var lastYear = this.maxDate();
          first = new Date(Math.max(firstYear, minDate)).getUTCFullYear();
          last = new Date(Math.min(lastYear, maxDate)).getUTCFullYear();
          break;
      }
      return { first: first, last: last };
    }
  }, {
    key: "rollDate",
    value: function rollDate(date, interval, amount, minDate, maxDate) {
      minDate = minDate || this.minDate();
      maxDate = maxDate || this.maxDate();
      var range = this.rollRange(date, interval, minDate, maxDate);
      var min = range.first;
      var max = range.last;
      var day = date.getUTCDate();
      var month = date.getUTCMonth();
      var year = date.getUTCFullYear();
      switch (interval) {
        case "day":
          day = this.roll(day + amount, min, max);
          break;
        case "month":
          month = this.roll(month + amount, min, max);
          break;
        case "year":
          year = this.roll(year + amount, min, max);
          break;
        default:
          throw new Error("[rollDate] Invalid interval: " + interval);
      }
      var daysInMonth = this.daysInMonth({ year: year, month: month });
      if (day > daysInMonth) {
        day = daysInMonth;
      }
      var newDate = new Date(Date.UTC(year, month, day));
      newDate = new Date(this.clamp(newDate, minDate, maxDate));
      return newDate;
    }
  }, {
    key: "pad",
    value: function pad(value, width, padding) {
      value = "" + value;
      if (value.length < width) {
        var add = width - value.length;
        value = this.repeat(padding, add) + value;
      }
      return value;
    }
  }]);

  return Utils;
}();

exports.default = Utils;

},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wvAnimationWidget = require('./components/animationwidget/wv.animation.widget.js');

Object.defineProperty(exports, 'AnimationWidget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvAnimationWidget).default;
  }
});

var _wvTimelineRangeselection = require('./components/rangeselection/wv.timeline.rangeselection.js');

Object.defineProperty(exports, 'RangeSelector', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvTimelineRangeselection).default;
  }
});

var _wvDateSelector = require('./components/dateSelector/wv.dateSelector.js');

Object.defineProperty(exports, 'DateSelector', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvDateSelector).default;
  }
});

var _wvTooltip = require('./components/tooltip/wv.tooltip.js');

Object.defineProperty(exports, 'ToolTip', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvTooltip).default;
  }
});

var _wvUtils = require('./components/util/wv.utils.js');

Object.defineProperty(exports, 'Utils', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvUtils).default;
  }
});

var _wvGoogleAnalytics = require('./components/util/wv.googleAnalytics.js');

Object.defineProperty(exports, 'GA', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_wvGoogleAnalytics).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./components/animationwidget/wv.animation.widget.js":12,"./components/dateSelector/wv.dateSelector.js":15,"./components/rangeselection/wv.timeline.rangeselection.js":21,"./components/tooltip/wv.tooltip.js":22,"./components/util/wv.googleAnalytics.js":23,"./components/util/wv.utils.js":24}]},{},[25])(25)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2Rpc3QvcmVhY3QtZHJhZ2dhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL0lucHV0UmFuZ2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtcmFuZ2UvbGliL0lucHV0UmFuZ2UvTGFiZWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtcmFuZ2UvbGliL0lucHV0UmFuZ2UvU2xpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL1RyYWNrLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL2RlZmF1bHRDbGFzc05hbWVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL3Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1pbnB1dC1yYW5nZS9saWIvSW5wdXRSYW5nZS91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LXJhbmdlL2xpYi9JbnB1dFJhbmdlL3ZhbHVlVHJhbnNmb3JtZXIuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5hbmltYXRpb24ud2lkZ2V0LmhlYWRlci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvYW5pbWF0aW9ud2lkZ2V0L3d2LmFuaW1hdGlvbi53aWRnZXQuanMiLCJzcmMvc2NyaXB0cy9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5sb29wYnV0dG9uLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy9hbmltYXRpb253aWRnZXQvd3YucGxheWJ1dHRvbi5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZVNlbGVjdG9yL3d2LmRhdGVTZWxlY3Rvci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZVNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5pbnB1dC5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZXNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5pbnB1dC5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvZGF0ZXNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUuZHJhZ2dlci5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUuZHJhZ2dlcnJhbmdlLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy9yYW5nZXNlbGVjdGlvbi93di50aW1lbGluZS5yYW5nZXNlbGVjdGlvbi5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvdG9vbHRpcC93di50b29sdGlwLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy91dGlsL3d2Lmdvb2dsZUFuYWx5dGljcy5qcyIsInNyYy9zY3JpcHRzL2NvbXBvbmVudHMvdXRpbC93di51dGlscy5qcyIsInNyYy9zY3JpcHRzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdGtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3B3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QkFBVSxJQUFJLElBQUosQ0FBUyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEVBQW9CLE9BQXBCLEVBQTZCLE9BQTdCLENBQVQsQ0FBVjtBQUNBLGFBQU8sT0FBUDtBQUNEOzs7d0JBQ0csSyxFQUFPLEssRUFBTyxPLEVBQVM7QUFDekIsY0FBUSxLQUFLLEtBQWI7QUFDQSxVQUFHLE1BQU0sTUFBTixHQUFlLEtBQWxCLEVBQXlCO0FBQ3ZCLFlBQUksTUFBTSxRQUFRLE1BQU0sTUFBeEI7QUFDQSxnQkFBUSxLQUFLLE1BQUwsQ0FBWSxPQUFaLEVBQXFCLEdBQXJCLElBQTRCLEtBQXBDO0FBQ0Q7QUFDRCxhQUFPLEtBQVA7QUFDRDs7Ozs7O2tCQWxNa0IsSzs7Ozs7Ozs7Ozs7Ozs7c0RDSGIsTzs7Ozs7Ozs7OzZEQUNBLE87Ozs7Ozs7OzttREFDQSxPOzs7Ozs7Ozs7OENBQ0EsTzs7Ozs7Ozs7OzRDQUNBLE87Ozs7Ozs7OztzREFDQSxPIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCksICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydSZWFjdERPTSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnUmVhY3RET00nXSA6IG51bGwpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QtZG9tXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJlYWN0RHJhZ2dhYmxlXCJdID0gZmFjdG9yeSgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snUmVhY3QnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ1JlYWN0J10gOiBudWxsKSwgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0RE9NJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdERPTSddIDogbnVsbCkpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJlYWN0RHJhZ2dhYmxlXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0sIHJvb3RbXCJSZWFjdERPTVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5kZWZhdWx0O1xuXHRtb2R1bGUuZXhwb3J0cy5EcmFnZ2FibGVDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5kZWZhdWx0O1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXHRcblx0dmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cdFxuXHR2YXIgX3JlYWN0RG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXHRcblx0dmFyIF9jbGFzc25hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdHZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblx0XG5cdHZhciBfZG9tRm5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfcG9zaXRpb25GbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9zaGltcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHR2YXIgX0RyYWdnYWJsZUNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcblx0dmFyIF9EcmFnZ2FibGVDb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZUNvcmUpO1xuXHRcblx0dmFyIF9sb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0XG5cdHZhciBfbG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHRmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblx0XG5cdGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXHQvLyAkRmxvd0lnbm9yZVxuXHRcblx0XG5cdC8qOjogaW1wb3J0IHR5cGUge0RyYWdnYWJsZUV2ZW50SGFuZGxlcn0gZnJvbSAnLi91dGlscy90eXBlcyc7Ki9cblx0Lyo6OiB0eXBlIERyYWdnYWJsZVN0YXRlID0ge1xuXHQgIGRyYWdnaW5nOiBib29sZWFuLFxuXHQgIGRyYWdnZWQ6IGJvb2xlYW4sXG5cdCAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG5cdCAgc2xhY2tYOiBudW1iZXIsIHNsYWNrWTogbnVtYmVyLFxuXHQgIGlzRWxlbWVudFNWRzogYm9vbGVhblxuXHR9OyovXG5cdFxuXHRcblx0Ly9cblx0Ly8gRGVmaW5lIDxEcmFnZ2FibGU+XG5cdC8vXG5cdFxuXHQvKjo6IHR5cGUgQ29uc3RydWN0b3JQcm9wcyA9IHtcblx0ICBwb3NpdGlvbjogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9LFxuXHQgIGRlZmF1bHRQb3NpdGlvbjogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9XG5cdH07Ki9cblx0XG5cdHZhciBEcmFnZ2FibGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhEcmFnZ2FibGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXHRcblx0ICBmdW5jdGlvbiBEcmFnZ2FibGUocHJvcHMgLyo6IENvbnN0cnVjdG9yUHJvcHMqLykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnYWJsZSk7XG5cdFxuXHQgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyYWdnYWJsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyYWdnYWJsZSkpLmNhbGwodGhpcywgcHJvcHMpKTtcblx0XG5cdCAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBjb3JlRGF0YSkge1xuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnU3RhcnQ6ICVqJywgY29yZURhdGEpO1xuXHRcblx0ICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuXHQgICAgICB2YXIgc2hvdWxkU3RhcnQgPSBfdGhpcy5wcm9wcy5vblN0YXJ0KGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX3RoaXMsIGNvcmVEYXRhKSk7XG5cdCAgICAgIC8vIEtpbGxzIHN0YXJ0IGV2ZW50IG9uIGNvcmUgYXMgd2VsbCwgc28gbW92ZSBoYW5kbGVycyBhcmUgbmV2ZXIgYm91bmQuXG5cdCAgICAgIGlmIChzaG91bGRTdGFydCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0XG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dpbmc6IHRydWUsIGRyYWdnZWQ6IHRydWUgfSk7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLm9uRHJhZyA9IGZ1bmN0aW9uIChlLCBjb3JlRGF0YSkge1xuXHQgICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICgwLCBfbG9nMi5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWc6ICVqJywgY29yZURhdGEpO1xuXHRcblx0ICAgICAgdmFyIHVpRGF0YSA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkoX3RoaXMsIGNvcmVEYXRhKTtcblx0XG5cdCAgICAgIHZhciBuZXdTdGF0ZSAvKjogJFNoYXBlPERyYWdnYWJsZVN0YXRlPiovID0ge1xuXHQgICAgICAgIHg6IHVpRGF0YS54LFxuXHQgICAgICAgIHk6IHVpRGF0YS55XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICAvLyBLZWVwIHdpdGhpbiBib3VuZHMuXG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5ib3VuZHMpIHtcblx0ICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIHggYW5kIHkuXG5cdCAgICAgICAgdmFyIF94ID0gbmV3U3RhdGUueCxcblx0ICAgICAgICAgICAgX3kgPSBuZXdTdGF0ZS55O1xuXHRcblx0ICAgICAgICAvLyBBZGQgc2xhY2sgdG8gdGhlIHZhbHVlcyB1c2VkIHRvIGNhbGN1bGF0ZSBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGlmXG5cdCAgICAgICAgLy8gd2Ugc3RhcnQgcmVtb3Zpbmcgc2xhY2ssIHRoZSBlbGVtZW50IHdvbid0IHJlYWN0IHRvIGl0IHJpZ2h0IGF3YXkgdW50aWwgaXQncyBiZWVuXG5cdCAgICAgICAgLy8gY29tcGxldGVseSByZW1vdmVkLlxuXHRcblx0ICAgICAgICBuZXdTdGF0ZS54ICs9IF90aGlzLnN0YXRlLnNsYWNrWDtcblx0ICAgICAgICBuZXdTdGF0ZS55ICs9IF90aGlzLnN0YXRlLnNsYWNrWTtcblx0XG5cdCAgICAgICAgLy8gR2V0IGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgY2VpbC9mbG9vciB0aGUgeCBhbmQgeSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuXG5cdCAgICAgICAgLy8gJEZsb3dCdWdcblx0XG5cdCAgICAgICAgLy8gUmVjYWxjdWxhdGUgc2xhY2sgYnkgbm90aW5nIGhvdyBtdWNoIHdhcyBzaGF2ZWQgYnkgdGhlIGJvdW5kUG9zaXRpb24gaGFuZGxlci5cblx0ICAgICAgICB2YXIgX2dldEJvdW5kUG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldEJvdW5kUG9zaXRpb24pKF90aGlzLCBuZXdTdGF0ZS54LCBuZXdTdGF0ZS55KTtcblx0XG5cdCAgICAgICAgdmFyIF9nZXRCb3VuZFBvc2l0aW9uMiA9IF9zbGljZWRUb0FycmF5KF9nZXRCb3VuZFBvc2l0aW9uLCAyKTtcblx0XG5cdCAgICAgICAgbmV3U3RhdGUueCA9IF9nZXRCb3VuZFBvc2l0aW9uMlswXTtcblx0ICAgICAgICBuZXdTdGF0ZS55ID0gX2dldEJvdW5kUG9zaXRpb24yWzFdO1xuXHQgICAgICAgIG5ld1N0YXRlLnNsYWNrWCA9IF90aGlzLnN0YXRlLnNsYWNrWCArIChfeCAtIG5ld1N0YXRlLngpO1xuXHQgICAgICAgIG5ld1N0YXRlLnNsYWNrWSA9IF90aGlzLnN0YXRlLnNsYWNrWSArIChfeSAtIG5ld1N0YXRlLnkpO1xuXHRcblx0ICAgICAgICAvLyBVcGRhdGUgdGhlIGV2ZW50IHdlIGZpcmUgdG8gcmVmbGVjdCB3aGF0IHJlYWxseSBoYXBwZW5lZCBhZnRlciBib3VuZHMgdG9vayBlZmZlY3QuXG5cdCAgICAgICAgdWlEYXRhLnggPSBfeDtcblx0ICAgICAgICB1aURhdGEueSA9IF95O1xuXHQgICAgICAgIHVpRGF0YS5kZWx0YVggPSBuZXdTdGF0ZS54IC0gX3RoaXMuc3RhdGUueDtcblx0ICAgICAgICB1aURhdGEuZGVsdGFZID0gbmV3U3RhdGUueSAtIF90aGlzLnN0YXRlLnk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cblx0ICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uRHJhZyhlLCB1aURhdGEpO1xuXHQgICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuXHQgICAgfTtcblx0XG5cdCAgICBfdGhpcy5vbkRyYWdTdG9wID0gZnVuY3Rpb24gKGUsIGNvcmVEYXRhKSB7XG5cdCAgICAgIGlmICghX3RoaXMuc3RhdGUuZHJhZ2dpbmcpIHJldHVybiBmYWxzZTtcblx0XG5cdCAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cblx0ICAgICAgdmFyIHNob3VsZFN0b3AgPSBfdGhpcy5wcm9wcy5vblN0b3AoZSwgKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKShfdGhpcywgY29yZURhdGEpKTtcblx0ICAgICAgaWYgKHNob3VsZFN0b3AgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdFxuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnU3RvcDogJWonLCBjb3JlRGF0YSk7XG5cdFxuXHQgICAgICB2YXIgbmV3U3RhdGUgLyo6ICRTaGFwZTxEcmFnZ2FibGVTdGF0ZT4qLyA9IHtcblx0ICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdCAgICAgICAgc2xhY2tYOiAwLFxuXHQgICAgICAgIHNsYWNrWTogMFxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgY29tcG9uZW50LCB0aGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uIHdpbGwgYmUgdG9cblx0ICAgICAgLy8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9sZCBwb3NpdGlvbi4gV2UgZXhwZWN0IGEgaGFuZGxlciBvbiBgb25EcmFnU3RvcGAsIGF0IHRoZSBsZWFzdC5cblx0ICAgICAgdmFyIGNvbnRyb2xsZWQgPSBCb29sZWFuKF90aGlzLnByb3BzLnBvc2l0aW9uKTtcblx0ICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMkcHJvcHMkcG9zaXRpb24gPSBfdGhpcy5wcm9wcy5wb3NpdGlvbixcblx0ICAgICAgICAgICAgX3gyID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ueCxcblx0ICAgICAgICAgICAgX3kyID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ueTtcblx0XG5cdCAgICAgICAgbmV3U3RhdGUueCA9IF94Mjtcblx0ICAgICAgICBuZXdTdGF0ZS55ID0gX3kyO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG5cdCAgICB9O1xuXHRcblx0ICAgIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nLlxuXHQgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdFxuXHQgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGJlZW4gZHJhZ2dlZCBiZWZvcmUuXG5cdCAgICAgIGRyYWdnZWQ6IGZhbHNlLFxuXHRcblx0ICAgICAgLy8gQ3VycmVudCB0cmFuc2Zvcm0geCBhbmQgeS5cblx0ICAgICAgeDogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi54IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLngsXG5cdCAgICAgIHk6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueSA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi55LFxuXHRcblx0ICAgICAgLy8gVXNlZCBmb3IgY29tcGVuc2F0aW5nIGZvciBvdXQtb2YtYm91bmRzIGRyYWdzXG5cdCAgICAgIHNsYWNrWDogMCwgc2xhY2tZOiAwLFxuXHRcblx0ICAgICAgLy8gQ2FuIG9ubHkgZGV0ZXJtaW5lIGlmIFNWRyBhZnRlciBtb3VudGluZ1xuXHQgICAgICBpc0VsZW1lbnRTVkc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKERyYWdnYWJsZSwgW3tcblx0ICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuXHQgICAgICBpZiAodGhpcy5wcm9wcy5wb3NpdGlvbiAmJiAhKHRoaXMucHJvcHMub25EcmFnIHx8IHRoaXMucHJvcHMub25TdG9wKSkge1xuXHQgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXHQgICAgICAgIGNvbnNvbGUud2FybignQSBgcG9zaXRpb25gIHdhcyBhcHBsaWVkIHRvIHRoaXMgPERyYWdnYWJsZT4sIHdpdGhvdXQgZHJhZyBoYW5kbGVycy4gVGhpcyB3aWxsIG1ha2UgdGhpcyAnICsgJ2NvbXBvbmVudCBlZmZlY3RpdmVseSB1bmRyYWdnYWJsZS4gUGxlYXNlIGF0dGFjaCBgb25EcmFnYCBvciBgb25TdG9wYCBoYW5kbGVycyBzbyB5b3UgY2FuIGFkanVzdCB0aGUgJyArICdgcG9zaXRpb25gIG9mIHRoaXMgZWxlbWVudC4nKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcblx0ICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpcyBhbiBpbnN0YW5jZW9mIFNWR0VsZW1lbnRcblx0ICAgICAgaWYgKHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcykgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG5cdCAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzRWxlbWVudFNWRzogdHJ1ZSB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzIC8qOiBPYmplY3QqLykge1xuXHQgICAgICAvLyBTZXQgeC95IGlmIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAgICAgIGlmIChuZXh0UHJvcHMucG9zaXRpb24gJiYgKCF0aGlzLnByb3BzLnBvc2l0aW9uIHx8IG5leHRQcm9wcy5wb3NpdGlvbi54ICE9PSB0aGlzLnByb3BzLnBvc2l0aW9uLnggfHwgbmV4dFByb3BzLnBvc2l0aW9uLnkgIT09IHRoaXMucHJvcHMucG9zaXRpb24ueSkpIHtcblx0ICAgICAgICB0aGlzLnNldFN0YXRlKHsgeDogbmV4dFByb3BzLnBvc2l0aW9uLngsIHk6IG5leHRQcm9wcy5wb3NpdGlvbi55IH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgICB0aGlzLnNldFN0YXRlKHsgZHJhZ2dpbmc6IGZhbHNlIH0pOyAvLyBwcmV2ZW50cyBpbnZhcmlhbnQgaWYgdW5tb3VudGVkIHdoaWxlIGRyYWdnaW5nXG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAncmVuZGVyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki8ge1xuXHQgICAgICB2YXIgX2NsYXNzTmFtZXM7XG5cdFxuXHQgICAgICB2YXIgc3R5bGUgPSB7fSxcblx0ICAgICAgICAgIHN2Z1RyYW5zZm9ybSA9IG51bGw7XG5cdFxuXHQgICAgICAvLyBJZiB0aGlzIGlzIGNvbnRyb2xsZWQsIHdlIGRvbid0IHdhbnQgdG8gbW92ZSBpdCAtIHVubGVzcyBpdCdzIGRyYWdnaW5nLlxuXHQgICAgICB2YXIgY29udHJvbGxlZCA9IEJvb2xlYW4odGhpcy5wcm9wcy5wb3NpdGlvbik7XG5cdCAgICAgIHZhciBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuXHRcblx0ICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wcm9wcy5wb3NpdGlvbiB8fCB0aGlzLnByb3BzLmRlZmF1bHRQb3NpdGlvbjtcblx0ICAgICAgdmFyIHRyYW5zZm9ybU9wdHMgPSB7XG5cdCAgICAgICAgLy8gU2V0IGxlZnQgaWYgaG9yaXpvbnRhbCBkcmFnIGlzIGVuYWJsZWRcblx0ICAgICAgICB4OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdYKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnggOiBwb3NpdGlvbi54LFxuXHRcblx0ICAgICAgICAvLyBTZXQgdG9wIGlmIHZlcnRpY2FsIGRyYWcgaXMgZW5hYmxlZFxuXHQgICAgICAgIHk6ICgwLCBfcG9zaXRpb25GbnMuY2FuRHJhZ1kpKHRoaXMpICYmIGRyYWdnYWJsZSA/IHRoaXMuc3RhdGUueSA6IHBvc2l0aW9uLnlcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cblx0ICAgICAgaWYgKHRoaXMuc3RhdGUuaXNFbGVtZW50U1ZHKSB7XG5cdCAgICAgICAgc3ZnVHJhbnNmb3JtID0gKDAsIF9kb21GbnMuY3JlYXRlU1ZHVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBBZGQgYSBDU1MgdHJhbnNmb3JtIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kLiBUaGlzIGFsbG93cyB1cyB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZFxuXHQgICAgICAgIC8vIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgd2hldGhlciBvciBub3QgaXQgaXMgcmVsYXRpdmVseSBvciBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQuXG5cdCAgICAgICAgLy8gSWYgdGhlIGl0ZW0geW91IGFyZSBkcmFnZ2luZyBhbHJlYWR5IGhhcyBhIHRyYW5zZm9ybSBzZXQsIHdyYXAgaXQgaW4gYSA8c3Bhbj4gc28gPERyYWdnYWJsZT5cblx0ICAgICAgICAvLyBoYXMgYSBjbGVhbiBzbGF0ZS5cblx0ICAgICAgICBzdHlsZSA9ICgwLCBfZG9tRm5zLmNyZWF0ZUNTU1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuXHQgICAgICAgICAgZGVmYXVsdENsYXNzTmFtZSA9IF9wcm9wcy5kZWZhdWx0Q2xhc3NOYW1lLFxuXHQgICAgICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nID0gX3Byb3BzLmRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyxcblx0ICAgICAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkID0gX3Byb3BzLmRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkO1xuXHRcblx0ICAgICAgLy8gTWFyayB3aXRoIGNsYXNzIHdoaWxlIGRyYWdnaW5nXG5cdFxuXHQgICAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh0aGlzLnByb3BzLmNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSB8fCAnJywgZGVmYXVsdENsYXNzTmFtZSwgKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLCB0aGlzLnN0YXRlLmRyYWdnaW5nKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZCwgdGhpcy5zdGF0ZS5kcmFnZ2VkKSwgX2NsYXNzTmFtZXMpKTtcblx0XG5cdCAgICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuXHQgICAgICAvLyBUaGlzIG1ha2VzIGl0IGZsZXhpYmxlIHRvIHVzZSB3aGF0ZXZlciBlbGVtZW50IGlzIHdhbnRlZCAoZGl2LCB1bCwgZXRjKVxuXHQgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG5cdCAgICAgICAgX0RyYWdnYWJsZUNvcmUyLmRlZmF1bHQsXG5cdCAgICAgICAgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCwgb25EcmFnOiB0aGlzLm9uRHJhZywgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3AgfSksXG5cdCAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwge1xuXHQgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG5cdCAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHRoaXMucHJvcHMuY2hpbGRyZW4ucHJvcHMuc3R5bGUsIHN0eWxlKSxcblx0ICAgICAgICAgIHRyYW5zZm9ybTogc3ZnVHJhbnNmb3JtXG5cdCAgICAgICAgfSlcblx0ICAgICAgKTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBEcmFnZ2FibGU7XG5cdH0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cdFxuXHREcmFnZ2FibGUuZGlzcGxheU5hbWUgPSAnRHJhZ2dhYmxlJztcblx0RHJhZ2dhYmxlLnByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBfRHJhZ2dhYmxlQ29yZTIuZGVmYXVsdC5wcm9wVHlwZXMsIHtcblx0XG5cdCAgLyoqXG5cdCAgICogYGF4aXNgIGRldGVybWluZXMgd2hpY2ggYXhpcyB0aGUgZHJhZ2dhYmxlIGNhbiBtb3ZlLlxuXHQgICAqXG5cdCAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcblx0ICAgKiAgY29udHJvbHMgZmx1c2hpbmcgdG8gdGhlIERPTS5cblx0ICAgKlxuXHQgICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuXHQgICAqICd4JyBsaW1pdHMgbW92ZW1lbnQgdG8gaG9yaXpvbnRhbCBheGlzLlxuXHQgICAqICd5JyBsaW1pdHMgbW92ZW1lbnQgdG8gdmVydGljYWwgYXhpcy5cblx0ICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cblx0ICAgKlxuXHQgICAqIERlZmF1bHRzIHRvICdib3RoJy5cblx0ICAgKi9cblx0ICBheGlzOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcblx0XG5cdCAgLyoqXG5cdCAgICogYGJvdW5kc2AgZGV0ZXJtaW5lcyB0aGUgcmFuZ2Ugb2YgbW92ZW1lbnQgYXZhaWxhYmxlIHRvIHRoZSBlbGVtZW50LlxuXHQgICAqIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOlxuXHQgICAqXG5cdCAgICogJ3BhcmVudCcgcmVzdHJpY3RzIG1vdmVtZW50IHdpdGhpbiB0aGUgRHJhZ2dhYmxlJ3MgcGFyZW50IG5vZGUuXG5cdCAgICpcblx0ICAgKiBBbHRlcm5hdGl2ZWx5LCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgYWxsIG9mIHdoaWNoIGFyZSBvcHRpb25hbDpcblx0ICAgKlxuXHQgICAqIHtsZWZ0OiBMRUZUX0JPVU5ELCByaWdodDogUklHSFRfQk9VTkQsIGJvdHRvbTogQk9UVE9NX0JPVU5ELCB0b3A6IFRPUF9CT1VORH1cblx0ICAgKlxuXHQgICAqIEFsbCB2YWx1ZXMgYXJlIGluIHB4LlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGJvdW5kcz17e3JpZ2h0OiAzMDAsIGJvdHRvbTogMzAwfX0+XG5cdCAgICogICAgICAgICAgICAgIDxkaXY+Q29udGVudDwvZGl2PlxuXHQgICAqICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICk7XG5cdCAgICogICAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICogYGBgXG5cdCAgICovXG5cdCAgYm91bmRzOiBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG5cdCAgICBsZWZ0OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHJpZ2h0OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHRvcDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIsXG5cdCAgICBib3R0b206IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG5cdCAgfSksIF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mKFtmYWxzZV0pXSksXG5cdFxuXHQgIGRlZmF1bHRDbGFzc05hbWU6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuXHQgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogX3JlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG5cdCAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuXHRcblx0ICAvKipcblx0ICAgKiBgZGVmYXVsdFBvc2l0aW9uYCBzcGVjaWZpZXMgdGhlIHggYW5kIHkgdGhhdCB0aGUgZHJhZ2dlZCBpdGVtIHNob3VsZCBzdGFydCBhdFxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcblx0ICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgZGVmYXVsdFBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuXHQgICAqICAgICAgICAgICAgICApO1xuXHQgICAqICAgICAgICAgIH1cblx0ICAgKiAgICAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIGRlZmF1bHRQb3NpdGlvbjogX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG5cdCAgICB4OiBfcmVhY3QuUHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHk6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG5cdCAgfSksXG5cdFxuXHQgIC8qKlxuXHQgICAqIGBwb3NpdGlvbmAsIGlmIHByZXNlbnQsIGRlZmluZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG5cdCAgICpcblx0ICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG5cdCAgICogIGlzIHVuY29udHJvbGxlZC5cblx0ICAgKlxuXHQgICAqIEV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiBgYGBqc3hcblx0ICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICogICAgICAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuXHQgICAqICAgICAgICAgICAgICApO1xuXHQgICAqICAgICAgICAgIH1cblx0ICAgKiAgICAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIHBvc2l0aW9uOiBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcblx0ICAgIHg6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuXHQgICAgeTogX3JlYWN0LlByb3BUeXBlcy5udW1iZXJcblx0ICB9KSxcblx0XG5cdCAgLyoqXG5cdCAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgY2hpbGQsIG5vdCBoZXJlLlxuXHQgICAqL1xuXHQgIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcblx0ICBzdHlsZTogX3NoaW1zLmRvbnRTZXRNZSxcblx0ICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcblx0fSk7XG5cdERyYWdnYWJsZS5kZWZhdWx0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgX0RyYWdnYWJsZUNvcmUyLmRlZmF1bHQuZGVmYXVsdFByb3BzLCB7XG5cdCAgYXhpczogJ2JvdGgnLFxuXHQgIGJvdW5kczogZmFsc2UsXG5cdCAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG5cdCAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nJyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2VkJyxcblx0ICBkZWZhdWx0UG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuXHQgIHBvc2l0aW9uOiBudWxsXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fO1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiFcblx0ICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cblx0ICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHQgIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcblx0Ki9cblx0LyogZ2xvYmFsIGRlZmluZSAqL1xuXHRcblx0KGZ1bmN0aW9uICgpIHtcblx0XHQndXNlIHN0cmljdCc7XG5cdFxuXHRcdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblx0XG5cdFx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblx0XG5cdFx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdFx0fVxuXHRcblx0XHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0XHR9IGVsc2UgaWYgKHRydWUpIHtcblx0XHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRcdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0XHR9LmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0XHR9XG5cdH0oKSk7XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblx0XG5cdGV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuXHRleHBvcnRzLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyA9IG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbztcblx0ZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuXHRleHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5cdGV4cG9ydHMub3V0ZXJIZWlnaHQgPSBvdXRlckhlaWdodDtcblx0ZXhwb3J0cy5vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDtcblx0ZXhwb3J0cy5pbm5lckhlaWdodCA9IGlubmVySGVpZ2h0O1xuXHRleHBvcnRzLmlubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuXHRleHBvcnRzLm9mZnNldFhZRnJvbVBhcmVudCA9IG9mZnNldFhZRnJvbVBhcmVudDtcblx0ZXhwb3J0cy5jcmVhdGVDU1NUcmFuc2Zvcm0gPSBjcmVhdGVDU1NUcmFuc2Zvcm07XG5cdGV4cG9ydHMuY3JlYXRlU1ZHVHJhbnNmb3JtID0gY3JlYXRlU1ZHVHJhbnNmb3JtO1xuXHRleHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5cdGV4cG9ydHMuZ2V0VG91Y2hJZGVudGlmaWVyID0gZ2V0VG91Y2hJZGVudGlmaWVyO1xuXHRleHBvcnRzLmFkZFVzZXJTZWxlY3RTdHlsZXMgPSBhZGRVc2VyU2VsZWN0U3R5bGVzO1xuXHRleHBvcnRzLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMgPSByZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xuXHRleHBvcnRzLnN0eWxlSGFja3MgPSBzdHlsZUhhY2tzO1xuXHRcblx0dmFyIF9zaGltcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHR2YXIgX2dldFByZWZpeCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX2dldFByZWZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcmVmaXgpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cdFxuXHQvKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb259IGZyb20gJy4vdHlwZXMnOyovXG5cdFxuXHRcblx0dmFyIG1hdGNoZXNTZWxlY3RvckZ1bmMgPSAnJztcblx0ZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgaWYgKCFtYXRjaGVzU2VsZWN0b3JGdW5jKSB7XG5cdCAgICBtYXRjaGVzU2VsZWN0b3JGdW5jID0gKDAsIF9zaGltcy5maW5kSW5BcnJheSkoWydtYXRjaGVzJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtb3pNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnb01hdGNoZXNTZWxlY3RvciddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdCAgICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcblx0ICAgICAgcmV0dXJuICgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWV0aG9kXSk7XG5cdCAgICB9KTtcblx0ICB9XG5cdFxuXHQgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcblx0ICByZXR1cm4gZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10uY2FsbChlbCwgc2VsZWN0b3IpO1xuXHR9XG5cdFxuXHQvLyBXb3JrcyB1cCB0aGUgdHJlZSB0byB0aGUgZHJhZ2dhYmxlIGl0c2VsZiBhdHRlbXB0aW5nIHRvIG1hdGNoIHNlbGVjdG9yLlxuXHRmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8oZWwgLyo6IE5vZGUqLywgc2VsZWN0b3IgLyo6IHN0cmluZyovLCBiYXNlTm9kZSAvKjogTm9kZSovKSAvKjogYm9vbGVhbiovIHtcblx0ICB2YXIgbm9kZSA9IGVsO1xuXHQgIGRvIHtcblx0ICAgIGlmIChtYXRjaGVzU2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcblx0ICAgIGlmIChub2RlID09PSBiYXNlTm9kZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0ICB9IHdoaWxlIChub2RlKTtcblx0XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhZGRFdmVudChlbCAvKjogP05vZGUqLywgZXZlbnQgLyo6IHN0cmluZyovLCBoYW5kbGVyIC8qOiBGdW5jdGlvbiovKSAvKjogdm9pZCovIHtcblx0ICBpZiAoIWVsKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChlbC5hdHRhY2hFdmVudCkge1xuXHQgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcblx0ICB9IGVsc2UgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cdCAgICBlbFsnb24nICsgZXZlbnRdID0gaGFuZGxlcjtcblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsIC8qOiA/Tm9kZSovLCBldmVudCAvKjogc3RyaW5nKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8pIC8qOiB2b2lkKi8ge1xuXHQgIGlmICghZWwpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGVsLmRldGFjaEV2ZW50KSB7XG5cdCAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuXHQgIH0gZWxzZSBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcblx0ICAgIGVsWydvbicgKyBldmVudF0gPSBudWxsO1xuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gb3V0ZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcblx0ICAvLyBvZmZzZXRUb3Agd2hpY2ggaXMgaW5jbHVkaW5nIG1hcmdpbi4gU2VlIGdldEJvdW5kUG9zaXRpb25cblx0ICB2YXIgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG5cdCAgdmFyIGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0ICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuXHQgIGhlaWdodCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG5cdCAgcmV0dXJuIGhlaWdodDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gb3V0ZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi8ge1xuXHQgIC8vIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGV4Y2x1ZGluZyBtYXJnaW4gZm9yIG91ciBjYWxjdWxhdGlvbnMsIHNpbmNlIHdlIGFyZSB1c2luZ1xuXHQgIC8vIG9mZnNldExlZnQgd2hpY2ggaXMgaW5jbHVkaW5nIG1hcmdpbi4gU2VlIGdldEJvdW5kUG9zaXRpb25cblx0ICB2YXIgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKTtcblx0ICB3aWR0aCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcblx0ICByZXR1cm4gd2lkdGg7XG5cdH1cblx0ZnVuY3Rpb24gaW5uZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICB2YXIgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG5cdCAgdmFyIGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0ICBoZWlnaHQgLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCk7XG5cdCAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuXHQgIHJldHVybiBoZWlnaHQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlubmVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICB2YXIgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpO1xuXHQgIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG5cdCAgcmV0dXJuIHdpZHRoO1xuXHR9XG5cdFxuXHQvLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcblx0ZnVuY3Rpb24gb2Zmc2V0WFlGcm9tUGFyZW50KGV2dCAvKjoge2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSovLCBvZmZzZXRQYXJlbnQgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBDb250cm9sUG9zaXRpb24qLyB7XG5cdCAgdmFyIGlzQm9keSA9IG9mZnNldFBhcmVudCA9PT0gb2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcblx0ICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGlzQm9keSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFxuXHQgIHZhciB4ID0gZXZ0LmNsaWVudFggKyBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCAtIG9mZnNldFBhcmVudFJlY3QubGVmdDtcblx0ICB2YXIgeSA9IGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wO1xuXHRcblx0ICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNyZWF0ZUNTU1RyYW5zZm9ybShfcmVmKSAvKjogT2JqZWN0Ki8ge1xuXHQgIHZhciB4ID0gX3JlZi54LFxuXHQgICAgICB5ID0gX3JlZi55O1xuXHRcblx0ICAvLyBSZXBsYWNlIHVuaXRsZXNzIGl0ZW1zIHdpdGggcHhcblx0ICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCAoMCwgX2dldFByZWZpeC5icm93c2VyUHJlZml4VG9LZXkpKCd0cmFuc2Zvcm0nLCBfZ2V0UHJlZml4Mi5kZWZhdWx0KSwgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY3JlYXRlU1ZHVHJhbnNmb3JtKF9yZWYzKSAvKjogc3RyaW5nKi8ge1xuXHQgIHZhciB4ID0gX3JlZjMueCxcblx0ICAgICAgeSA9IF9yZWYzLnk7XG5cdFxuXHQgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJztcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0VG91Y2goZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8sIGlkZW50aWZpZXIgLyo6IG51bWJlciovKSAvKjogP3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn0qLyB7XG5cdCAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlcyAmJiAoMCwgX3NoaW1zLmZpbmRJbkFycmF5KShlLnRhcmdldFRvdWNoZXMsIGZ1bmN0aW9uICh0KSB7XG5cdCAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyO1xuXHQgIH0pIHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHQpIHtcblx0ICAgIHJldHVybiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXI7XG5cdCAgfSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldFRvdWNoSWRlbnRpZmllcihlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLykgLyo6ID9udW1iZXIqLyB7XG5cdCAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXNbMF0pIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcblx0ICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xuXHR9XG5cdFxuXHQvLyBVc2VyLXNlbGVjdCBIYWNrczpcblx0Ly9cblx0Ly8gVXNlZnVsIGZvciBwcmV2ZW50aW5nIGJsdWUgaGlnaGxpZ2h0cyBhbGwgb3ZlciBldmVyeXRoaW5nIHdoZW4gZHJhZ2dpbmcuXG5cdHZhciB1c2VyU2VsZWN0UHJlZml4ID0gKDAsIF9nZXRQcmVmaXguZ2V0UHJlZml4KSgndXNlci1zZWxlY3QnKTtcblx0dmFyIHVzZXJTZWxlY3QgPSAoMCwgX2dldFByZWZpeC5icm93c2VyUHJlZml4VG9TdHlsZSkoJ3VzZXItc2VsZWN0JywgdXNlclNlbGVjdFByZWZpeCk7XG5cdHZhciB1c2VyU2VsZWN0U3R5bGUgPSAnOycgKyB1c2VyU2VsZWN0ICsgJzogbm9uZTsnO1xuXHR2YXIgdXNlclNlbGVjdFJlcGxhY2VSZWdFeHAgPSBuZXcgUmVnRXhwKCc7PycgKyB1c2VyU2VsZWN0ICsgJzogbm9uZTsnKTsgLy8gbGVhZGluZyA7IG5vdCBwcmVzZW50IG9uIElFXG5cdFxuXHQvLyBOb3RlIHdlJ3JlIHBhc3NpbmcgYGRvY3VtZW50YCBiL2Mgd2UgY291bGQgYmUgaWZyYW1lZFxuXHRmdW5jdGlvbiBhZGRVc2VyU2VsZWN0U3R5bGVzKGJvZHkgLyo6IEhUTUxFbGVtZW50Ki8pIHtcblx0ICB2YXIgc3R5bGUgPSBib2R5LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcblx0ICBib2R5LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZSArIHVzZXJTZWxlY3RTdHlsZSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoYm9keSAvKjogSFRNTEVsZW1lbnQqLykge1xuXHQgIHZhciBzdHlsZSA9IGJvZHkuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnO1xuXHQgIGJvZHkuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlLnJlcGxhY2UodXNlclNlbGVjdFJlcGxhY2VSZWdFeHAsICcnKSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHN0eWxlSGFja3MoKSAvKjogT2JqZWN0Ki8ge1xuXHQgIHZhciBjaGlsZFN0eWxlIC8qOiBPYmplY3QqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cdFxuXHQgIC8vIFdvcmthcm91bmQgSUUgcG9pbnRlciBldmVudHM7IHNlZSAjNTFcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvaXNzdWVzLzUxI2lzc3VlY29tbWVudC0xMDM0ODgyNzhcblx0ICByZXR1cm4gX2V4dGVuZHMoe1xuXHQgICAgdG91Y2hBY3Rpb246ICdub25lJ1xuXHQgIH0sIGNoaWxkU3R5bGUpO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5maW5kSW5BcnJheSA9IGZpbmRJbkFycmF5O1xuXHRleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXHRleHBvcnRzLmlzTnVtID0gaXNOdW07XG5cdGV4cG9ydHMuaW50ID0gaW50O1xuXHRleHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcblx0XG5cdC8vIEBjcmVkaXRzIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JvZ296aG5pa29mZi9hNDNjZmVkMjdjNDFlNGU2OGNkY1xuXHRmdW5jdGlvbiBmaW5kSW5BcnJheShhcnJheSAvKjogQXJyYXk8YW55PiB8IFRvdWNoTGlzdCovLCBjYWxsYmFjayAvKjogRnVuY3Rpb24qLykgLyo6IGFueSovIHtcblx0ICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChjYWxsYmFjay5hcHBseShjYWxsYmFjaywgW2FycmF5W2ldLCBpLCBhcnJheV0pKSByZXR1cm4gYXJyYXlbaV07XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMgLyo6IGFueSovKSAvKjogYm9vbGVhbiovIHtcblx0ICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmMpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc051bShudW0gLyo6IGFueSovKSAvKjogYm9vbGVhbiovIHtcblx0ICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGludChhIC8qOiBzdHJpbmcqLykgLyo6IG51bWJlciovIHtcblx0ICByZXR1cm4gcGFyc2VJbnQoYSwgMTApO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBkb250U2V0TWUocHJvcHMgLyo6IE9iamVjdCovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8sIGNvbXBvbmVudE5hbWUgLyo6IHN0cmluZyovKSB7XG5cdCAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuXHQgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBwcm9wICcgKyBwcm9wTmFtZSArICcgcGFzc2VkIHRvICcgKyBjb21wb25lbnROYW1lICsgJyAtIGRvIG5vdCBzZXQgdGhpcywgc2V0IGl0IG9uIHRoZSBjaGlsZC4nKTtcblx0ICB9XG5cdH1cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmdldFByZWZpeCA9IGdldFByZWZpeDtcblx0ZXhwb3J0cy5icm93c2VyUHJlZml4VG9LZXkgPSBicm93c2VyUHJlZml4VG9LZXk7XG5cdGV4cG9ydHMuYnJvd3NlclByZWZpeFRvU3R5bGUgPSBicm93c2VyUHJlZml4VG9TdHlsZTtcblx0dmFyIHByZWZpeGVzID0gWydNb3onLCAnV2Via2l0JywgJ08nLCAnbXMnXTtcblx0ZnVuY3Rpb24gZ2V0UHJlZml4KCkgLyo6IHN0cmluZyovIHtcblx0ICB2YXIgcHJvcCAvKjogc3RyaW5nKi8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd0cmFuc2Zvcm0nO1xuXHRcblx0ICAvLyBDaGVja2luZyBzcGVjaWZpY2FsbHkgZm9yICd3aW5kb3cuZG9jdW1lbnQnIGlzIGZvciBwc2V1ZG8tYnJvd3NlciBzZXJ2ZXItc2lkZVxuXHQgIC8vIGVudmlyb25tZW50cyB0aGF0IGRlZmluZSAnd2luZG93JyBhcyB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdCAgLy8gRS5nLiBSZWFjdC1yYWlscyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJhaWxzL3B1bGwvODQpXG5cdCAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG5cdFxuXHQgIHZhciBzdHlsZSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cdFxuXHQgIGlmIChwcm9wIGluIHN0eWxlKSByZXR1cm4gJyc7XG5cdFxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChicm93c2VyUHJlZml4VG9LZXkocHJvcCwgcHJlZml4ZXNbaV0pIGluIHN0eWxlKSByZXR1cm4gcHJlZml4ZXNbaV07XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gJyc7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb0tleShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyovIHtcblx0ICByZXR1cm4gcHJlZml4ID8gJycgKyBwcmVmaXggKyBrZWJhYlRvVGl0bGVDYXNlKHByb3ApIDogcHJvcDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvU3R5bGUocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqLyB7XG5cdCAgcmV0dXJuIHByZWZpeCA/ICctJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJy0nICsgcHJvcCA6IHByb3A7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGtlYmFiVG9UaXRsZUNhc2Uoc3RyIC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyovIHtcblx0ICB2YXIgb3V0ID0gJyc7XG5cdCAgdmFyIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoc2hvdWxkQ2FwaXRhbGl6ZSkge1xuXHQgICAgICBvdXQgKz0gc3RyW2ldLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgIHNob3VsZENhcGl0YWxpemUgPSBmYWxzZTtcblx0ICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnLScpIHtcblx0ICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQgKz0gc3RyW2ldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gb3V0O1xuXHR9XG5cdFxuXHQvLyBEZWZhdWx0IGV4cG9ydCBpcyB0aGUgcHJlZml4IGl0c2VsZiwgbGlrZSAnTW96JywgJ1dlYmtpdCcsIGV0Y1xuXHQvLyBOb3RlIHRoYXQgeW91IG1heSBoYXZlIHRvIHJlLXRlc3QgZm9yIGNlcnRhaW4gdGhpbmdzOyBmb3IgaW5zdGFuY2UsIENocm9tZSA1MFxuXHQvLyBjYW4gaGFuZGxlIHVucHJlZml4ZWQgYHRyYW5zZm9ybWAsIGJ1dCBub3QgdW5wcmVmaXhlZCBgdXNlci1zZWxlY3RgXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGdldFByZWZpeCgpO1xuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZ2V0Qm91bmRQb3NpdGlvbiA9IGdldEJvdW5kUG9zaXRpb247XG5cdGV4cG9ydHMuc25hcFRvR3JpZCA9IHNuYXBUb0dyaWQ7XG5cdGV4cG9ydHMuY2FuRHJhZ1ggPSBjYW5EcmFnWDtcblx0ZXhwb3J0cy5jYW5EcmFnWSA9IGNhbkRyYWdZO1xuXHRleHBvcnRzLmdldENvbnRyb2xQb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbjtcblx0ZXhwb3J0cy5jcmVhdGVDb3JlRGF0YSA9IGNyZWF0ZUNvcmVEYXRhO1xuXHRleHBvcnRzLmNyZWF0ZURyYWdnYWJsZURhdGEgPSBjcmVhdGVEcmFnZ2FibGVEYXRhO1xuXHRcblx0dmFyIF9zaGltcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHR2YXIgX3JlYWN0RG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXHRcblx0dmFyIF9kb21GbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZSc7Ki9cblx0Lyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZURhdGF9IGZyb20gJy4vdHlwZXMnOyovXG5cdC8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZSBmcm9tICcuLi9EcmFnZ2FibGVDb3JlJzsqL1xuXHRmdW5jdGlvbiBnZXRCb3VuZFBvc2l0aW9uKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLykgLyo6IFtudW1iZXIsIG51bWJlcl0qLyB7XG5cdCAgLy8gSWYgbm8gYm91bmRzLCBzaG9ydC1jaXJjdWl0IGFuZCBtb3ZlIG9uXG5cdCAgaWYgKCFkcmFnZ2FibGUucHJvcHMuYm91bmRzKSByZXR1cm4gW3gsIHldO1xuXHRcblx0ICAvLyBDbG9uZSBuZXcgYm91bmRzXG5cdCAgdmFyIGJvdW5kcyA9IGRyYWdnYWJsZS5wcm9wcy5ib3VuZHM7XG5cdFxuXHQgIGJvdW5kcyA9IHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnID8gYm91bmRzIDogY2xvbmVCb3VuZHMoYm91bmRzKTtcblx0ICB2YXIgbm9kZSA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuXHRcblx0ICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuXHRcblx0ICAgIHZhciBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdCAgICB2YXIgYm91bmROb2RlID0gdm9pZCAwO1xuXHQgICAgaWYgKGJvdW5kcyA9PT0gJ3BhcmVudCcpIHtcblx0ICAgICAgYm91bmROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYm91bmROb2RlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJvdW5kcyk7XG5cdCAgICAgIGlmICghYm91bmROb2RlKSB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBzZWxlY3RvciBcIicgKyBib3VuZHMgKyAnXCIgY291bGQgbm90IGZpbmQgYW4gZWxlbWVudC4nKTtcblx0ICAgIH1cblx0ICAgIHZhciBub2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHQgICAgdmFyIGJvdW5kTm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShib3VuZE5vZGUpO1xuXHQgICAgLy8gQ29tcHV0ZSBib3VuZHMuIFRoaXMgaXMgYSBwYWluIHdpdGggcGFkZGluZyBhbmQgb2Zmc2V0cyBidXQgdGhpcyBnZXRzIGl0IGV4YWN0bHkgcmlnaHQuXG5cdCAgICBib3VuZHMgPSB7XG5cdCAgICAgIGxlZnQ6IC1ub2RlLm9mZnNldExlZnQgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ0xlZnQpICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5MZWZ0KSxcblx0ICAgICAgdG9wOiAtbm9kZS5vZmZzZXRUb3AgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ1RvcCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLmJvcmRlclRvcFdpZHRoKSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luVG9wKSxcblx0ICAgICAgcmlnaHQ6ICgwLCBfZG9tRm5zLmlubmVyV2lkdGgpKGJvdW5kTm9kZSkgLSAoMCwgX2RvbUZucy5vdXRlcldpZHRoKShub2RlKSAtIG5vZGUub2Zmc2V0TGVmdCxcblx0ICAgICAgYm90dG9tOiAoMCwgX2RvbUZucy5pbm5lckhlaWdodCkoYm91bmROb2RlKSAtICgwLCBfZG9tRm5zLm91dGVySGVpZ2h0KShub2RlKSAtIG5vZGUub2Zmc2V0VG9wXG5cdCAgICB9O1xuXHQgIH1cblx0XG5cdCAgLy8gS2VlcCB4IGFuZCB5IGJlbG93IHJpZ2h0IGFuZCBib3R0b20gbGltaXRzLi4uXG5cdCAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5yaWdodCkpIHggPSBNYXRoLm1pbih4LCBib3VuZHMucmlnaHQpO1xuXHQgIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMuYm90dG9tKSkgeSA9IE1hdGgubWluKHksIGJvdW5kcy5ib3R0b20pO1xuXHRcblx0ICAvLyBCdXQgYWJvdmUgbGVmdCBhbmQgdG9wIGxpbWl0cy5cblx0ICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmxlZnQpKSB4ID0gTWF0aC5tYXgoeCwgYm91bmRzLmxlZnQpO1xuXHQgIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMudG9wKSkgeSA9IE1hdGgubWF4KHksIGJvdW5kcy50b3ApO1xuXHRcblx0ICByZXR1cm4gW3gsIHldO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzbmFwVG9HcmlkKGdyaWQgLyo6IFtudW1iZXIsIG51bWJlcl0qLywgcGVuZGluZ1ggLyo6IG51bWJlciovLCBwZW5kaW5nWSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8ge1xuXHQgIHZhciB4ID0gTWF0aC5yb3VuZChwZW5kaW5nWCAvIGdyaWRbMF0pICogZ3JpZFswXTtcblx0ICB2YXIgeSA9IE1hdGgucm91bmQocGVuZGluZ1kgLyBncmlkWzFdKSAqIGdyaWRbMV07XG5cdCAgcmV0dXJuIFt4LCB5XTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY2FuRHJhZ1goZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd4Jztcblx0fVxuXHRcblx0ZnVuY3Rpb24gY2FuRHJhZ1koZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd5Jztcblx0fVxuXHRcblx0Ly8gR2V0IHt4LCB5fSBwb3NpdGlvbnMgZnJvbSBldmVudC5cblx0ZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCB0b3VjaElkZW50aWZpZXIgLyo6ID9udW1iZXIqLywgZHJhZ2dhYmxlQ29yZSAvKjogRHJhZ2dhYmxlQ29yZSovKSAvKjogP0NvbnRyb2xQb3NpdGlvbiovIHtcblx0ICB2YXIgdG91Y2hPYmogPSB0eXBlb2YgdG91Y2hJZGVudGlmaWVyID09PSAnbnVtYmVyJyA/ICgwLCBfZG9tRm5zLmdldFRvdWNoKShlLCB0b3VjaElkZW50aWZpZXIpIDogbnVsbDtcblx0ICBpZiAodHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgJiYgIXRvdWNoT2JqKSByZXR1cm4gbnVsbDsgLy8gbm90IHRoZSByaWdodCB0b3VjaFxuXHQgIHZhciBub2RlID0gX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKGRyYWdnYWJsZUNvcmUpO1xuXHQgIC8vIFVzZXIgY2FuIHByb3ZpZGUgYW4gb2Zmc2V0UGFyZW50IGlmIGRlc2lyZWQuXG5cdCAgdmFyIG9mZnNldFBhcmVudCA9IGRyYWdnYWJsZUNvcmUucHJvcHMub2Zmc2V0UGFyZW50IHx8IG5vZGUub2Zmc2V0UGFyZW50IHx8IG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuXHQgIHJldHVybiAoMCwgX2RvbUZucy5vZmZzZXRYWUZyb21QYXJlbnQpKHRvdWNoT2JqIHx8IGUsIG9mZnNldFBhcmVudCk7XG5cdH1cblx0XG5cdC8vIENyZWF0ZSBhbiBkYXRhIG9iamVjdCBleHBvc2VkIGJ5IDxEcmFnZ2FibGVDb3JlPidzIGV2ZW50c1xuXHRmdW5jdGlvbiBjcmVhdGVDb3JlRGF0YShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZUNvcmUqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovKSAvKjogRHJhZ2dhYmxlRGF0YSovIHtcblx0ICB2YXIgc3RhdGUgPSBkcmFnZ2FibGUuc3RhdGU7XG5cdCAgdmFyIGlzU3RhcnQgPSAhKDAsIF9zaGltcy5pc051bSkoc3RhdGUubGFzdFgpO1xuXHRcblx0ICBpZiAoaXNTdGFydCkge1xuXHQgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgbW92ZSwgdXNlIHRoZSB4IGFuZCB5IGFzIGxhc3QgY29vcmRzLlxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgbm9kZTogX3JlYWN0RG9tMi5kZWZhdWx0LmZpbmRET01Ob2RlKGRyYWdnYWJsZSksXG5cdCAgICAgIGRlbHRhWDogMCwgZGVsdGFZOiAwLFxuXHQgICAgICBsYXN0WDogeCwgbGFzdFk6IHksXG5cdCAgICAgIHg6IHgsIHk6IHlcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG5vZGU6IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShkcmFnZ2FibGUpLFxuXHQgICAgICBkZWx0YVg6IHggLSBzdGF0ZS5sYXN0WCwgZGVsdGFZOiB5IC0gc3RhdGUubGFzdFksXG5cdCAgICAgIGxhc3RYOiBzdGF0ZS5sYXN0WCwgbGFzdFk6IHN0YXRlLmxhc3RZLFxuXHQgICAgICB4OiB4LCB5OiB5XG5cdCAgICB9O1xuXHQgIH1cblx0fVxuXHRcblx0Ly8gQ3JlYXRlIGFuIGRhdGEgZXhwb3NlZCBieSA8RHJhZ2dhYmxlPidzIGV2ZW50c1xuXHRmdW5jdGlvbiBjcmVhdGVEcmFnZ2FibGVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIGNvcmVEYXRhIC8qOiBEcmFnZ2FibGVEYXRhKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi8ge1xuXHQgIHJldHVybiB7XG5cdCAgICBub2RlOiBjb3JlRGF0YS5ub2RlLFxuXHQgICAgeDogZHJhZ2dhYmxlLnN0YXRlLnggKyBjb3JlRGF0YS5kZWx0YVgsXG5cdCAgICB5OiBkcmFnZ2FibGUuc3RhdGUueSArIGNvcmVEYXRhLmRlbHRhWSxcblx0ICAgIGRlbHRhWDogY29yZURhdGEuZGVsdGFYLFxuXHQgICAgZGVsdGFZOiBjb3JlRGF0YS5kZWx0YVksXG5cdCAgICBsYXN0WDogZHJhZ2dhYmxlLnN0YXRlLngsXG5cdCAgICBsYXN0WTogZHJhZ2dhYmxlLnN0YXRlLnlcblx0ICB9O1xuXHR9XG5cdFxuXHQvLyBBIGxvdCBmYXN0ZXIgdGhhbiBzdHJpbmdpZnkvcGFyc2Vcblx0ZnVuY3Rpb24gY2xvbmVCb3VuZHMoYm91bmRzIC8qOiBCb3VuZHMqLykgLyo6IEJvdW5kcyovIHtcblx0ICByZXR1cm4ge1xuXHQgICAgbGVmdDogYm91bmRzLmxlZnQsXG5cdCAgICB0b3A6IGJvdW5kcy50b3AsXG5cdCAgICByaWdodDogYm91bmRzLnJpZ2h0LFxuXHQgICAgYm90dG9tOiBib3VuZHMuYm90dG9tXG5cdCAgfTtcblx0fVxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXHRcblx0dmFyIF9yZWFjdERvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblx0XG5cdHZhciBfZG9tRm5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfcG9zaXRpb25GbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9zaGltcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFxuXHR2YXIgX2xvZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0dmFyIF9sb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cdFxuXHRmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblx0XG5cdC8vIFNpbXBsZSBhYnN0cmFjdGlvbiBmb3IgZHJhZ2dpbmcgZXZlbnRzIG5hbWVzLlxuXHQvKjo6IGltcG9ydCB0eXBlIHtFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG5cdHZhciBldmVudHNGb3IgPSB7XG5cdCAgdG91Y2g6IHtcblx0ICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG5cdCAgICBtb3ZlOiAndG91Y2htb3ZlJyxcblx0ICAgIHN0b3A6ICd0b3VjaGVuZCdcblx0ICB9LFxuXHQgIG1vdXNlOiB7XG5cdCAgICBzdGFydDogJ21vdXNlZG93bicsXG5cdCAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcblx0ICAgIHN0b3A6ICdtb3VzZXVwJ1xuXHQgIH1cblx0fTtcblx0XG5cdC8vIERlZmF1bHQgdG8gbW91c2UgZXZlbnRzLlxuXHR2YXIgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlO1xuXHRcblx0Ly9cblx0Ly8gRGVmaW5lIDxEcmFnZ2FibGVDb3JlPi5cblx0Ly9cblx0Ly8gPERyYWdnYWJsZUNvcmU+IGlzIGZvciBhZHZhbmNlZCB1c2FnZSBvZiA8RHJhZ2dhYmxlPi4gSXQgbWFpbnRhaW5zIG1pbmltYWwgaW50ZXJuYWwgc3RhdGUgc28gaXQgY2FuXG5cdC8vIHdvcmsgd2VsbCB3aXRoIGxpYnJhcmllcyB0aGF0IHJlcXVpcmUgbW9yZSBjb250cm9sIG92ZXIgdGhlIGVsZW1lbnQuXG5cdC8vXG5cdFxuXHQvKjo6IHR5cGUgQ29yZVN0YXRlID0ge1xuXHQgIGRyYWdnaW5nOiBib29sZWFuLFxuXHQgIGxhc3RYOiBudW1iZXIsXG5cdCAgbGFzdFk6IG51bWJlcixcblx0ICB0b3VjaElkZW50aWZpZXI6ID9udW1iZXJcblx0fTsqL1xuXHRcblx0dmFyIERyYWdnYWJsZUNvcmUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIF9pbmhlcml0cyhEcmFnZ2FibGVDb3JlLCBfUmVhY3QkQ29tcG9uZW50KTtcblx0XG5cdCAgZnVuY3Rpb24gRHJhZ2dhYmxlQ29yZSgpIHtcblx0ICAgIHZhciBfcmVmO1xuXHRcblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cdFxuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnYWJsZUNvcmUpO1xuXHRcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IERyYWdnYWJsZUNvcmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEcmFnZ2FibGVDb3JlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG5cdCAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblx0ICAgICAgLy8gVXNlZCB3aGlsZSBkcmFnZ2luZyB0byBkZXRlcm1pbmUgZGVsdGFzLlxuXHQgICAgICBsYXN0WDogTmFOLCBsYXN0WTogTmFOLFxuXHQgICAgICB0b3VjaElkZW50aWZpZXI6IG51bGxcblx0ICAgIH0sIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gYXR0YWNoIGV2ZW50IGhhbmRsZXJzIG9uIHRvcCBvZiB0aGlzIG9uZS5cblx0ICAgICAgX3RoaXMucHJvcHMub25Nb3VzZURvd24oZSk7XG5cdFxuXHQgICAgICAvLyBPbmx5IGFjY2VwdCBsZWZ0LWNsaWNrcy5cblx0ICAgICAgaWYgKCFfdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTtcblx0XG5cdCAgICAgIC8vIEdldCBub2Rlcy4gQmUgc3VyZSB0byBncmFiIHJlbGF0aXZlIGRvY3VtZW50IChjb3VsZCBiZSBpZnJhbWVkKVxuXHQgICAgICB2YXIgZG9tTm9kZSA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShfdGhpcyk7XG5cdCAgICAgIHZhciBvd25lckRvY3VtZW50ID0gZG9tTm9kZS5vd25lckRvY3VtZW50O1xuXHRcblx0ICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuXHRcblx0ICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkIHx8ICEoZS50YXJnZXQgaW5zdGFuY2VvZiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk5vZGUpIHx8IF90aGlzLnByb3BzLmhhbmRsZSAmJiAhKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgX3RoaXMucHJvcHMuaGFuZGxlLCBkb21Ob2RlKSB8fCBfdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgX3RoaXMucHJvcHMuY2FuY2VsLCBkb21Ob2RlKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gU2V0IHRvdWNoIGlkZW50aWZpZXIgaW4gY29tcG9uZW50IHN0YXRlIGlmIHRoaXMgaXMgYSB0b3VjaCBldmVudC4gVGhpcyBhbGxvd3MgdXMgdG9cblx0ICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBpbmRpdmlkdWFsIHRvdWNoZXMgb24gbXVsdGl0b3VjaCBzY3JlZW5zIGJ5IGlkZW50aWZ5aW5nIHdoaWNoXG5cdCAgICAgIC8vIHRvdWNocG9pbnQgd2FzIHNldCB0byB0aGlzIGVsZW1lbnQuXG5cdCAgICAgIHZhciB0b3VjaElkZW50aWZpZXIgPSAoMCwgX2RvbUZucy5nZXRUb3VjaElkZW50aWZpZXIpKGUpO1xuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHRvdWNoSWRlbnRpZmllcjogdG91Y2hJZGVudGlmaWVyIH0pO1xuXHRcblx0ICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxuXHQgICAgICB2YXIgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgdG91Y2hJZGVudGlmaWVyLCBfdGhpcyk7XG5cdCAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47IC8vIG5vdCBwb3NzaWJsZSBidXQgc2F0aXNmaWVzIGZsb3dcblx0ICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuXHQgICAgICAgICAgeSA9IHBvc2l0aW9uLnk7XG5cdFxuXHQgICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgb2JqZWN0IHdpdGggYWxsIHRoZSBkYXRhIHBhcmVudHMgbmVlZCB0byBtYWtlIGEgZGVjaXNpb24gaGVyZS5cblx0XG5cdCAgICAgIHZhciBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKShfdGhpcywgeCwgeSk7XG5cdFxuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdGFydDogJWonLCBjb3JlRXZlbnQpO1xuXHRcblx0ICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCBjYW5jZWwuXG5cdCAgICAgICgwLCBfbG9nMi5kZWZhdWx0KSgnY2FsbGluZycsIF90aGlzLnByb3BzLm9uU3RhcnQpO1xuXHQgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gX3RoaXMucHJvcHMub25TdGFydChlLCBjb3JlRXZlbnQpO1xuXHQgICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcblx0ICAgICAgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cblx0ICAgICAgLy8gYmVpbmcgc2VsZWN0ZWQgYWxsIG92ZXIgdGhlIHBhZ2UuXG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5lbmFibGVVc2VyU2VsZWN0SGFjaykgKDAsIF9kb21GbnMuYWRkVXNlclNlbGVjdFN0eWxlcykob3duZXJEb2N1bWVudC5ib2R5KTtcblx0XG5cdCAgICAgIC8vIEluaXRpYXRlIGRyYWdnaW5nLiBTZXQgdGhlIGN1cnJlbnQgeCBhbmQgeSBhcyBvZmZzZXRzXG5cdCAgICAgIC8vIHNvIHdlIGtub3cgaG93IG11Y2ggd2UndmUgbW92ZWQgZHVyaW5nIHRoZSBkcmFnLiBUaGlzIGFsbG93cyB1c1xuXHQgICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG5cdCAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG5cdFxuXHQgICAgICAgIGxhc3RYOiB4LFxuXHQgICAgICAgIGxhc3RZOiB5XG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgLy8gQWRkIGV2ZW50cyB0byB0aGUgZG9jdW1lbnQgZGlyZWN0bHkgc28gd2UgY2F0Y2ggd2hlbiB0aGUgdXNlcidzIG1vdXNlL3RvdWNoIG1vdmVzIG91dHNpZGUgb2Zcblx0ICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcblx0ICAgICAgLy8gaXMgYSB0b3VjaC1jYXBhYmxlIGRldmljZS5cblx0ICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCBfdGhpcy5oYW5kbGVEcmFnKTtcblx0ICAgICAgKDAsIF9kb21GbnMuYWRkRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5zdG9wLCBfdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICB9LCBfdGhpcy5oYW5kbGVEcmFnID0gZnVuY3Rpb24gKGUpIHtcblx0XG5cdCAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXZpY2VzLCBsaWtlIGlwYWQvaXBob25lLlxuXHQgICAgICBpZiAoZS50eXBlID09PSAndG91Y2htb3ZlJykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcblx0ICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxuXHQgICAgICB2YXIgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgX3RoaXMuc3RhdGUudG91Y2hJZGVudGlmaWVyLCBfdGhpcyk7XG5cdCAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG5cdCAgICAgIHZhciB4ID0gcG9zaXRpb24ueCxcblx0ICAgICAgICAgIHkgPSBwb3NpdGlvbi55O1xuXHRcblx0ICAgICAgLy8gU25hcCB0byBncmlkIGlmIHByb3AgaGFzIGJlZW4gcHJvdmlkZWRcblx0XG5cdCAgICAgIGlmICh4ICE9PSB4KSBkZWJ1Z2dlcjtcblx0XG5cdCAgICAgIGlmIChBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmdyaWQpKSB7XG5cdCAgICAgICAgdmFyIGRlbHRhWCA9IHggLSBfdGhpcy5zdGF0ZS5sYXN0WCxcblx0ICAgICAgICAgICAgZGVsdGFZID0geSAtIF90aGlzLnN0YXRlLmxhc3RZO1xuXHRcblx0ICAgICAgICB2YXIgX3NuYXBUb0dyaWQgPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKF90aGlzLnByb3BzLmdyaWQsIGRlbHRhWCwgZGVsdGFZKTtcblx0XG5cdCAgICAgICAgdmFyIF9zbmFwVG9HcmlkMiA9IF9zbGljZWRUb0FycmF5KF9zbmFwVG9HcmlkLCAyKTtcblx0XG5cdCAgICAgICAgZGVsdGFYID0gX3NuYXBUb0dyaWQyWzBdO1xuXHQgICAgICAgIGRlbHRhWSA9IF9zbmFwVG9HcmlkMlsxXTtcblx0XG5cdCAgICAgICAgaWYgKCFkZWx0YVggJiYgIWRlbHRhWSkgcmV0dXJuOyAvLyBza2lwIHVzZWxlc3MgZHJhZ1xuXHQgICAgICAgIHggPSBfdGhpcy5zdGF0ZS5sYXN0WCArIGRlbHRhWCwgeSA9IF90aGlzLnN0YXRlLmxhc3RZICsgZGVsdGFZO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkoX3RoaXMsIHgsIHkpO1xuXHRcblx0ICAgICAgKDAsIF9sb2cyLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnOiAlaicsIGNvcmVFdmVudCk7XG5cdFxuXHQgICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXIuIElmIGl0IHJldHVybnMgZXhwbGljaXQgZmFsc2UsIHRyaWdnZXIgZW5kLlxuXHQgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gX3RoaXMucHJvcHMub25EcmFnKGUsIGNvcmVFdmVudCk7XG5cdCAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIC8vICRGbG93SWdub3JlXG5cdCAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnU3RvcChuZXcgTW91c2VFdmVudCgnbW91c2V1cCcpKTtcblx0ICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgIC8vIE9sZCBicm93c2Vyc1xuXHQgICAgICAgICAgdmFyIGV2ZW50ID0gKChkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKSAvKjogYW55Ki8pIC8qOiBNb3VzZVRvdWNoRXZlbnQqLyk7XG5cdCAgICAgICAgICAvLyBJIHNlZSB3aHkgdGhpcyBpbnNhbml0eSB3YXMgZGVwcmVjYXRlZFxuXHQgICAgICAgICAgLy8gJEZsb3dJZ25vcmVcblx0ICAgICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZXVwJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cdCAgICAgICAgICBfdGhpcy5oYW5kbGVEcmFnU3RvcChldmVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuXHQgICAgICAgIGxhc3RYOiB4LFxuXHQgICAgICAgIGxhc3RZOiB5XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgX3RoaXMuaGFuZGxlRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm47XG5cdFxuXHQgICAgICB2YXIgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgX3RoaXMuc3RhdGUudG91Y2hJZGVudGlmaWVyLCBfdGhpcyk7XG5cdCAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG5cdCAgICAgIHZhciB4ID0gcG9zaXRpb24ueCxcblx0ICAgICAgICAgIHkgPSBwb3NpdGlvbi55O1xuXHRcblx0ICAgICAgdmFyIGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKF90aGlzLCB4LCB5KTtcblx0XG5cdCAgICAgIHZhciBfUmVhY3RET00kZmluZERPTU5vZGUgPSBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoX3RoaXMpLFxuXHQgICAgICAgICAgb3duZXJEb2N1bWVudCA9IF9SZWFjdERPTSRmaW5kRE9NTm9kZS5vd25lckRvY3VtZW50O1xuXHRcblx0ICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcblx0XG5cdFxuXHQgICAgICBpZiAoX3RoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQuYm9keSk7XG5cdFxuXHQgICAgICAoMCwgX2xvZzIuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cdFxuXHQgICAgICAvLyBSZXNldCB0aGUgZWwuXG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHtcblx0ICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdCAgICAgICAgbGFzdFg6IE5hTixcblx0ICAgICAgICBsYXN0WTogTmFOXG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyXG5cdCAgICAgIF90aGlzLnByb3BzLm9uU3RvcChlLCBjb3JlRXZlbnQpO1xuXHRcblx0ICAgICAgLy8gUmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG5cdCAgICAgICgwLCBfbG9nMi5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcblx0ICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCBfdGhpcy5oYW5kbGVEcmFnKTtcblx0ICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5zdG9wLCBfdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICB9LCBfdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTsgLy8gb24gdG91Y2hzY3JlZW4gbGFwdG9wcyB3ZSBjb3VsZCBzd2l0Y2ggYmFjayB0byBtb3VzZVxuXHRcblx0ICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdGFydChlKTtcblx0ICAgIH0sIF90aGlzLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTtcblx0XG5cdCAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcblx0ICAgIH0sIF90aGlzLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IudG91Y2g7XG5cdFxuXHQgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuXHQgICAgfSwgX3RoaXMub25Ub3VjaEVuZCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IudG91Y2g7XG5cdFxuXHQgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRHJhZ1N0b3AoZSk7XG5cdCAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhEcmFnZ2FibGVDb3JlLCBbe1xuXHQgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHQgICAgICAvLyBSZW1vdmUgYW55IGxlZnRvdmVyIGV2ZW50IGhhbmRsZXJzLiBSZW1vdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgaGFuZGxlcnMgaW4gY2FzZVxuXHQgICAgICAvLyBzb21lIGJyb3dzZXIgcXVpcmsgY2F1c2VkIGEgdG91Y2ggZXZlbnQgdG8gZmlyZSBkdXJpbmcgYSBtb3VzZSBtb3ZlLCBvciB2aWNlIHZlcnNhLlxuXHQgICAgICB2YXIgX1JlYWN0RE9NJGZpbmRET01Ob2RlMiA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKSxcblx0ICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBfUmVhY3RET00kZmluZERPTU5vZGUyLm93bmVyRG9jdW1lbnQ7XG5cdFxuXHQgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkob3duZXJEb2N1bWVudCwgZXZlbnRzRm9yLm1vdXNlLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2gubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcblx0ICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcblx0ICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcblx0ICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQuYm9keSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gU2FtZSBhcyBvbk1vdXNlRG93biAoc3RhcnQgZHJhZyksIGJ1dCBub3cgY29uc2lkZXIgdGhpcyBhIHRvdWNoIGRldmljZS5cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAncmVuZGVyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki8ge1xuXHQgICAgICAvLyBSZXVzZSB0aGUgY2hpbGQgcHJvdmlkZWRcblx0ICAgICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0Yylcblx0ICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jbG9uZUVsZW1lbnQoX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHtcblx0ICAgICAgICBzdHlsZTogKDAsIF9kb21GbnMuc3R5bGVIYWNrcykodGhpcy5wcm9wcy5jaGlsZHJlbi5wcm9wcy5zdHlsZSksXG5cdFxuXHQgICAgICAgIC8vIE5vdGU6IG1vdXNlTW92ZSBoYW5kbGVyIGlzIGF0dGFjaGVkIHRvIGRvY3VtZW50IHNvIGl0IHdpbGwgc3RpbGwgZnVuY3Rpb25cblx0ICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuXHQgICAgICAgIG9uTW91c2VEb3duOiB0aGlzLm9uTW91c2VEb3duLFxuXHQgICAgICAgIG9uVG91Y2hTdGFydDogdGhpcy5vblRvdWNoU3RhcnQsXG5cdCAgICAgICAgb25Nb3VzZVVwOiB0aGlzLm9uTW91c2VVcCxcblx0ICAgICAgICBvblRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmRcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gRHJhZ2dhYmxlQ29yZTtcblx0fShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblx0XG5cdERyYWdnYWJsZUNvcmUuZGlzcGxheU5hbWUgPSAnRHJhZ2dhYmxlQ29yZSc7XG5cdERyYWdnYWJsZUNvcmUucHJvcFR5cGVzID0ge1xuXHQgIC8qKlxuXHQgICAqIGBhbGxvd0FueUNsaWNrYCBhbGxvd3MgZHJhZ2dpbmcgdXNpbmcgYW55IG1vdXNlIGJ1dHRvbi5cblx0ICAgKiBCeSBkZWZhdWx0LCB3ZSBvbmx5IGFjY2VwdCB0aGUgbGVmdCBidXR0b24uXG5cdCAgICpcblx0ICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuXHQgICAqL1xuXHQgIGFsbG93QW55Q2xpY2s6IF9yZWFjdC5Qcm9wVHlwZXMuYm9vbCxcblx0XG5cdCAgLyoqXG5cdCAgICogYGRpc2FibGVkYCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIDxEcmFnZ2FibGU+IGZyb20gZHJhZ2dpbmcuIEFsbCBoYW5kbGVycyxcblx0ICAgKiB3aXRoIHRoZSBleGNlcHRpb24gb2YgYG9uTW91c2VEb3duYCwgd2lsbCBub3QgZmlyZS5cblx0ICAgKi9cblx0ICBkaXNhYmxlZDogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuXHRcblx0ICAvKipcblx0ICAgKiBCeSBkZWZhdWx0LCB3ZSBhZGQgJ3VzZXItc2VsZWN0Om5vbmUnIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGJvZHlcblx0ICAgKiB0byBwcmV2ZW50IHVnbHkgdGV4dCBzZWxlY3Rpb24gZHVyaW5nIGRyYWcuIElmIHRoaXMgaXMgY2F1c2luZyBwcm9ibGVtc1xuXHQgICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cblx0ICAgKi9cblx0ICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3JlYWN0LlByb3BUeXBlcy5ib29sLFxuXHRcblx0ICAvKipcblx0ICAgKiBgb2Zmc2V0UGFyZW50YCwgaWYgc2V0LCB1c2VzIHRoZSBwYXNzZWQgRE9NIG5vZGUgdG8gY29tcHV0ZSBkcmFnIG9mZnNldHNcblx0ICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cblx0ICAgKi9cblx0ICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudChwcm9wcywgcHJvcE5hbWUpIHtcblx0ICAgIGlmIChwcm9jZXNzLmJyb3dzZXIgJiYgcHJvcHNbcHJvcE5hbWVdICYmIHByb3BzW3Byb3BOYW1lXS5ub2RlVHlwZSAhPT0gMSkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZVxcJ3Mgb2Zmc2V0UGFyZW50IG11c3QgYmUgYSBET00gTm9kZS4nKTtcblx0ICAgIH1cblx0ICB9LFxuXHRcblx0ICAvKipcblx0ICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG5cdCAgICovXG5cdCAgZ3JpZDogX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mKF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyKSxcblx0XG5cdCAgLyoqXG5cdCAgICogYGhhbmRsZWAgc3BlY2lmaWVzIGEgc2VsZWN0b3IgdG8gYmUgdXNlZCBhcyB0aGUgaGFuZGxlIHRoYXQgaW5pdGlhdGVzIGRyYWcuXG5cdCAgICpcblx0ICAgKiBFeGFtcGxlOlxuXHQgICAqXG5cdCAgICogYGBganN4XG5cdCAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXHQgICAqICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAqICAgICAgICAgcmV0dXJuIChcblx0ICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuXHQgICAqICAgICAgICAgICAgICA8ZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoYW5kbGVcIj5DbGljayBtZSB0byBkcmFnPC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG5cdCAgICogICAgICAgICAgICAgIDwvZGl2PlxuXHQgICAqICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICk7XG5cdCAgICogICAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICogYGBgXG5cdCAgICovXG5cdCAgaGFuZGxlOiBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcblx0XG5cdCAgLyoqXG5cdCAgICogYGNhbmNlbGAgc3BlY2lmaWVzIGEgc2VsZWN0b3IgdG8gYmUgdXNlZCB0byBwcmV2ZW50IGRyYWcgaW5pdGlhbGl6YXRpb24uXG5cdCAgICpcblx0ICAgKiBFeGFtcGxlOlxuXHQgICAqXG5cdCAgICogYGBganN4XG5cdCAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXHQgICAqICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAqICAgICAgICAgICByZXR1cm4oXG5cdCAgICogICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGNhbmNlbD1cIi5jYW5jZWxcIj5cblx0ICAgKiAgICAgICAgICAgICAgICAgICA8ZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW5jZWxcIj5Zb3UgY2FuJ3QgZHJhZyBmcm9tIGhlcmU8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXY+RHJhZ2dpbmcgaGVyZSB3b3JrcyBmaW5lPC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICAgKTtcblx0ICAgKiAgICAgICB9XG5cdCAgICogICB9KTtcblx0ICAgKiBgYGBcblx0ICAgKi9cblx0ICBjYW5jZWw6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuXHRcblx0ICAvKipcblx0ICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMuXG5cdCAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuXHQgICAqL1xuXHQgIG9uU3RhcnQ6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoaWxlIGRyYWdnaW5nLlxuXHQgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgZHJhZ2dpbmcgd2lsbCBiZSBjYW5jZWxlZC5cblx0ICAgKi9cblx0ICBvbkRyYWc6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYyxcblx0XG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RvcHMuXG5cdCAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCB0aGUgZHJhZyB3aWxsIHJlbWFpbiBhY3RpdmUuXG5cdCAgICovXG5cdCAgb25TdG9wOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG5cdFxuXHQgIC8qKlxuXHQgICAqIEEgd29ya2Fyb3VuZCBvcHRpb24gd2hpY2ggY2FuIGJlIHBhc3NlZCBpZiBvbk1vdXNlRG93biBuZWVkcyB0byBiZSBhY2Nlc3NlZCxcblx0ICAgKiBzaW5jZSBpdCdsbCBhbHdheXMgYmUgYmxvY2tlZCAoYXMgdGhlcmUgaXMgaW50ZXJuYWwgdXNlIG9mIG9uTW91c2VEb3duKVxuXHQgICAqL1xuXHQgIG9uTW91c2VEb3duOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG5cdFxuXHQgIC8qKlxuXHQgICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cblx0ICAgKi9cblx0ICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG5cdCAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG5cdCAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG5cdH07XG5cdERyYWdnYWJsZUNvcmUuZGVmYXVsdFByb3BzID0ge1xuXHQgIGFsbG93QW55Q2xpY2s6IGZhbHNlLCAvLyBieSBkZWZhdWx0IG9ubHkgYWNjZXB0IGxlZnQgY2xpY2tcblx0ICBjYW5jZWw6IG51bGwsXG5cdCAgZGlzYWJsZWQ6IGZhbHNlLFxuXHQgIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiB0cnVlLFxuXHQgIG9mZnNldFBhcmVudDogbnVsbCxcblx0ICBoYW5kbGU6IG51bGwsXG5cdCAgZ3JpZDogbnVsbCxcblx0ICB0cmFuc2Zvcm06IG51bGwsXG5cdCAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuXHQgIG9uRHJhZzogZnVuY3Rpb24gb25EcmFnKCkge30sXG5cdCAgb25TdG9wOiBmdW5jdGlvbiBvblN0b3AoKSB7fSxcblx0ICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7fVxuXHR9O1xuXHRleHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpKVxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXHR2YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cdFxuXHQvLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcblx0Ly8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG5cdC8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcblx0Ly8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblx0XG5cdHZhciBjYWNoZWRTZXRUaW1lb3V0O1xuXHR2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXHRcblx0ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cdGZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcblx0fVxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblx0ICAgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblx0ICAgIH1cblx0fSAoKSlcblx0ZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcblx0ICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cdCAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcblx0ICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcblx0ICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG5cdCAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH0gY2F0Y2goZSl7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcblx0ICAgICAgICB9IGNhdGNoKGUpe1xuXHQgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0XG5cdH1cblx0ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuXHQgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG5cdCAgICAgICAgfSBjYXRjaCAoZSl7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuXHQgICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdFxuXHRcblx0fVxuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIGRyYWluaW5nID0gZmFsc2U7XG5cdHZhciBjdXJyZW50UXVldWU7XG5cdHZhciBxdWV1ZUluZGV4ID0gLTE7XG5cdFxuXHRmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG5cdCAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG5cdCAgICB9XG5cdCAgICBpZiAocXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgZHJhaW5RdWV1ZSgpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuXHQgICAgaWYgKGRyYWluaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG5cdCAgICBkcmFpbmluZyA9IHRydWU7XG5cdFxuXHQgICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIHdoaWxlKGxlbikge1xuXHQgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuXHQgICAgICAgIHF1ZXVlID0gW107XG5cdCAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIH1cblx0ICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9XG5cdFxuXHRwcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuXHQgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblx0ICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG5cdCAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcblx0ICAgIH1cblx0fTtcblx0XG5cdC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblx0ZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG5cdCAgICB0aGlzLmZ1biA9IGZ1bjtcblx0ICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcblx0fVxuXHRJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcblx0fTtcblx0cHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcblx0cHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcblx0cHJvY2Vzcy5lbnYgPSB7fTtcblx0cHJvY2Vzcy5hcmd2ID0gW107XG5cdHByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXHRwcm9jZXNzLnZlcnNpb25zID0ge307XG5cdFxuXHRmdW5jdGlvbiBub29wKCkge31cblx0XG5cdHByb2Nlc3Mub24gPSBub29wO1xuXHRwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5vbmNlID0gbm9vcDtcblx0cHJvY2Vzcy5vZmYgPSBub29wO1xuXHRwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xuXHRwcm9jZXNzLmVtaXQgPSBub29wO1xuXHRcblx0cHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0XG5cdHByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5cdHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHR9O1xuXHRwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gbG9nO1xuXHRcblx0Lyplc2xpbnQgbm8tY29uc29sZTowKi9cblx0ZnVuY3Rpb24gbG9nKCkge1xuXHQgIHZhciBfY29uc29sZTtcblx0XG5cdCAgaWYgKCh1bmRlZmluZWQpKSAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtZHJhZ2dhYmxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NsaWRlciA9IHJlcXVpcmUoJy4vU2xpZGVyJyk7XG5cbnZhciBfU2xpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NsaWRlcik7XG5cbnZhciBfVHJhY2sgPSByZXF1aXJlKCcuL1RyYWNrJyk7XG5cbnZhciBfVHJhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVHJhY2spO1xuXG52YXIgX0xhYmVsID0gcmVxdWlyZSgnLi9MYWJlbCcpO1xuXG52YXIgX0xhYmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhYmVsKTtcblxudmFyIF9kZWZhdWx0Q2xhc3NOYW1lcyA9IHJlcXVpcmUoJy4vZGVmYXVsdENsYXNzTmFtZXMnKTtcblxudmFyIF9kZWZhdWx0Q2xhc3NOYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0Q2xhc3NOYW1lcyk7XG5cbnZhciBfdmFsdWVUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vdmFsdWVUcmFuc2Zvcm1lcicpO1xuXG52YXIgX3ZhbHVlVHJhbnNmb3JtZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsdWVUcmFuc2Zvcm1lcik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vcHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQSBtYXAgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbWVtYmVyc1xuICogQGNvbnN0IHtXZWFrTWFwfVxuICovXG52YXIgaW50ZXJuYWxzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBBbiBvYmplY3Qgc3RvcmluZyBrZXlib2FyZCBrZXkgY29kZXNcbiAqIEBjb25zdCB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gKi9cbnZhciBLZXlDb2RlID0ge1xuICBET1dOX0FSUk9XOiA0MCxcbiAgTEVGVF9BUlJPVzogMzcsXG4gIFJJR0hUX0FSUk9XOiAzOSxcbiAgVVBfQVJST1c6IDM4XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlcyBhcmUgd2l0aGluIHRoZSBtYXggYW5kIG1pbiByYW5nZSBvZiBpbnB1dFJhbmdlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge1JhbmdlfSB2YWx1ZXMgLSBNaW4vbWF4IHZhbHVlIG9mIHNsaWRlcnNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgd2l0aGluIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIGlzV2l0aGluUmFuZ2UoaW5wdXRSYW5nZSwgdmFsdWVzKSB7XG4gIHZhciBwcm9wcyA9IGlucHV0UmFuZ2UucHJvcHM7XG5cbiAgaWYgKGlucHV0UmFuZ2UuaXNNdWx0aVZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5taW4gPj0gcHJvcHMubWluVmFsdWUgJiYgdmFsdWVzLm1heCA8PSBwcm9wcy5tYXhWYWx1ZSAmJiB2YWx1ZXMubWluIDwgdmFsdWVzLm1heDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXMubWF4ID49IHByb3BzLm1pblZhbHVlICYmIHZhbHVlcy5tYXggPD0gcHJvcHMubWF4VmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB2YWx1ZXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlcyBvZiBpbnB1dFJhbmdlXG4gKiBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIGl0cyBzdGVwIGFtb3VudFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtIHtSYW5nZX0gdmFsdWVzIC0gTWluL21heCB2YWx1ZSBvZiBzbGlkZXJzXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGRpZmZlcmVuY2UgaXMgZ3JlYXRlciBvciBlcXVhbCB0byBzdGVwIGFtb3VudFxuICovXG5mdW5jdGlvbiBoYXNTdGVwRGlmZmVyZW5jZShpbnB1dFJhbmdlLCB2YWx1ZXMpIHtcbiAgdmFyIHByb3BzID0gaW5wdXRSYW5nZS5wcm9wcztcblxuICB2YXIgY3VycmVudFZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyhpbnB1dFJhbmdlKTtcblxuICByZXR1cm4gKDAsIF91dGlsLmxlbmd0aCkodmFsdWVzLm1pbiwgY3VycmVudFZhbHVlcy5taW4pID49IHByb3BzLnN0ZXAgfHwgKDAsIF91dGlsLmxlbmd0aCkodmFsdWVzLm1heCwgY3VycmVudFZhbHVlcy5tYXgpID49IHByb3BzLnN0ZXA7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXRSYW5nZSBzaG91bGQgdXBkYXRlIHdpdGggbmV3IHZhbHVlc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHBhcmFtIHtSYW5nZX0gdmFsdWVzIC0gTWluL21heCB2YWx1ZSBvZiBzbGlkZXJzXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGlucHV0UmFuZ2Ugc2hvdWxkIHVwZGF0ZVxuICovXG5mdW5jdGlvbiBzaG91bGRVcGRhdGUoaW5wdXRSYW5nZSwgdmFsdWVzKSB7XG4gIHJldHVybiBpc1dpdGhpblJhbmdlKGlucHV0UmFuZ2UsIHZhbHVlcykgJiYgaGFzU3RlcERpZmZlcmVuY2UoaW5wdXRSYW5nZSwgdmFsdWVzKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG93bmVyIGRvY3VtZW50IG9mIGlucHV0UmFuZ2VcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2UgLSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge0RvY3VtZW50fSBEb2N1bWVudFxuICovXG5mdW5jdGlvbiBnZXREb2N1bWVudChpbnB1dFJhbmdlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gaW5wdXRSYW5nZS5yZWZzLmlucHV0UmFuZ2Uub3duZXJEb2N1bWVudDtcblxuICByZXR1cm4gb3duZXJEb2N1bWVudDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNsYXNzIG5hbWUocykgb2YgaW5wdXRSYW5nZSBiYXNlZCBvbiBpdHMgcHJvcHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0lucHV0UmFuZ2V9IGlucHV0UmFuZ2UgLSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBsaXN0IG9mIGNsYXNzIG5hbWVzIGRlbGltaXRlZCB3aXRoIHNwYWNlc1xuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc05hbWUoaW5wdXRSYW5nZSkge1xuICB2YXIgcHJvcHMgPSBpbnB1dFJhbmdlLnByb3BzO1xuXG4gIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gcHJvcHMuY2xhc3NOYW1lcy5jb21wb25lbnQ7XG4gIH1cblxuICByZXR1cm4gcHJvcHMuY2xhc3NOYW1lcy5jb21wb25lbnQgKyAnIGlzLWRpc2FibGVkJztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBuYW1lIG9mIGEgc2xpZGVyXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge1NsaWRlcn0gc2xpZGVyIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGdldEtleUZyb21TbGlkZXIoaW5wdXRSYW5nZSwgc2xpZGVyKSB7XG4gIGlmIChzbGlkZXIgPT09IGlucHV0UmFuZ2UucmVmcy5zbGlkZXJNaW4pIHtcbiAgICByZXR1cm4gJ21pbic7XG4gIH1cblxuICByZXR1cm4gJ21heCc7XG59XG5cbi8qKlxuICogR2V0IGFsbCBzbGlkZXIga2V5cyBvZiBpbnB1dFJhbmdlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gS2V5IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMoaW5wdXRSYW5nZSkge1xuICBpZiAoaW5wdXRSYW5nZS5pc011bHRpVmFsdWUpIHtcbiAgICByZXR1cm4gWydtaW4nLCAnbWF4J107XG4gIH1cblxuICByZXR1cm4gWydtYXgnXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBuYW1lIG9mIGEgc2xpZGVyIHRoYXQncyB0aGUgY2xvc2VzdCB0byBhIHBvaW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHgveVxuICogQHJldHVybiB7c3RyaW5nfSBLZXkgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRLZXlCeVBvc2l0aW9uKGlucHV0UmFuZ2UsIHBvc2l0aW9uKSB7XG4gIHZhciB2YWx1ZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS52YWx1ZXNGcm9tUHJvcHMoaW5wdXRSYW5nZSk7XG4gIHZhciBwb3NpdGlvbnMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS5wb3NpdGlvbnNGcm9tVmFsdWVzKGlucHV0UmFuZ2UsIHZhbHVlcyk7XG5cbiAgaWYgKGlucHV0UmFuZ2UuaXNNdWx0aVZhbHVlKSB7XG4gICAgdmFyIGRpc3RhbmNlVG9NaW4gPSAoMCwgX3V0aWwuZGlzdGFuY2VUbykocG9zaXRpb24sIHBvc2l0aW9ucy5taW4pO1xuICAgIHZhciBkaXN0YW5jZVRvTWF4ID0gKDAsIF91dGlsLmRpc3RhbmNlVG8pKHBvc2l0aW9uLCBwb3NpdGlvbnMubWF4KTtcblxuICAgIGlmIChkaXN0YW5jZVRvTWluIDwgZGlzdGFuY2VUb01heCkge1xuICAgICAgcmV0dXJuICdtaW4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnbWF4Jztcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2Ygc2xpZGVyIEhUTUwgZm9yIHJlbmRlcmluZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZSAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEFycmF5IG9mIEhUTUxcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xpZGVycyhpbnB1dFJhbmdlKSB7XG4gIHZhciBjbGFzc05hbWVzID0gaW5wdXRSYW5nZS5wcm9wcy5jbGFzc05hbWVzO1xuXG4gIHZhciBzbGlkZXJzID0gW107XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhpbnB1dFJhbmdlKTtcbiAgdmFyIHZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyhpbnB1dFJhbmdlKTtcbiAgdmFyIHBlcmNlbnRhZ2VzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10ucGVyY2VudGFnZXNGcm9tVmFsdWVzKGlucHV0UmFuZ2UsIHZhbHVlcyk7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0ga2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICB2YXIgcGVyY2VudGFnZSA9IHBlcmNlbnRhZ2VzW2tleV07XG4gICAgICB2YXIgcmVmID0gJ3NsaWRlcicgKyAoMCwgX3V0aWwuY2FwdGlhbGl6ZSkoa2V5KTtcblxuICAgICAgdmFyIF9pbnB1dFJhbmdlJHByb3BzID0gaW5wdXRSYW5nZS5wcm9wcztcbiAgICAgIHZhciBtYXhWYWx1ZSA9IF9pbnB1dFJhbmdlJHByb3BzLm1heFZhbHVlO1xuICAgICAgdmFyIG1pblZhbHVlID0gX2lucHV0UmFuZ2UkcHJvcHMubWluVmFsdWU7XG5cbiAgICAgIGlmIChrZXkgPT09ICdtaW4nKSB7XG4gICAgICAgIG1heFZhbHVlID0gdmFsdWVzLm1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblZhbHVlID0gdmFsdWVzLm1pbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsaWRlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TbGlkZXIyWydkZWZhdWx0J10sIHtcbiAgICAgICAgYXJpYUxhYmVsbGVkYnk6IGlucHV0UmFuZ2UucHJvcHMuYXJpYUxhYmVsbGVkYnksXG4gICAgICAgIGFyaWFDb250cm9sczogaW5wdXRSYW5nZS5wcm9wcy5hcmlhQ29udHJvbHMsXG4gICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMsXG4gICAgICAgIGZvcm1hdExhYmVsOiBpbnB1dFJhbmdlLmZvcm1hdExhYmVsLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbWF4VmFsdWU6IG1heFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZTogbWluVmFsdWUsXG4gICAgICAgIG9uU2xpZGVyS2V5RG93bjogaW5wdXRSYW5nZS5oYW5kbGVTbGlkZXJLZXlEb3duLFxuICAgICAgICBvblNsaWRlck1vdXNlTW92ZTogaW5wdXRSYW5nZS5oYW5kbGVTbGlkZXJNb3VzZU1vdmUsXG4gICAgICAgIHBlcmNlbnRhZ2U6IHBlcmNlbnRhZ2UsXG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSB9KTtcblxuICAgICAgc2xpZGVycy5wdXNoKHNsaWRlcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzbGlkZXJzO1xufVxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBoaWRkZW4gaW5wdXQgSFRNTCBmb3IgcmVuZGVyaW5nXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gQXJyYXkgb2YgSFRNTFxuICovXG5mdW5jdGlvbiByZW5kZXJIaWRkZW5JbnB1dHMoaW5wdXRSYW5nZSkge1xuICB2YXIgaW5wdXRzID0gW107XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhpbnB1dFJhbmdlKTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0ga2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgdmFyIF9uYW1lID0gaW5wdXRSYW5nZS5pc011bHRpVmFsdWUgPyAnJyArIGlucHV0UmFuZ2UucHJvcHMubmFtZSArICgwLCBfdXRpbC5jYXB0aWFsaXplKShrZXkpIDogaW5wdXRSYW5nZS5wcm9wcy5uYW1lO1xuXG4gICAgICB2YXIgaW5wdXQgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7IHR5cGU6ICdoaWRkZW4nLCBuYW1lOiBfbmFtZSB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjJbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvcjJbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dHM7XG59XG5cbi8qKlxuICogSW5wdXRSYW5nZSBSZWFjdCBjb21wb25lbnRcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBSZWFjdCBjb21wb25lbnQgcHJvcHNcbiAqL1xuXG52YXIgSW5wdXRSYW5nZSA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSW5wdXRSYW5nZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSW5wdXRSYW5nZShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dFJhbmdlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKElucHV0UmFuZ2UucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgaW50ZXJuYWxzLnNldCh0aGlzLCB7fSk7XG5cbiAgICAvLyBBdXRvLWJpbmRcbiAgICAoMCwgX3V0aWwuYXV0b2JpbmQpKFsnZm9ybWF0TGFiZWwnLCAnaGFuZGxlSW50ZXJhY3Rpb25FbmQnLCAnaGFuZGxlSW50ZXJhY3Rpb25TdGFydCcsICdoYW5kbGVLZXlEb3duJywgJ2hhbmRsZUtleVVwJywgJ2hhbmRsZU1vdXNlRG93bicsICdoYW5kbGVNb3VzZVVwJywgJ2hhbmRsZVNsaWRlcktleURvd24nLCAnaGFuZGxlU2xpZGVyTW91c2VNb3ZlJywgJ2hhbmRsZVRvdWNoU3RhcnQnLCAnaGFuZGxlVG91Y2hFbmQnLCAnaGFuZGxlVHJhY2tNb3VzZURvd24nXSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0ZWQgcHJvcFR5cGVzIG9mIElucHV0UmFuZ2VcbiAgICogQHN0YXRpYyB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhcmlhTGFiZWxsZWRieVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBhcmlhQ29udHJvbHNcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2xhc3NOYW1lc1xuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkZWZhdWx0VmFsdWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGlzYWJsZWRcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZm9ybWF0TGFiZWxcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGFiZWxQcmVmaXhcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGFiZWxTdWZmaXhcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbWF4VmFsdWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbWluVmFsdWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbmFtZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbkNoYW5nZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbkNoYW5nZUNvbXBsZXRlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHN0ZXBcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY2xpZW50UmVjdCBvZiB0aGUgY29tcG9uZW50J3MgdHJhY2tcbiAgICogQG1lbWJlciB7Q2xpZW50UmVjdH1cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKElucHV0UmFuZ2UsIFt7XG4gICAga2V5OiAndXBkYXRlUG9zaXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHNsaWRlciBieSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gbWluL21heFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIHgveVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihrZXksIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmFsdWVzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVzRnJvbVByb3BzKHRoaXMpO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnBvc2l0aW9uc0Zyb21WYWx1ZXModGhpcywgdmFsdWVzKTtcblxuICAgICAgcG9zaXRpb25zW2tleV0gPSBwb3NpdGlvbjtcblxuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbnMocG9zaXRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHNsaWRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb25zLm1pblxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9ucy5tYXhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIG1pbjogX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVGcm9tUG9zaXRpb24odGhpcywgcG9zaXRpb25zLm1pbiksXG4gICAgICAgIG1heDogX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVGcm9tUG9zaXRpb24odGhpcywgcG9zaXRpb25zLm1heClcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1lZFZhbHVlcyA9IHtcbiAgICAgICAgbWluOiBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS5zdGVwVmFsdWVGcm9tVmFsdWUodGhpcywgdmFsdWVzLm1pbiksXG4gICAgICAgIG1heDogX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10uc3RlcFZhbHVlRnJvbVZhbHVlKHRoaXMsIHZhbHVlcy5tYXgpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlcyh0cmFuc2Zvcm1lZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB2YWx1ZSBvZiBhIHNsaWRlciBieSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gbWF4L21pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE5ldyB2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndXBkYXRlVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVzRnJvbVByb3BzKHRoaXMpO1xuXG4gICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIGFsbCBzbGlkZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSB2YWx1ZXMgLSBPYmplY3QgaWYgbXVsdGktdmFsdWUsIG51bWJlciBpZiBzaW5nbGUtdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVZhbHVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVZhbHVlcyh2YWx1ZXMpIHtcbiAgICAgIGlmICghc2hvdWxkVXBkYXRlKHRoaXMsIHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc011bHRpVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLCB2YWx1ZXMubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIHZhbHVlIG9mIGEgc2xpZGVyIGJ5IGtleSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIG1heC9taW5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2luY3JlbWVudFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jcmVtZW50VmFsdWUoa2V5KSB7XG4gICAgICB2YXIgdmFsdWVzID0gX3ZhbHVlVHJhbnNmb3JtZXIyWydkZWZhdWx0J10udmFsdWVzRnJvbVByb3BzKHRoaXMpO1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV0gKyB0aGlzLnByb3BzLnN0ZXA7XG5cbiAgICAgIHRoaXMudXBkYXRlVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjcmVtZW50IHRoZSB2YWx1ZSBvZiBhIHNsaWRlciBieSBrZXkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBtYXgvbWluXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkZWNyZW1lbnRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3JlbWVudFZhbHVlKGtleSkge1xuICAgICAgdmFyIHZhbHVlcyA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnZhbHVlc0Zyb21Qcm9wcyh0aGlzKTtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldIC0gdGhpcy5wcm9wcy5zdGVwO1xuXG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBsYWJlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFZhbHVlIC0gTGFiZWwgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBsYWJlbCB2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0TGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRMYWJlbChsYWJlbFZhbHVlKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBmb3JtYXRMYWJlbCA9IF9wcm9wcy5mb3JtYXRMYWJlbDtcbiAgICAgIHZhciBsYWJlbFByZWZpeCA9IF9wcm9wcy5sYWJlbFByZWZpeDtcbiAgICAgIHZhciBsYWJlbFN1ZmZpeCA9IF9wcm9wcy5sYWJlbFN1ZmZpeDtcblxuICAgICAgaWYgKGZvcm1hdExhYmVsKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRMYWJlbChsYWJlbFZhbHVlLCB7IGxhYmVsUHJlZml4OiBsYWJlbFByZWZpeCwgbGFiZWxTdWZmaXg6IGxhYmVsU3VmZml4IH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJycgKyBsYWJlbFByZWZpeCArIGxhYmVsVmFsdWUgKyBsYWJlbFN1ZmZpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IG1vdXNlbW92ZSBldmVudCByZWNlaXZlZCBieSB0aGUgc2xpZGVyXG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICogQHBhcmFtIHtTbGlkZXJ9IHNsaWRlciAtIFJlYWN0IGNvbXBvbmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlU2xpZGVyTW91c2VNb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2xpZGVyTW91c2VNb3ZlKGV2ZW50LCBzbGlkZXIpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IGdldEtleUZyb21TbGlkZXIodGhpcywgc2xpZGVyKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IF92YWx1ZVRyYW5zZm9ybWVyMlsnZGVmYXVsdCddLnBvc2l0aW9uRnJvbUV2ZW50KHRoaXMsIGV2ZW50KTtcblxuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihrZXksIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IGtleWRvd24gZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIHNsaWRlclxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqIEBwYXJhbSB7U2xpZGVyfSBzbGlkZXIgLSBSZWFjdCBjb21wb25lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVNsaWRlcktleURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTbGlkZXJLZXlEb3duKGV2ZW50LCBzbGlkZXIpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IGdldEtleUZyb21TbGlkZXIodGhpcywgc2xpZGVyKTtcblxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgS2V5Q29kZS5MRUZUX0FSUk9XOlxuICAgICAgICBjYXNlIEtleUNvZGUuRE9XTl9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuZGVjcmVtZW50VmFsdWUoa2V5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEtleUNvZGUuUklHSFRfQVJST1c6XG4gICAgICAgIGNhc2UgS2V5Q29kZS5VUF9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50VmFsdWUoa2V5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2Vkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSB0cmFja1xuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqIEBwYXJhbSB7U2xpZGVyfSBzbGlkZXIgLSBSZWFjdCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIE1vdXNlZG93biBwb3NpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlVHJhY2tNb3VzZURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUcmFja01vdXNlRG93bihldmVudCwgdHJhY2ssIHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBrZXkgPSBnZXRLZXlCeVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihrZXksIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIHN0YXJ0IG9mIGFueSB1c2VyLXRyaWdnZXJlZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlSW50ZXJhY3Rpb25TdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUludGVyYWN0aW9uU3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSBpbnRlcm5hbHMuZ2V0KHRoaXMpO1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMub25DaGFuZ2VDb21wbGV0ZSB8fCAoMCwgX3V0aWwuaXNEZWZpbmVkKShfdGhpcy5zdGFydFZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnN0YXJ0VmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlIHx8IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgZW5kIG9mIGFueSB1c2VyLXRyaWdnZXJlZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlSW50ZXJhY3Rpb25FbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVJbnRlcmFjdGlvbkVuZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IGludGVybmFscy5nZXQodGhpcyk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5vbkNoYW5nZUNvbXBsZXRlIHx8ICEoMCwgX3V0aWwuaXNEZWZpbmVkKShfdGhpcy5zdGFydFZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5zdGFydFZhbHVlICE9PSB0aGlzLnByb3BzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2VDb21wbGV0ZSh0aGlzLCB0aGlzLnByb3BzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhcnRWYWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBrZXlkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUtleURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkga2V5dXAgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlS2V5VXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVLZXlVcChldmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBtb3VzZWRvd24gZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlTW91c2VEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBnZXREb2N1bWVudCh0aGlzKTtcblxuICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0KGV2ZW50KTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBtb3VzZXVwIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBnZXREb2N1bWVudCh0aGlzKTtcblxuICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldmVudCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgdG91Y2hzdGFydCBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaFN0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25TdGFydChldmVudCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSB0b3VjaGVuZCBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaEVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBnZXREb2N1bWVudCh0aGlzKTtcblxuICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldmVudCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG1ldGhvZCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb21wb25lbnQgSlNYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMucHJvcHMuY2xhc3NOYW1lcztcblxuICAgICAgdmFyIGNvbXBvbmVudENsYXNzTmFtZSA9IGdldENvbXBvbmVudENsYXNzTmFtZSh0aGlzKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS52YWx1ZXNGcm9tUHJvcHModGhpcyk7XG4gICAgICB2YXIgcGVyY2VudGFnZXMgPSBfdmFsdWVUcmFuc2Zvcm1lcjJbJ2RlZmF1bHQnXS5wZXJjZW50YWdlc0Zyb21WYWx1ZXModGhpcywgdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogdGhpcy5wcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgICByZWY6ICdpbnB1dFJhbmdlJyxcbiAgICAgICAgICBjbGFzc05hbWU6IGNvbXBvbmVudENsYXNzTmFtZSxcbiAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgICBvbktleVVwOiB0aGlzLmhhbmRsZUtleVVwLFxuICAgICAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcbiAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCB9LFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBfTGFiZWwyWydkZWZhdWx0J10sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmxhYmVsTWluLFxuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiBjbGFzc05hbWVzLmxhYmVsQ29udGFpbmVyLFxuICAgICAgICAgICAgZm9ybWF0TGFiZWw6IHRoaXMuZm9ybWF0TGFiZWwgfSxcbiAgICAgICAgICB0aGlzLnByb3BzLm1pblZhbHVlXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIF9UcmFjazJbJ2RlZmF1bHQnXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICAgICAgcmVmOiAndHJhY2snLFxuICAgICAgICAgICAgcGVyY2VudGFnZXM6IHBlcmNlbnRhZ2VzLFxuICAgICAgICAgICAgb25UcmFja01vdXNlRG93bjogdGhpcy5oYW5kbGVUcmFja01vdXNlRG93biB9LFxuICAgICAgICAgIHJlbmRlclNsaWRlcnModGhpcylcbiAgICAgICAgKSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX0xhYmVsMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbE1heCxcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgIGZvcm1hdExhYmVsOiB0aGlzLmZvcm1hdExhYmVsIH0sXG4gICAgICAgICAgdGhpcy5wcm9wcy5tYXhWYWx1ZVxuICAgICAgICApLFxuICAgICAgICByZW5kZXJIaWRkZW5JbnB1dHModGhpcylcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJhY2tDbGllbnRSZWN0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMucmVmcy50cmFjaztcblxuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiB0cmFjay5jbGllbnRSZWN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgd2lkdGg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIGNvbXBvbmVudCBhY2NlcHRzIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2lzTXVsdGlWYWx1ZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF91dGlsLmlzT2JqZWN0KSh0aGlzLnByb3BzLnZhbHVlKSB8fCAoMCwgX3V0aWwuaXNPYmplY3QpKHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5wdXRSYW5nZTtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBJbnB1dFJhbmdlO1xuSW5wdXRSYW5nZS5wcm9wVHlwZXMgPSB7XG4gIGFyaWFMYWJlbGxlZGJ5OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgYXJpYUNvbnRyb2xzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3RPZihfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyksXG4gIGRlZmF1bHRWYWx1ZTogX3Byb3BUeXBlcy5tYXhNaW5WYWx1ZVByb3BUeXBlLFxuICBkaXNhYmxlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLFxuICBmb3JtYXRMYWJlbDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICBsYWJlbFByZWZpeDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsU3VmZml4OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZyxcbiAgbWF4VmFsdWU6IF9wcm9wVHlwZXMubWF4TWluVmFsdWVQcm9wVHlwZSxcbiAgbWluVmFsdWU6IF9wcm9wVHlwZXMubWF4TWluVmFsdWVQcm9wVHlwZSxcbiAgbmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ2hhbmdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25DaGFuZ2VDb21wbGV0ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICBzdGVwOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgdmFsdWU6IF9wcm9wVHlwZXMubWF4TWluVmFsdWVQcm9wVHlwZVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHByb3BzIG9mIElucHV0UmFuZ2VcbiAqIEBzdGF0aWMge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IGRlZmF1bHRDbGFzc05hbWVzXG4gKiBAcHJvcGVydHkge1JhbmdlfG51bWJlcn0gZGVmYXVsdFZhbHVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRpc2FibGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxQcmVmaXhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbFN1ZmZpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVwXG4gKiBAcHJvcGVydHkge1JhbmdlfG51bWJlcn0gdmFsdWVcbiAqL1xuSW5wdXRSYW5nZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZXM6IF9kZWZhdWx0Q2xhc3NOYW1lczJbJ2RlZmF1bHQnXSxcbiAgZGVmYXVsdFZhbHVlOiAwLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGxhYmVsUHJlZml4OiAnJyxcbiAgbGFiZWxTdWZmaXg6ICcnLFxuICBtYXhWYWx1ZTogMTAsXG4gIG1pblZhbHVlOiAwLFxuICBzdGVwOiAxLFxuICB2YWx1ZTogbnVsbFxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL0xhYmVsXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG4vKipcbiAqIExhYmVsIFJlYWN0IGNvbXBvbmVudFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFJlYWN0IGNvbXBvbmVudCBwcm9wc1xuICovXG5cbnZhciBMYWJlbCA9IChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGFiZWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExhYmVsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihMYWJlbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdGVkIHByb3BUeXBlcyBvZiBMYWJlbFxuICAgKiBAc3RhdGljIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNoaWxkcmVuXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNsYXNzTmFtZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb250YWluZXJDbGFzc05hbWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZm9ybWF0TGFiZWxcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKExhYmVsLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbWV0aG9kIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbXBvbmVudCBKU1hcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gX3Byb3BzLmNsYXNzTmFtZTtcbiAgICAgIHZhciBjb250YWluZXJDbGFzc05hbWUgPSBfcHJvcHMuY29udGFpbmVyQ2xhc3NOYW1lO1xuXG4gICAgICB2YXIgbGFiZWxWYWx1ZSA9IHRoaXMucHJvcHMuZm9ybWF0TGFiZWwgPyB0aGlzLnByb3BzLmZvcm1hdExhYmVsKHRoaXMucHJvcHMuY2hpbGRyZW4pIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3BhbicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiBjb250YWluZXJDbGFzc05hbWUgfSxcbiAgICAgICAgICBsYWJlbFZhbHVlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsO1xufSkoX3JlYWN0MlsnZGVmYXVsdCddLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExhYmVsO1xuTGFiZWwucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ub2RlLFxuICBjbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBjb250YWluZXJDbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLFxuICBmb3JtYXRMYWJlbDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLyoqXG4gKiBAbW9kdWxlIElucHV0UmFuZ2UvU2xpZGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xhYmVsID0gcmVxdWlyZSgnLi9MYWJlbCcpO1xuXG52YXIgX0xhYmVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xhYmVsKTtcblxudmFyIF91dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogR2V0IHRoZSBvd25lciBkb2N1bWVudCBvZiBzbGlkZXJcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NsaWRlcn0gc2xpZGVyIC0gUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gRG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc2xpZGVyKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gc2xpZGVyLnJlZnMuc2xpZGVyLm93bmVyRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzdHlsZSBvZiBzbGlkZXIgYmFzZWQgb24gaXRzIHByb3BzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTbGlkZXJ9IHNsaWRlciAtIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7T2JqZWN0fSBDU1Mgc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKHNsaWRlcikge1xuICB2YXIgcGVyYyA9IChzbGlkZXIucHJvcHMucGVyY2VudGFnZSB8fCAwKSAqIDEwMDtcbiAgdmFyIHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGxlZnQ6IHBlcmMgKyAnJSdcbiAgfTtcblxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogU2xpZGVyIFJlYWN0IGNvbXBvbmVudFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFJlYWN0IGNvbXBvbmVudCBwcm9wc1xuICovXG5cbnZhciBTbGlkZXIgPSAoZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNsaWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU2xpZGVyKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTbGlkZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBBdXRvLWJpbmRcbiAgICAoMCwgX3V0aWwuYXV0b2JpbmQpKFsnaGFuZGxlQ2xpY2snLCAnaGFuZGxlTW91c2VEb3duJywgJ2hhbmRsZU1vdXNlVXAnLCAnaGFuZGxlTW91c2VNb3ZlJywgJ2hhbmRsZVRvdWNoU3RhcnQnLCAnaGFuZGxlVG91Y2hFbmQnLCAnaGFuZGxlVG91Y2hNb3ZlJywgJ2hhbmRsZUtleURvd24nXSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0ZWQgcHJvcFR5cGVzIG9mIFNsaWRlclxuICAgKiBAc3RhdGljIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFyaWFMYWJlbGxlZGJ5XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFyaWFDb250cm9sc1xuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjbGFzc05hbWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZm9ybWF0TGFiZWxcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbWF4VmFsdWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbWluVmFsdWVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25TbGlkZXJLZXlEb3duXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uU2xpZGVyTW91c2VNb3ZlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBlcmNlbnRhZ2VcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdHlwZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB2YWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGFueSBjbGljayBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgIGtleTogJ2hhbmRsZUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBtb3VzZWRvd24gZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlTW91c2VEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIC8vIEV2ZW50XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IG1vdXNldXAgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlTW91c2VVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBnZXREb2N1bWVudCh0aGlzKTtcblxuICAgICAgLy8gRXZlbnRcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2Vtb3ZlIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgdGhpcy5wcm9wcy5vblNsaWRlck1vdXNlTW92ZShldmVudCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSB0b3VjaHN0YXJ0IGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVRvdWNoU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBnZXREb2N1bWVudCh0aGlzKTtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IHRvdWNobW92ZSBldmVudCByZWNlaXZlZCBieSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgLSBVc2VyIGV2ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaE1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZXZlbnQpIHtcbiAgICAgIHRoaXMucHJvcHMub25TbGlkZXJNb3VzZU1vdmUoZXZlbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgdG91Y2hlbmQgZXZlbnQgcmVjZWl2ZWQgYnkgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IC0gVXNlciBldmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlVG91Y2hFbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZChldmVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQodGhpcyk7XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSBrZXlkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZUtleURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICB0aGlzLnByb3BzLm9uU2xpZGVyS2V5RG93bihldmVudCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG1ldGhvZCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb21wb25lbnQgSlNYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMucHJvcHMuY2xhc3NOYW1lcztcbiAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKHRoaXMpO1xuXG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdzcGFuJyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5zbGlkZXJDb250YWluZXIsXG4gICAgICAgICAgcmVmOiAnc2xpZGVyJyxcbiAgICAgICAgICBzdHlsZTogc3R5bGUgfSxcbiAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgX0xhYmVsMlsnZGVmYXVsdCddLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5sYWJlbFZhbHVlLFxuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiBjbGFzc05hbWVzLmxhYmVsQ29udGFpbmVyLFxuICAgICAgICAgICAgZm9ybWF0TGFiZWw6IHRoaXMucHJvcHMuZm9ybWF0TGFiZWwgfSxcbiAgICAgICAgICB0aGlzLnByb3BzLnZhbHVlXG4gICAgICAgICksXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdhJywge1xuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0aGlzLnByb3BzLmFyaWFMYWJlbGxlZGJ5LFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5wcm9wcy5hcmlhQ29udHJvbHMsXG4gICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLnByb3BzLm1heFZhbHVlLFxuICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogdGhpcy5wcm9wcy5taW5WYWx1ZSxcbiAgICAgICAgICAnYXJpYS12YWx1ZW5vdyc6IHRoaXMucHJvcHMuZm9ybWF0TGFiZWwgPyB0aGlzLnByb3BzLmZvcm1hdExhYmVsKHRoaXMucHJvcHMudmFsdWUpIDogdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuc2xpZGVyLFxuICAgICAgICAgIGRyYWdnYWJsZTogJ2ZhbHNlJyxcbiAgICAgICAgICBocmVmOiAnIycsXG4gICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljayxcbiAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5oYW5kbGVNb3VzZURvd24sXG4gICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXG4gICAgICAgICAgcm9sZTogJ3NsaWRlcicgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0pKF9yZWFjdDJbJ2RlZmF1bHQnXS5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTbGlkZXI7XG5TbGlkZXIucHJvcFR5cGVzID0ge1xuICBhcmlhTGFiZWxsZWRieTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGFyaWFDb250cm9sczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICBmb3JtYXRMYWJlbDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuICBtYXhWYWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIsXG4gIG1pblZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlcixcbiAgb25TbGlkZXJLZXlEb3duOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25TbGlkZXJNb3VzZU1vdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwZXJjZW50YWdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB0eXBlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICB2YWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL1RyYWNrXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ1JlYWN0J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydSZWFjdCddIDogbnVsbCk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBHZXQgdGhlIENTUyBzdHlsZXMgZm9yIGFuIGFjdGl2ZSB0cmFja1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7T2JqZWN0fSBDU1Mgc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrU3R5bGUodHJhY2spIHtcbiAgdmFyIHByb3BzID0gdHJhY2sucHJvcHM7XG5cbiAgdmFyIHdpZHRoID0gKHByb3BzLnBlcmNlbnRhZ2VzLm1heCAtIHByb3BzLnBlcmNlbnRhZ2VzLm1pbikgKiAxMDAgKyAnJSc7XG4gIHZhciBsZWZ0ID0gcHJvcHMucGVyY2VudGFnZXMubWluICogMTAwICsgJyUnO1xuXG4gIHZhciBhY3RpdmVUcmFja1N0eWxlID0ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgd2lkdGg6IHdpZHRoXG4gIH07XG5cbiAgcmV0dXJuIGFjdGl2ZVRyYWNrU3R5bGU7XG59XG5cbi8qKlxuICogVHJhY2sgUmVhY3QgY29tcG9uZW50XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUmVhY3QgY29tcG9uZW50IHByb3BzXG4gKi9cblxudmFyIFRyYWNrID0gKGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUcmFjaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhY2socHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHJhY2sucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBBdXRvLWJpbmRcbiAgICAoMCwgX3V0aWwuYXV0b2JpbmQpKFsnaGFuZGxlTW91c2VEb3duJywgJ2hhbmRsZVRvdWNoU3RhcnQnXSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0ZWQgcHJvcFR5cGVzIG9mIFRyYWNrXG4gICAqIEBzdGF0aWMge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2hpbGRyZW5cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2xhc3NOYW1lc1xuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvblRyYWNrTW91c2VEb3duXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBlcmNlbnRhZ2VzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNsaWVudFJlY3Qgb2YgdGhlIGNvbXBvbmVudFxuICAgKiBAbWVtYmVyIHtDbGllbnRSZWN0fVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoVHJhY2ssIFt7XG4gICAga2V5OiAnaGFuZGxlTW91c2VEb3duJyxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgbW91c2Vkb3duIGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICB2YXIgdHJhY2tDbGllbnRSZWN0ID0gdGhpcy5jbGllbnRSZWN0O1xuXG4gICAgICB2YXIgX3JlZiA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQ7XG5cbiAgICAgIHZhciBjbGllbnRYID0gX3JlZi5jbGllbnRYO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6IGNsaWVudFggLSB0cmFja0NsaWVudFJlY3QubGVmdCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcblxuICAgICAgdGhpcy5wcm9wcy5vblRyYWNrTW91c2VEb3duKGV2ZW50LCB0aGlzLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSB0b3VjaHN0YXJ0IGV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCAtIFVzZXIgZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVRvdWNoU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG1ldGhvZCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb21wb25lbnQgSlNYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgYWN0aXZlVHJhY2tTdHlsZSA9IGdldEFjdGl2ZVRyYWNrU3R5bGUodGhpcyk7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMucHJvcHMuY2xhc3NOYW1lcztcblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy50cmFja0NvbnRhaW5lcixcbiAgICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5oYW5kbGVNb3VzZURvd24sXG4gICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXG4gICAgICAgICAgcmVmOiAndHJhY2snIH0sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgc3R5bGU6IGFjdGl2ZVRyYWNrU3R5bGUsXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnRyYWNrQWN0aXZlIH0pLFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsaWVudFJlY3QnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy5yZWZzLnRyYWNrO1xuXG4gICAgICB2YXIgY2xpZW50UmVjdCA9IHRyYWNrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhY2s7XG59KShfcmVhY3QyWydkZWZhdWx0J10uQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVHJhY2s7XG5UcmFjay5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm5vZGUsXG4gIGNsYXNzTmFtZXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcpLFxuICBvblRyYWNrTW91c2VEb3duOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgcGVyY2VudGFnZXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0T2YoX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5udW1iZXIpLmlzUmVxdWlyZWRcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIEBtb2R1bGUgSW5wdXRSYW5nZS9kZWZhdWx0Q2xhc3NOYW1lc1xuICovXG5cbi8qKlxuKiBBbiBvYmplY3QgY29udGFpbmluZyBjbGFzcyBuYW1lc1xuKiBAY29uc3Qge09iamVjdH1cbiogQHByb3BlcnR5IHtzdHJpbmd9IGNvbXBvbmVudFxuKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxDb250YWluZXJcbiogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsTWF4XG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbE1pblxuKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWxWYWx1ZVxuKiBAcHJvcGVydHkge3N0cmluZ30gc2xpZGVyXG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSBzbGlkZXJDb250YWluZXJcbiogQHByb3BlcnR5IHtzdHJpbmd9IHRyYWNrQWN0aXZlXG4qIEBwcm9wZXJ0eSB7c3RyaW5nfSB0cmFja0NvbnRhaW5lclxuKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGNvbXBvbmVudDogJ0lucHV0UmFuZ2UnLFxuICBsYWJlbENvbnRhaW5lcjogJ0lucHV0UmFuZ2UtbGFiZWxDb250YWluZXInLFxuICBsYWJlbE1heDogJ0lucHV0UmFuZ2UtbGFiZWwgSW5wdXRSYW5nZS1sYWJlbC0tbWF4JyxcbiAgbGFiZWxNaW46ICdJbnB1dFJhbmdlLWxhYmVsIElucHV0UmFuZ2UtbGFiZWwtLW1pbicsXG4gIGxhYmVsVmFsdWU6ICdJbnB1dFJhbmdlLWxhYmVsIElucHV0UmFuZ2UtbGFiZWwtLXZhbHVlJyxcbiAgc2xpZGVyOiAnSW5wdXRSYW5nZS1zbGlkZXInLFxuICBzbGlkZXJDb250YWluZXI6ICdJbnB1dFJhbmdlLXNsaWRlckNvbnRhaW5lcicsXG4gIHRyYWNrQWN0aXZlOiAnSW5wdXRSYW5nZS10cmFjayBJbnB1dFJhbmdlLXRyYWNrLS1hY3RpdmUnLFxuICB0cmFja0NvbnRhaW5lcjogJ0lucHV0UmFuZ2UtdHJhY2sgSW5wdXRSYW5nZS10cmFjay0tY29udGFpbmVyJ1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0lucHV0UmFuZ2UgPSByZXF1aXJlKCcuL0lucHV0UmFuZ2UnKTtcblxudmFyIF9JbnB1dFJhbmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0lucHV0UmFuZ2UpO1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IHZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgdmFsdWVcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSYW5nZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbiAtIE1pbiB2YWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCAtIE1heCB2YWx1ZVxuICovXG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9JbnB1dFJhbmdlMlsnZGVmYXVsdCddO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLyoqXG4gKiBAbW9kdWxlIElucHV0UmFuZ2UvbWF4TWluVmFsdWVQcm9wVHlwZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1heE1pblZhbHVlUHJvcFR5cGUgPSBtYXhNaW5WYWx1ZVByb3BUeXBlO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBBIHByb3AgdHlwZSBhY2NlcHRpbmcgYSByYW5nZSBvZiBudW1lcmljIHZhbHVlcyBvciBhIHNpbmdsZSBudW1lcmljIHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBSZWFjdCBjb21wb25lbnQgcHJvcHNcbiAqIEByZXR1cm4gez9FcnJvcn0gUmV0dXJuIEVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHNcbiAqL1xuXG5mdW5jdGlvbiBtYXhNaW5WYWx1ZVByb3BUeXBlKHByb3BzKSB7XG4gIHZhciBtYXhWYWx1ZSA9IHByb3BzLm1heFZhbHVlO1xuICB2YXIgbWluVmFsdWUgPSBwcm9wcy5taW5WYWx1ZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBpc1ZhbHVlTnVtYmVyID0gKDAsIF91dGlsLmlzTnVtYmVyKSh2YWx1ZSk7XG4gIHZhciBpc0RlZmF1bHRWYWx1ZU51bWJlciA9ICgwLCBfdXRpbC5pc051bWJlcikoZGVmYXVsdFZhbHVlKTtcbiAgdmFyIGlzVmFsdWVOdW1iZXJPYmplY3QgPSAoMCwgX3V0aWwub2JqZWN0T2YpKHZhbHVlLCBfdXRpbC5pc051bWJlcik7XG4gIHZhciBpc0RlZmF1bHRWYWx1ZU51bWJlck9iamVjdCA9ICgwLCBfdXRpbC5vYmplY3RPZikoZGVmYXVsdFZhbHVlLCBfdXRpbC5pc051bWJlcik7XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdgdmFsdWVgIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG5cbiAgaWYgKCFpc1ZhbHVlTnVtYmVyICYmICFpc0RlZmF1bHRWYWx1ZU51bWJlciAmJiAhaXNWYWx1ZU51bWJlck9iamVjdCAmJiAhaXNEZWZhdWx0VmFsdWVOdW1iZXJPYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdgdmFsdWVgIG9yIGBkZWZhdWx0VmFsdWVgIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gYXJyYXknKTtcbiAgfVxuXG4gIGlmIChtaW5WYWx1ZSA+PSBtYXhWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ2BtaW5WYWx1ZWAgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYG1heFZhbHVlYCcpO1xuICB9XG5cbiAgaWYgKG1heFZhbHVlIDw9IG1pblZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignYG1heFZhbHVlYCBtdXN0IGJlIGxhcmdlciB0aGFuIGBtaW5WYWx1ZWAnKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8IG1pblZhbHVlIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdgdmFsdWVgIG11c3QgYmUgd2l0aGluIGBtaW5WYWx1ZWAgYW5kIGBtYXhWYWx1ZWAnKTtcbiAgfVxufSIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL3V0aWxcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBwcmVkaWNhdGVGblxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG4vKipcbiAqIENsYW1wIGEgdmFsdWUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IHZhbHVlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZXhwb3J0cy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuZXhwb3J0cy5vbWl0ID0gb21pdDtcbmV4cG9ydHMuY2FwdGlhbGl6ZSA9IGNhcHRpYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlVG8gPSBkaXN0YW5jZVRvO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzRGVmaW5lZCA9IGlzRGVmaW5lZDtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmFycmF5T2YgPSBhcnJheU9mO1xuZXhwb3J0cy5vYmplY3RPZiA9IG9iamVjdE9mO1xuZXhwb3J0cy5hdXRvYmluZCA9IGF1dG9iaW5kO1xuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG4vKipcbiAqIEV4dGVuZCBhbiBPYmplY3RcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIC0gU291cmNlIG9iamVjdHNcbiAqIEByZXR1cm4ge09iamVjdH0gRGVzdGluYXRpb24gb2JqZWN0LCBleHRlbmRlZCB3aXRoIG1lbWJlcnMgZnJvbSBzb3VyY2VzXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBpbmNsdWRlZCBpbiBhbiBhcnJheVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpID4gLTE7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBzcGVjaWZpZWQga2V5c1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gb21pdEtleXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBvbWl0KG9iaiwgb21pdEtleXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgb3V0cHV0T2JqID0ge307XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWluY2x1ZGVzKG9taXRLZXlzLCBrZXkpKSB7XG4gICAgICBvdXRwdXRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dE9iajtcbn1cblxuLyoqXG4gKiBDYXB0aWFsaXplIGEgc3RyaW5nXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY2FwdGlhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRBIGFuZCBwb2ludEJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50QVxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRCXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VUbyhwb2ludEEsIHBvaW50Qikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50Qi54IC0gcG9pbnRBLngsIDIpICsgTWF0aC5wb3cocG9pbnRCLnkgLSBwb2ludEEueSwgMikpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBudW1iZXJzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtQVxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBsZW5ndGgobnVtQSwgbnVtQikge1xuICByZXR1cm4gTWF0aC5hYnMobnVtQSAtIG51bUIpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBudW1iZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBvYmplY3RcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBkZWZpbmVkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbGwgaXRlbXMgaW4gYW4gYXJyYXkgbWF0Y2ggYSBwcmVkaWNhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge3ByZWRpY2F0ZUZufSBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gYXJyYXlPZihhcnJheSwgcHJlZGljYXRlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbGwgaXRlbXMgaW4gYW4gb2JqZWN0IG1hdGNoIGEgcHJlZGljYXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3ByZWRpY2F0ZUZufSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGtleXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0T2Yob2JqZWN0LCBwcmVkaWNhdGUsIGtleXMpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3BzID0ga2V5cyB8fCBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG5cbiAgICBpZiAoIXByZWRpY2F0ZShvYmplY3RbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQmluZCBhbGwgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gaXRzZWxmXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0FycmF5LjxGdW5jdGlvbj59IG1ldGhvZE5hbWVzXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VcbiAqL1xuXG5mdW5jdGlvbiBhdXRvYmluZChtZXRob2ROYW1lcywgaW5zdGFuY2UpIHtcbiAgbWV0aG9kTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGluc3RhbmNlW21ldGhvZE5hbWVdID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0uYmluZChpbnN0YW5jZSk7XG4gIH0pO1xufSIsIi8qKlxuICogQG1vZHVsZSBJbnB1dFJhbmdlL3ZhbHVlVHJhbnNmb3JtZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBDb252ZXJ0IHBvc2l0aW9uIGludG8gcGVyY2VudGFnZSB2YWx1ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICogQHJldHVybiB7bnVtYmVyfSBQZXJjZW50YWdlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHBlcmNlbnRhZ2VGcm9tUG9zaXRpb24oaW5wdXRSYW5nZSwgcG9zaXRpb24pIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0UmFuZ2UudHJhY2tDbGllbnRSZWN0LndpZHRoO1xuICB2YXIgc2l6ZVBlcmMgPSBwb3NpdGlvbi54IC8gbGVuZ3RoO1xuXG4gIHJldHVybiBzaXplUGVyYyB8fCAwO1xufVxuXG4vKipcbiAqIENvbnZlcnQgcG9zaXRpb24gaW50byBtb2RlbCB2YWx1ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvblxuICogQHJldHVybiB7bnVtYmVyfSBNb2RlbCB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWx1ZUZyb21Qb3NpdGlvbihpbnB1dFJhbmdlLCBwb3NpdGlvbikge1xuICB2YXIgc2l6ZVBlcmMgPSBwZXJjZW50YWdlRnJvbVBvc2l0aW9uKGlucHV0UmFuZ2UsIHBvc2l0aW9uKTtcbiAgdmFyIHZhbHVlRGlmZiA9IGlucHV0UmFuZ2UucHJvcHMubWF4VmFsdWUgLSBpbnB1dFJhbmdlLnByb3BzLm1pblZhbHVlO1xuICB2YXIgdmFsdWUgPSBpbnB1dFJhbmdlLnByb3BzLm1pblZhbHVlICsgdmFsdWVEaWZmICogc2l6ZVBlcmM7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdmFsdWVzIGZyb20gcHJvcHNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtQb2ludH0gW3Byb3BzPWlucHV0UmFuZ2UucHJvcHNdXG4gKiBAcmV0dXJuIHtSYW5nZX0gUmFuZ2UgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHZhbHVlc0Zyb21Qcm9wcyhpbnB1dFJhbmdlKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gaW5wdXRSYW5nZSA6IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzO1xuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5wdXRSYW5nZS5pc011bHRpVmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBwcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKCgwLCBfdXRpbC5pc0VtcHR5KSh2YWx1ZXMpIHx8ICEoMCwgX3V0aWwub2JqZWN0T2YpKHZhbHVlcywgX3V0aWwuaXNOdW1iZXIpKSB7XG4gICAgICAgIHZhbHVlcyA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodmFsdWVzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSAoMCwgX3V0aWwuaXNOdW1iZXIpKHByb3BzLnZhbHVlKSA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogcHJvcHMubWluVmFsdWUsXG4gICAgICBtYXg6IHZhbHVlXG4gICAgfTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIGludG8gcGVyY2VudGFnZSB2YWx1ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gUGVyY2VudGFnZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBwZXJjZW50YWdlRnJvbVZhbHVlKGlucHV0UmFuZ2UsIHZhbHVlKSB7XG4gIHZhciB2YWxpZFZhbHVlID0gKDAsIF91dGlsLmNsYW1wKSh2YWx1ZSwgaW5wdXRSYW5nZS5wcm9wcy5taW5WYWx1ZSwgaW5wdXRSYW5nZS5wcm9wcy5tYXhWYWx1ZSk7XG4gIHZhciB2YWx1ZURpZmYgPSBpbnB1dFJhbmdlLnByb3BzLm1heFZhbHVlIC0gaW5wdXRSYW5nZS5wcm9wcy5taW5WYWx1ZTtcbiAgdmFyIHZhbHVlUGVyYyA9ICh2YWxpZFZhbHVlIC0gaW5wdXRSYW5nZS5wcm9wcy5taW5WYWx1ZSkgLyB2YWx1ZURpZmY7XG5cbiAgcmV0dXJuIHZhbHVlUGVyYyB8fCAwO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdmFsdWVzIGludG8gcGVyY2VudGFnZSB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtSYW5nZX0gdmFsdWVzXG4gKiBAcmV0dXJuIHtSYW5nZX0gUGVyY2VudGFnZSB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gcGVyY2VudGFnZXNGcm9tVmFsdWVzKGlucHV0UmFuZ2UsIHZhbHVlcykge1xuICB2YXIgcGVyY2VudGFnZXMgPSB7XG4gICAgbWluOiBwZXJjZW50YWdlRnJvbVZhbHVlKGlucHV0UmFuZ2UsIHZhbHVlcy5taW4pLFxuICAgIG1heDogcGVyY2VudGFnZUZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZXMubWF4KVxuICB9O1xuXG4gIHJldHVybiBwZXJjZW50YWdlcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIGludG8gcG9zaXRpb25cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtQb2ludH0gUG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gcG9zaXRpb25Gcm9tVmFsdWUoaW5wdXRSYW5nZSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0UmFuZ2UudHJhY2tDbGllbnRSZWN0LndpZHRoO1xuICB2YXIgdmFsdWVQZXJjID0gcGVyY2VudGFnZUZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZSk7XG4gIHZhciBwb3NpdGlvblZhbHVlID0gdmFsdWVQZXJjICogbGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgeDogcG9zaXRpb25WYWx1ZSxcbiAgICB5OiAwXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBhIHJhbmdlIG9mIHZhbHVlcyBpbnRvIHBvc2l0aW9uc1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlXG4gKiBAcGFyYW0ge1JhbmdlfSB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBQb2ludD59XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uc0Zyb21WYWx1ZXMoaW5wdXRSYW5nZSwgdmFsdWVzKSB7XG4gIHZhciBwb3NpdGlvbnMgPSB7XG4gICAgbWluOiBwb3NpdGlvbkZyb21WYWx1ZShpbnB1dFJhbmdlLCB2YWx1ZXMubWluKSxcbiAgICBtYXg6IHBvc2l0aW9uRnJvbVZhbHVlKGlucHV0UmFuZ2UsIHZhbHVlcy5tYXgpXG4gIH07XG5cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgcG9zaXRpb24gZnJvbSBhbiBldmVudFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtJbnB1dFJhbmdlfSBpbnB1dFJhbmdlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7UG9pbnR9XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uRnJvbUV2ZW50KGlucHV0UmFuZ2UsIGV2ZW50KSB7XG4gIHZhciB0cmFja0NsaWVudFJlY3QgPSBpbnB1dFJhbmdlLnRyYWNrQ2xpZW50UmVjdDtcbiAgdmFyIGxlbmd0aCA9IHRyYWNrQ2xpZW50UmVjdC53aWR0aDtcblxuICB2YXIgX3JlZjIgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuXG4gIHZhciBjbGllbnRYID0gX3JlZjIuY2xpZW50WDtcblxuICB2YXIgcG9zaXRpb24gPSB7XG4gICAgeDogKDAsIF91dGlsLmNsYW1wKShjbGllbnRYIC0gdHJhY2tDbGllbnRSZWN0LmxlZnQsIDAsIGxlbmd0aCksXG4gICAgeTogMFxuICB9O1xuXG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIHN0ZXAgdmFsdWVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7SW5wdXRSYW5nZX0gaW5wdXRSYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFN0ZXAgdmFsdWVcbiAqL1xuZnVuY3Rpb24gc3RlcFZhbHVlRnJvbVZhbHVlKGlucHV0UmFuZ2UsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gaW5wdXRSYW5nZS5wcm9wcy5zdGVwKSAqIGlucHV0UmFuZ2UucHJvcHMuc3RlcDtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBwZXJjZW50YWdlRnJvbVBvc2l0aW9uOiBwZXJjZW50YWdlRnJvbVBvc2l0aW9uLFxuICBwZXJjZW50YWdlRnJvbVZhbHVlOiBwZXJjZW50YWdlRnJvbVZhbHVlLFxuICBwZXJjZW50YWdlc0Zyb21WYWx1ZXM6IHBlcmNlbnRhZ2VzRnJvbVZhbHVlcyxcbiAgcG9zaXRpb25Gcm9tRXZlbnQ6IHBvc2l0aW9uRnJvbUV2ZW50LFxuICBwb3NpdGlvbkZyb21WYWx1ZTogcG9zaXRpb25Gcm9tVmFsdWUsXG4gIHBvc2l0aW9uc0Zyb21WYWx1ZXM6IHBvc2l0aW9uc0Zyb21WYWx1ZXMsXG4gIHN0ZXBWYWx1ZUZyb21WYWx1ZTogc3RlcFZhbHVlRnJvbVZhbHVlLFxuICB2YWx1ZUZyb21Qb3NpdGlvbjogdmFsdWVGcm9tUG9zaXRpb24sXG4gIHZhbHVlc0Zyb21Qcm9wczogdmFsdWVzRnJvbVByb3BzXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLypcbiAqIE5BU0EgV29ybGR2aWV3XG4gKlxuICogVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IGRldmVsb3BlZCBhdCBOQVNBL0dvZGRhcmQgU3BhY2UgRmxpZ2h0IENlbnRlciBmb3JcbiAqIHRoZSBFYXJ0aCBTY2llbmNlIERhdGEgYW5kIEluZm9ybWF0aW9uIFN5c3RlbSAoRVNESVMpIHByb2plY3QuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEzIC0gMjAxNiBVbml0ZWQgU3RhdGVzIEdvdmVybm1lbnQgYXMgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiBBZG1pbmlzdHJhdG9yIG9mIHRoZSBOYXRpb25hbCBBZXJvbmF1dGljcyBhbmQgU3BhY2UgQWRtaW5pc3RyYXRpb24uXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOQVNBIE9wZW4gU291cmNlIEFncmVlbWVudCwgVmVyc2lvbiAxLjNcbiAqIGh0dHA6Ly9vcGVuc291cmNlLmdzZmMubmFzYS5nb3Yvbm9zYS5waHBcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi4vdG9vbHRpcC93di50b29sdGlwJztcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBCdWlsZHMgYSByYXRoZXIgc3BlY2lmaWNcbiAqIGludGVyYWN0aXZlIHdpZGdldFxuICpcbiAqIEBjbGFzcyBBbmltYXRpb25XaWRnZXRcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBhbmltV2lkZ2V0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSd3di1hbmltYXRpb24td2lkZ2V0LWhlYWRlcic+XG4gICAgICAgIHsnQW5pbWF0ZSBNYXAgaW4gJ31cbiAgICAgICAgPFRvb2x0aXAgdGV4dD17dGhpcy5wcm9wcy50ZXh0fSBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ2xpY2t9IGRhdGFBcnJheT17dGhpcy5wcm9wcy50b29sVGlwVGV4dEFycmF5fS8+XG4gICAgICAgIHsnIEluY3JlbWVudHMnfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbnB1dFJhbmdlIGZyb20gJ3JlYWN0LWlucHV0LXJhbmdlJztcbmltcG9ydCBUaW1lU2VsZWN0b3IgZnJvbSAnLi4vZGF0ZXNlbGVjdG9yL3d2LmRhdGVzZWxlY3Rvcic7XG5pbXBvcnQgTG9vcEJ1dHRvbiBmcm9tICcuL3d2Lmxvb3BidXR0b24nO1xuaW1wb3J0IFBsYXlCdXR0b24gZnJvbSAnLi93di5wbGF5YnV0dG9uJztcbmltcG9ydCBBbmltV2lkZ2V0SGVhZGVyIGZyb20gJy4vd3YuYW5pbWF0aW9uLndpZGdldC5oZWFkZXInO1xuaW1wb3J0IEdBIGZyb20gJy4uL3V0aWwvd3YuZ29vZ2xlQW5hbHl0aWNzJztcblxuXG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgQnVpbGRzIGEgcmF0aGVyIHNwZWNpZmljXG4gKiBpbnRlcmFjdGl2ZSB3aWRnZXRcbiAqXG4gKiBAY2xhc3MgQW5pbWF0aW9uV2lkZ2V0XG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uV2lkZ2V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9ICB7XG4gICAgICB2YWx1ZTogcHJvcHMuc2xpZGVyU3BlZWQsXG4gICAgICBsb29waW5nOiBwcm9wcy5sb29waW5nLFxuICAgICAgc3RhcnREYXRlOiBwcm9wcy5zdGFydERhdGUsXG4gICAgICBlbmREYXRlOiBwcm9wcy5lbmREYXRlLFxuICAgICAgaGVhZGVyOiBwcm9wcy5oZWFkZXIsXG4gICAgICBpbmNyZW1lbnRBcnJheTogcHJvcHMuaW5jcmVtZW50QXJyYXksXG4gICAgICBpbmNyZW1lbnQ6IHByb3BzLmluY3JlbWVudFxuXG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gICAqIFNldHMgYSBuZXcgc3RhdGUgdmFsdWUgd2hlbiBhXG4gICAqIHdoZW4gdGhlIHNsaWRlciBpcyBhZGp1c3RlZFxuICAgKlxuICAgKiBAbWV0aG9kIG9uU2xpZGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIHNsaWRlciByZWFjdFxuICAgKiAgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgb25TbGlkZShjb21wb25lbnQsIHZhbHVlKSB7XG4gICAgdGhpcy5wcm9wcy5vblNsaWRlKHZhbHVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogY2FsbHMgdGhlIGNhbGxiYWNrLCBwYXNzaW5nIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIGVsZW1lbnRzIGFzIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQG1ldGhvZCBwbGF5XG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBwbGF5KCkge1xuICAgIHRoaXMucHJvcHMub25QdXNoUGxheSgpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGxheWluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMucHJvcHMub25QdXNoUGF1c2UoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBsYXlpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgLypcbiAgICogU2V0cyBhIG5ldyBzdGF0ZSB0byBzYXkgd2hldGhlciBvciBub3RcbiAgICogdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcFxuICAgKlxuICAgKiBAbWV0aG9kIG9uTG9vcFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gc2xpZGVyIHJlYWN0XG4gICAqICBjb21wb25lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgb2YgdGhlIHNsaWRlclxuICAgKiAgc2VsZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBvbkxvb3AoKSB7XG4gICAgdmFyIGxvb3AgPSB0cnVlO1xuICAgIGlmKHRoaXMuc3RhdGUubG9vcGluZykge1xuICAgICAgbG9vcCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxvb3Bpbmc6IGxvb3BcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uUHVzaExvb3AobG9vcCk7XG4gIH1cbiAgb25EYXRlQ2hhbmdlKGlkLCBkYXRlKSB7XG4gICAgaWYoaWQgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGFydERhdGU6IGRhdGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vbkRhdGVDaGFuZ2UoXG4gICAgICAgIGRhdGUsXG4gICAgICAgIHRoaXMuc3RhdGUuZW5kRGF0ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGVuZERhdGU6IGRhdGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vbkRhdGVDaGFuZ2UoXG4gICAgICAgIHRoaXMuc3RhdGUuc3RhcnREYXRlLFxuICAgICAgICBkYXRlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuKFxuICAgICAgPGRpdiBpZD1cInd2LWFuaW1hdGlvbi13aWRnZXRcIiBjbGFzc05hbWU9XCJ3di1hbmltYXRpb24td2lkZ2V0XCI+XG4gICAgICAgIDxBbmltV2lkZ2V0SGVhZGVyXG4gICAgICAgICAgdGV4dD17dGhpcy5zdGF0ZS5pbmNyZW1lbnR9XG4gICAgICAgICAgdG9vbFRpcFRleHRBcnJheT17dGhpcy5zdGF0ZS5pbmNyZW1lbnRBcnJheX1cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLm9uWm9vbVNlbGVjdH0vPlxuXG4gICAgICAgIDxQbGF5QnV0dG9uIHBsYXlpbmc9e3RoaXMuc3RhdGUucGxheWluZ30gcGxheT17dGhpcy5wbGF5LmJpbmQodGhpcyl9IHBhdXNlPXt0aGlzLnBhdXNlLmJpbmQodGhpcyl9IC8+XG4gICAgICAgIDxMb29wQnV0dG9uIGxvb3Bpbmc9e3RoaXMuc3RhdGUubG9vcGluZ30gb25Mb29wPXt0aGlzLm9uTG9vcC5iaW5kKHRoaXMpfS8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3Ytc2xpZGVyLWNhc2VcIj5cbiAgICAgICAgICA8SW5wdXRSYW5nZSBzdGVwPXswLjV9IG1heFZhbHVlPXsxMH0gbWluVmFsdWU9ezAuNX0gdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9IG9uQ2hhbmdlPXt0aGlzLm9uU2xpZGUuYmluZCh0aGlzKX0gLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ3di1zbGlkZXItbGFiZWxcIj57dGhpcy5wcm9wcy5zbGlkZXJMYWJlbH08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQobnVsbClcIlxuICAgICAgICAgIHRpdGxlPVwiQ3JlYXRlIEFuaW1hdGVkIEdJRlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwid3YtaWNvbi1jYXNlXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLm9uUHVzaEdJRn1cbiAgICAgICAgPlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLWZpbGUtdmlkZW8tbyB3di1hbmltYXRpb24td2lkZ2V0LWljb25cIi8+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3d2LWFuaW0tZGF0ZXMtY2FzZSc+XG4gICAgICAgICAgPFRpbWVTZWxlY3RvclxuICAgICAgICAgICAgd2lkdGg9XCIxMjBcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMzBcIlxuICAgICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5zdGFydERhdGV9XG4gICAgICAgICAgICBpZD0nc3RhcnQnXG4gICAgICAgICAgICBvbkRhdGVDaGFuZ2U9e3RoaXMub25EYXRlQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBtYXhEYXRlPXt0aGlzLnN0YXRlLmVuZERhdGV9XG4gICAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0ndGhydS1sYWJlbCc+VG88L2Rpdj5cbiAgICAgICAgICA8VGltZVNlbGVjdG9yXG4gICAgICAgICAgICB3aWR0aD1cIjEyMFwiXG4gICAgICAgICAgICBoZWlnaHQ9XCIzMFwiXG4gICAgICAgICAgICBkYXRlPXt0aGlzLnN0YXRlLmVuZERhdGV9XG4gICAgICAgICAgICBpZD0nZW5kJ1xuICAgICAgICAgICAgb25EYXRlQ2hhbmdlPXt0aGlzLm9uRGF0ZUNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgICAgbWluRGF0ZT17dGhpcy5zdGF0ZS5zdGFydERhdGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlcbiAgICAgICAgICBjbGFzc05hbWU9XCJmYSBmYS1jbG9zZSB3di1jbG9zZVwiXG4gICAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsb3NlfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICApO1xuICB9XG5cbn1cbiIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBCdWlsZHMgYSByYXRoZXIgc3BlY2lmaWNcbiAqIGludGVyYWN0aXZlIHdpZGdldFxuICpcbiAqIEBjbGFzcyBBbmltYXRpb25XaWRnZXRcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb29wQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZChudWxsKVwiXG4gICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMubG9vcGluZyA/IFwiU3RvcCBMb29wXCIgOiBcIkxvb3AgdmlkZW9cIn1cbiAgICAgICAgICBjbGFzc05hbWU9e3RoaXMucHJvcHMubG9vcGluZyA/ICd3di1sb29wLWljb24tY2FzZSB3di1pY29uLWNhc2UgYWN0aXZlJyA6ICd3di1sb29wLWljb24tY2FzZSB3di1pY29uLWNhc2UnfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMucHJvcHMub25Mb29wfVxuICAgICAgICA+XG4gICAgICAgICAgPGkgY2xhc3NOYW1lPSdmYSBmYS1yZXR3ZWV0IHd2LWFuaW1hdGlvbi13aWRnZXQtaWNvbicgLz5cbiAgICAgICAgPC9hPlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgQnVpbGRzIGEgcmF0aGVyIHNwZWNpZmljXG4gKiBpbnRlcmFjdGl2ZSB3aWRnZXRcbiAqXG4gKiBAY2xhc3MgQW5pbWF0aW9uV2lkZ2V0XG4gKiBAZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheUJ1dHRvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4oXG4gICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKG51bGwpXCIgdGl0bGU9e3RoaXMucHJvcHMucGxheWluZyA/ICdQYXVzZSB2aWRlbycgOiAnUGxheSB2aWRlbyd9XG4gICAgICAgIGNsYXNzTmFtZT0nd3YtYW5pbS1wbGF5LWNhc2Ugd3YtaWNvbi1jYXNlJ1xuICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLnBsYXlpbmcgPyB0aGlzLnByb3BzLnBhdXNlIDogdGhpcy5wcm9wcy5wbGF5fVxuICAgICAgPlxuICAgICAgICA8aSBjbGFzc05hbWU9e3RoaXMucHJvcHMucGxheWluZyA/ICdmYSBmYS1wYXVzZSB3di1hbmltYXRpb24td2lkZ2V0LWljb24nOiAnZmEgZmEtcGxheSB3di1hbmltYXRpb24td2lkZ2V0LWljb24nfSAvPlxuICAgICAgPC9hPlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRGF0ZUlucHV0Q29sdW1uIGZyb20gJy4vd3YuZGF0ZXNlbGVjdG9yLmlucHV0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlsL3d2LnV0aWxzJztcblxuY29uc3QgdXRpbCA9IG5ldyBVdGlscygpO1xuXG4vKlxuICogQSByZWFjdCBjb21wb25lbnQsIGlzIGEgZHJhZ2dhYmxlIHN2Z1xuICogZ3JvdXAuIEl0IGlzIGEgcGFyZW50IGNvbXBvbmVudCB0aGF0XG4gKiByZXJlbmRlcnMgd2hlbiBjaGlsZCBlbGVtZW50cyBhcmUgZHJhZ2dlZFxuICpcbiAqIEBjbGFzcyBUaW1lbGluZVJhbmdlU2VsZWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZGF0ZVNlbGVjdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgbWF4RGF0ZTogcHJvcHMubWF4RGF0ZSxcbiAgICAgIG1pbkRhdGU6IHByb3BzLm1pbkRhdGUsXG4gICAgICB0YWI6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBtYXhEYXRlOiBwcm9wcy5tYXhEYXRlLFxuICAgICAgbWluRGF0ZTogcHJvcHMubWluRGF0ZSxcbiAgICB9KTtcbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe3RhYjogbnVsbH0pO1xuICB9XG4gIG5leHRUYWIoaW5kZXgpIHtcbiAgICB2YXIgbmV4dFRhYjtcbiAgICBpZihpbmRleCA8IDMpIHtcbiAgICAgIG5leHRUYWIgPSBpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRUYWIgPSAxO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHRhYjogbmV4dFRhYlxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdGUoZGF0ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGF0ZTogZGF0ZVxuICAgIH0pO1xuICAgIHRoaXMucHJvcHMub25EYXRlQ2hhbmdlKHRoaXMucHJvcHMuaWQsIGRhdGUpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3di1kYXRlLXNlbGVjdG9yLXdpZGdldFwiPlxuICAgICAgICA8RGF0ZUlucHV0Q29sdW1uIHN0YXJ0RGF0ZT17bmV3IERhdGUoMjAwMCl9XG4gICAgICAgICAgdG9kYXk9e25ldyBEYXRlKCl9XG4gICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDRnVsbFllYXIoKX1cbiAgICAgICAgICB0eXBlPVwieWVhclwiXG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy53aWR0aH1cbiAgICAgICAgICB1cGRhdGVEYXRlPXt0aGlzLnVwZGF0ZURhdGUuYmluZCh0aGlzKX1cbiAgICAgICAgICB0YWJJbmRleD17MX1cbiAgICAgICAgICBmb2N1c2VkPXsodGhpcy5zdGF0ZS50YWIgPT0gMSl9XG4gICAgICAgICAgbmV4dFRhYj17dGhpcy5uZXh0VGFiLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgIG1pbkRhdGU9e3RoaXMucHJvcHMubWluRGF0ZX1cbiAgICAgICAgICBibHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgICAvPlxuICAgICAgICA8RGF0ZUlucHV0Q29sdW1uXG4gICAgICAgICAgc3RhcnREYXRlPXtuZXcgRGF0ZSgyMDAwKX1cbiAgICAgICAgICB0b2RheT17bmV3IERhdGUoKX0gZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHR5cGU9XCJtb250aFwiIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgdXBkYXRlRGF0ZT17dGhpcy51cGRhdGVEYXRlLmJpbmQodGhpcyl9XG4gICAgICAgICAgdmFsdWU9e3V0aWwubW9udGhTdHJpbmdBcnJheVt0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDTW9udGgoKV19XG4gICAgICAgICAgdGFiSW5kZXg9ezJ9XG4gICAgICAgICAgZm9jdXNlZD17KHRoaXMuc3RhdGUudGFiID09IDIpfVxuICAgICAgICAgIG5leHRUYWI9e3RoaXMubmV4dFRhYi5iaW5kKHRoaXMpfVxuICAgICAgICAgIG1heERhdGU9e3RoaXMucHJvcHMubWF4RGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgYmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW5cbiAgICAgICAgICBzdGFydERhdGU9e25ldyBEYXRlKDIwMDApfVxuICAgICAgICAgIHRvZGF5PXtuZXcgRGF0ZSgpfVxuICAgICAgICAgIGRhdGU9e3RoaXMuc3RhdGUuZGF0ZX1cbiAgICAgICAgICB0eXBlPVwiZGF5XCJcbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLndpZHRofVxuICAgICAgICAgIHVwZGF0ZURhdGU9e3RoaXMudXBkYXRlRGF0ZS5iaW5kKHRoaXMpfVxuICAgICAgICAgIHZhbHVlPXt1dGlsLnBhZCh0aGlzLnN0YXRlLmRhdGUuZ2V0VVRDRGF0ZSgpLCAyLCAnMCcpfVxuICAgICAgICAgIHRhYkluZGV4PXszfVxuICAgICAgICAgIGZvY3VzZWQ9eyh0aGlzLnN0YXRlLnRhYiA9PSAzKX1cbiAgICAgICAgICBuZXh0VGFiPXt0aGlzLm5leHRUYWIuYmluZCh0aGlzKX1cbiAgICAgICAgICBtYXhEYXRlPXt0aGlzLnByb3BzLm1heERhdGV9XG4gICAgICAgICAgbWluRGF0ZT17dGhpcy5wcm9wcy5taW5EYXRlfVxuICAgICAgICAgIGJsdXI9e3RoaXMuYmx1ci5iaW5kKHRoaXMpfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLypcbiAqIE5BU0EgV29ybGR2aWV3XG4gKlxuICogVGhpcyBjb2RlIHdhcyBvcmlnaW5hbGx5IGRldmVsb3BlZCBhdCBOQVNBL0dvZGRhcmQgU3BhY2UgRmxpZ2h0IENlbnRlciBmb3JcbiAqIHRoZSBFYXJ0aCBTY2llbmNlIERhdGEgYW5kIEluZm9ybWF0aW9uIFN5c3RlbSAoRVNESVMpIHByb2plY3QuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEzIC0gMjAxNiBVbml0ZWQgU3RhdGVzIEdvdmVybm1lbnQgYXMgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiBBZG1pbmlzdHJhdG9yIG9mIHRoZSBOYXRpb25hbCBBZXJvbmF1dGljcyBhbmQgU3BhY2UgQWRtaW5pc3RyYXRpb24uXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOQVNBIE9wZW4gU291cmNlIEFncmVlbWVudCwgVmVyc2lvbiAxLjNcbiAqIGh0dHA6Ly9vcGVuc291cmNlLmdzZmMubmFzYS5nb3Yvbm9zYS5waHBcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RG9tIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsL3d2LnV0aWxzJztcblxuY29uc3QgdXRpbCA9IG5ldyBVdGlsKCk7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlSW5wdXRDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZih0aGlzLnByb3BzLmZvY3VzZWQpIHtcbiAgICAgIFJlYWN0RG9tLmZpbmRET01Ob2RlKHRoaXMucmVmc1snaW5wdXQtJyArIHRoaXMucHJvcHMudGFiSW5kZXhdKS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIHNpemU7XG4gICAgdmFyIHR5cGU7XG4gICAgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcbiAgICBpZih0eXBlID09PSAneWVhcicpIHtcbiAgICAgIHNpemUgPSAnNCc7XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICdkYXknKSB7XG4gICAgICBzaXplID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IDM7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBwcm9wcy52YWx1ZX0pO1xuICB9XG4gIG9uS2V5UHJlc3MoZSkge1xuICAgIHZhciBrYyA9IGUua2V5Q29kZTtcbiAgICBpZihrYyA9PT0gOSB8fCAvLyB0YWJcbiAgICAgIGtjID09PSAxMykgeyAvL2VudGVyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICBvbktleVVwKGUpIHtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICB2YXIgZW50ZXJlZCA9IChrZXlDb2RlID09IDEzIHx8IGtleUNvZGUgPT0gOSk7XG4gICAgaWYoa2V5Q29kZSA9PT0gMzgpIHsgLy91cFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5vbkNsaWNrVXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYoa2V5Q29kZSA9PT0gNDApIHsvLyBkb3duXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm9uQ2xpY2tEb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnR5cGUgPT0gJ2ZvY3Vzb3V0JyB8fCBlbnRlcmVkKSB7XG4gICAgICBpZih0aGlzLnByb3BzLnR5cGUgPT0gJ3llYXInIHx8IHRoaXMucHJvcHMudHlwZSA9PSAnZGF5Jykge1xuICAgICAgICBpZighKChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpXG4gICAgICAgIHx8IGVudGVyZWRcbiAgICAgICAgfHwga2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoKHRoaXMucHJvcHMudHlwZSkge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy55ZWFyVmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF5VmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy5tb250aFZhbGlkYXRpb24odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYobmV3RGF0ZSkge1xuICAgICAgICB0aGlzLnByb3BzLnVwZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICAgIGlmKGVudGVyZWQpIHsgLy9pZiBlbmV0ZXJlZCBvciB0YWJiZWRcbiAgICAgICAgICB0aGlzLm5leHRUYWIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGVudGVyZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkNsaWNrVXAoKSB7XG4gICAgdGhpcy5yb2xsRGF0ZSgxKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG5cbiAgfVxuICBvbkNsaWNrRG93bigpIHtcbiAgICB0aGlzLnJvbGxEYXRlKC0xKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgeWVhclZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICBpZigoaW5wdXQgPiAxMDAwKSAmJiAoaW5wdXQgPCA5OTk5KSkge1xuICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKChuZXcgRGF0ZSh0aGlzLnByb3BzLmRhdGUpKS5zZXRVVENGdWxsWWVhcihpbnB1dCkpO1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgIH1cbiAgfVxuICBkYXlWYWxpZGF0aW9uKGlucHV0KSB7XG4gICAgdmFyIG5ld0RhdGU7XG4gICAgdmFyIG1heERhdGU7XG4gICAgdmFyIGN1cnJlbnREYXRlID0gdGhpcy5wcm9wcy5kYXRlO1xuXG4gICAgbWF4RGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlLmdldFllYXIoKSwgY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKTtcblxuICAgIGlmKGlucHV0ID4gMCAmJiBpbnB1dCA8PSBtYXhEYXRlKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKGN1cnJlbnREYXRlKSkuc2V0VVRDRGF0ZShpbnB1dCkpO1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgIH1cblxuICB9XG4gIHJvbGxEYXRlKGFtdCkge1xuICAgIHZhciBuZXdEYXRlID0gdXRpbC5yb2xsRGF0ZShcbiAgICAgIHRoaXMucHJvcHMuZGF0ZSxcbiAgICAgIHRoaXMucHJvcHMudHlwZSxcbiAgICAgIGFtdCxcbiAgICAgIHRoaXMucHJvcHMubWluRGF0ZSxcbiAgICAgIHRoaXMucHJvcHMubWF4RGF0ZVxuICAgICk7XG4gICAgdGhpcy5wcm9wcy51cGRhdGVEYXRlKG5ld0RhdGUpO1xuICB9XG5cbiAgbW9udGhWYWxpZGF0aW9uKGlucHV0KSB7XG4gICAgdmFyIG5ld0RhdGU7XG4gICAgaWYgKCghaXNOYU4oaW5wdXQpKSAmJiBpbnB1dCA8IDEzICYmIGlucHV0ID4gMCkge1xuICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKChuZXcgRGF0ZSh0aGlzLnByb3BzLmRhdGUpKS5zZXRVVENNb250aChpbnB1dCAtIDEpKTtcbiAgICAgIGlmKG5ld0RhdGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdmFsdWU6IHV0aWwubW9udGhTdHJpbmdBcnJheVtpbnB1dC0xXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlKG5ld0RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVhbE1vbnRoO1xuICAgICAgcmVhbE1vbnRoID0gdXRpbC5zdHJpbmdJbkFycmF5KHV0aWwubW9udGhTdHJpbmdBcnJheSwgaW5wdXQpO1xuICAgICAgaWYocmVhbE1vbnRoICE9PSBmYWxzZSkge1xuICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ01vbnRoKHJlYWxNb250aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy52YWx1ZSxcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3BzLmJsdXIoKTtcbiAgfVxuICBvbkNoYW5nZShlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZTogZS50YXJnZXQudmFsdWUudG9VcHBlckNhc2UoKVxuICAgIH0pO1xuICB9XG4gIG5leHRUYWIoKSB7XG4gICAgdGhpcy5wcm9wcy5uZXh0VGFiKHRoaXMucHJvcHMudGFiSW5kZXgpO1xuICB9XG4gIHZhbGlkYXRlRGF0ZShkYXRlKSB7XG4gICAgaWYoZGF0ZSA+IHRoaXMucHJvcHMubWluRGF0ZSAmJiBkYXRlIDw9IHRoaXMucHJvcHMubWF4RGF0ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LXdyYXBwZXJcIiBzdHlsZT17KHRoaXMuc3RhdGUudmFsaWQpID8ge30gOiB7Ym9yZGVyQ29sb3I6ICcjZmYwMDAwJ319ID5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tVcC5iaW5kKHRoaXMpfSBjbGFzc05hbWU9XCJkYXRlLWFycm93cyBkYXRlLWFycm93LXVwXCIgZGF0YS1pbnRlcnZhbD17dGhpcy5wcm9wcy50eXBlfT5cbiAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjhcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0gMTIuNSwwIDI1LDggMCw4IHpcIiBjbGFzc05hbWU9XCJ1cGFycm93XCI+XG4gICAgICAgICAgICAgIDwvcGF0aD5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHJlZj17J2lucHV0LScgKyB0aGlzLnByb3BzLnRhYkluZGV4fVxuICAgICAgICAgIHNpemU9e3RoaXMuc2l6ZX1cbiAgICAgICAgICBtYXhMZW5ndGg9e3RoaXMuc2l6ZX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24taW5wdXQtZ3JvdXBcIlxuICAgICAgICAgIGlkPXt0aGlzLnByb3BzLnR5cGUgKyAnLWlucHV0LWdyb3VwJ31cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS52YWx1ZX1cbiAgICAgICAgICB0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cbiAgICAgICAgICBvbktleVVwPXt0aGlzLm9uS2V5VXAuYmluZCh0aGlzKX1cbiAgICAgICAgICBvbktleURvd249e3RoaXMub25LZXlQcmVzcy5iaW5kKHRoaXMpfSAvL2N1cnJlbnRseSBub3Qgd29ya2luZ1xuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgc3R5bGU9e3tmb250U2l6ZTogKCh0aGlzLnByb3BzLmhlaWdodCAvIDIpICsgJ3B4Jyl9fVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5vbkNsaWNrRG93bi5iaW5kKHRoaXMpfSBjbGFzc05hbWU9XCJkYXRlLWFycm93cyBkYXRlLWFycm93LWRvd25cIiBkYXRhLWludGVydmFsPXt0aGlzLnByb3BzLnR5cGV9PlxuICAgICAgICAgIDxzdmcgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjhcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNIDEyLjUsMCAyNSw4IDAsOCB6XCIgY2xhc3NOYW1lPVwiZG93bmFycm93XCI+PC9wYXRoPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3REb20gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwvd3YudXRpbHMnO1xuXG5jb25zdCB1dGlsID0gbmV3IFV0aWwoKTtcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBpcyBhIGRyYWdnYWJsZSBzdmdcbiAqIGdyb3VwLiBJdCBpcyBhIHBhcmVudCBjb21wb25lbnQgdGhhdFxuICogcmVyZW5kZXJzIHdoZW4gY2hpbGQgZWxlbWVudHMgYXJlIGRyYWdnZWRcbiAqXG4gKiBAY2xhc3MgVGltZWxpbmVSYW5nZVNlbGVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVJbnB1dENvbHVtbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLypcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWUsXG4gICAgICB2YWxpZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmKHRoaXMucHJvcHMuZm9jdXNlZCkge1xuICAgICAgUmVhY3REb20uZmluZERPTU5vZGUodGhpcy5yZWZzWydpbnB1dC0nICsgdGhpcy5wcm9wcy50YWJJbmRleF0pLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgdHlwZTtcbiAgICB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIGlmKHR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgc2l6ZSA9ICc0JztcbiAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ2RheScpIHtcbiAgICAgIHNpemUgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gMztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHByb3BzLnZhbHVlfSk7XG4gIH1cbiAgb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGtjID0gZS5rZXlDb2RlO1xuICAgIGlmKGtjID09PSA5IHx8IC8vIHRhYlxuICAgICAga2MgPT09IDEzKSB7IC8vZW50ZXJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG4gIG9uS2V5VXAoZSkge1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgIHZhciB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIHZhciBuZXdEYXRlO1xuICAgIHZhciBlbnRlcmVkID0gKGtleUNvZGUgPT0gMTMgfHwga2V5Q29kZSA9PSA5KTtcbiAgICBpZihrZXlDb2RlID09PSAzOCkgeyAvL3VwXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm9uQ2xpY2tVcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZihrZXlDb2RlID09PSA0MCkgey8vIGRvd25cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMub25DbGlja0Rvd24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUudHlwZSA9PSAnZm9jdXNvdXQnIHx8IGVudGVyZWQpIHtcbiAgICAgIGlmKHRoaXMucHJvcHMudHlwZSA9PSAneWVhcicgfHwgdGhpcy5wcm9wcy50eXBlID09ICdkYXknKSB7XG4gICAgICAgIGlmKCEoKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NylcbiAgICAgICAgfHwgZW50ZXJlZFxuICAgICAgICB8fCBrZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2godGhpcy5wcm9wcy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLnllYXJWYWxpZGF0aW9uKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICBuZXdEYXRlID0gdGhpcy5kYXlWYWxpZGF0aW9uKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLm1vbnRoVmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZihuZXdEYXRlKSB7XG4gICAgICAgIHRoaXMucHJvcHMudXBkYXRlRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgaWYoZW50ZXJlZCkgeyAvL2lmIGVuZXRlcmVkIG9yIHRhYmJlZFxuICAgICAgICAgIHRoaXMubmV4dFRhYigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoZW50ZXJlZCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2YWxpZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQ2xpY2tVcCgpIHtcbiAgICB0aGlzLnJvbGxEYXRlKDEpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcblxuICB9XG4gIG9uQ2xpY2tEb3duKCkge1xuICAgIHRoaXMucm9sbERhdGUoLTEpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICB5ZWFyVmFsaWRhdGlvbihpbnB1dCkge1xuICAgIHZhciBuZXdEYXRlO1xuICAgIGlmKChpbnB1dCA+IDEwMDApICYmIChpbnB1dCA8IDk5OTkpKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ0Z1bGxZZWFyKGlucHV0KSk7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgfVxuICB9XG4gIGRheVZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICB2YXIgbWF4RGF0ZTtcbiAgICB2YXIgY3VycmVudERhdGUgPSB0aGlzLnByb3BzLmRhdGU7XG5cbiAgICBtYXhEYXRlID0gbmV3IERhdGUoY3VycmVudERhdGUuZ2V0WWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXG4gICAgaWYoaW5wdXQgPiAwICYmIGlucHV0IDw9IG1heERhdGUpIHtcbiAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSgobmV3IERhdGUoY3VycmVudERhdGUpKS5zZXRVVENEYXRlKGlucHV0KSk7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgfVxuXG4gIH1cbiAgcm9sbERhdGUoYW10KSB7XG4gICAgdmFyIG5ld0RhdGUgPSB1dGlsLnJvbGxEYXRlKFxuICAgICAgdGhpcy5wcm9wcy5kYXRlLFxuICAgICAgdGhpcy5wcm9wcy50eXBlLFxuICAgICAgYW10LFxuICAgICAgdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgdGhpcy5wcm9wcy5tYXhEYXRlXG4gICAgKTtcbiAgICB0aGlzLnByb3BzLnVwZGF0ZURhdGUobmV3RGF0ZSk7XG4gIH1cblxuICBtb250aFZhbGlkYXRpb24oaW5wdXQpIHtcbiAgICB2YXIgbmV3RGF0ZTtcbiAgICBpZiAoKCFpc05hTihpbnB1dCkpICYmIGlucHV0IDwgMTMgJiYgaW5wdXQgPiAwKSB7XG4gICAgICBuZXdEYXRlID0gbmV3IERhdGUoKG5ldyBEYXRlKHRoaXMucHJvcHMuZGF0ZSkpLnNldFVUQ01vbnRoKGlucHV0IC0gMSkpO1xuICAgICAgaWYobmV3RGF0ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB2YWx1ZTogdXRpbC5tb250aFN0cmluZ0FycmF5W2lucHV0LTFdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZURhdGUobmV3RGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZWFsTW9udGg7XG4gICAgICByZWFsTW9udGggPSB1dGlsLnN0cmluZ0luQXJyYXkodXRpbC5tb250aFN0cmluZ0FycmF5LCBpbnB1dCk7XG4gICAgICBpZihyZWFsTW9udGggIT09IGZhbHNlKSB7XG4gICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSgobmV3IERhdGUodGhpcy5wcm9wcy5kYXRlKSkuc2V0VVRDTW9udGgocmVhbE1vbnRoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRGF0ZShuZXdEYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMucHJvcHMuYmx1cigpO1xuICB9XG4gIG9uQ2hhbmdlKGUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlOiBlLnRhcmdldC52YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbiAgbmV4dFRhYigpIHtcbiAgICB0aGlzLnByb3BzLm5leHRUYWIodGhpcy5wcm9wcy50YWJJbmRleCk7XG4gIH1cbiAgdmFsaWRhdGVEYXRlKGRhdGUpIHtcbiAgICBpZihkYXRlID4gdGhpcy5wcm9wcy5taW5EYXRlICYmIGRhdGUgPD0gdGhpcy5wcm9wcy5tYXhEYXRlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtd3JhcHBlclwiIHN0eWxlPXsodGhpcy5zdGF0ZS52YWxpZCkgPyB7fSA6IHtib3JkZXJDb2xvcjogJyNmZjAwMDAnfX0gPlxuICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMub25DbGlja1VwLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cImRhdGUtYXJyb3dzIGRhdGUtYXJyb3ctdXBcIiBkYXRhLWludGVydmFsPXt0aGlzLnByb3BzLnR5cGV9PlxuICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiOFwiPlxuICAgICAgICAgICAgICA8cGF0aCBkPVwiTSAxMi41LDAgMjUsOCAwLDggelwiIGNsYXNzTmFtZT1cInVwYXJyb3dcIj5cbiAgICAgICAgICAgICAgPC9wYXRoPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgcmVmPXsnaW5wdXQtJyArIHRoaXMucHJvcHMudGFiSW5kZXh9XG4gICAgICAgICAgc2l6ZT17dGhpcy5zaXplfVxuICAgICAgICAgIG1heExlbmd0aD17dGhpcy5zaXplfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImJ1dHRvbi1pbnB1dC1ncm91cFwiXG4gICAgICAgICAgaWQ9e3RoaXMucHJvcHMudHlwZSArICctaW5wdXQtZ3JvdXAnfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLnZhbHVlfVxuICAgICAgICAgIHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuICAgICAgICAgIG9uS2V5VXA9e3RoaXMub25LZXlVcC5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5vbktleVByZXNzLmJpbmQodGhpcyl9IC8vY3VycmVudGx5IG5vdCB3b3JraW5nXG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICBzdHlsZT17e2ZvbnRTaXplOiAoKHRoaXMucHJvcHMuaGVpZ2h0IC8gMikgKyAncHgnKX19XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tEb3duLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cImRhdGUtYXJyb3dzIGRhdGUtYXJyb3ctZG93blwiIGRhdGEtaW50ZXJ2YWw9e3RoaXMucHJvcHMudHlwZX0+XG4gICAgICAgICAgPHN2ZyB3aWR0aD1cIjI1XCIgaGVpZ2h0PVwiOFwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0gMTIuNSwwIDI1LDggMCw4IHpcIiBjbGFzc05hbWU9XCJkb3duYXJyb3dcIj48L3BhdGg+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufSIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBEYXRlSW5wdXRDb2x1bW4gZnJvbSAnLi93di5kYXRlc2VsZWN0b3IuaW5wdXQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWwvd3YudXRpbHMnO1xuXG5jb25zdCB1dGlsID0gbmV3IFV0aWxzKCk7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBkYXRlU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICBtYXhEYXRlOiBwcm9wcy5tYXhEYXRlLFxuICAgICAgbWluRGF0ZTogcHJvcHMubWluRGF0ZSxcbiAgICAgIHRhYjogbnVsbFxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgIG1heERhdGU6IHByb3BzLm1heERhdGUsXG4gICAgICBtaW5EYXRlOiBwcm9wcy5taW5EYXRlLFxuICAgIH0pO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dGFiOiBudWxsfSk7XG4gIH1cbiAgbmV4dFRhYihpbmRleCkge1xuICAgIHZhciBuZXh0VGFiO1xuICAgIGlmKGluZGV4IDwgMykge1xuICAgICAgbmV4dFRhYiA9IGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRhYiA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdGFiOiBuZXh0VGFiXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlRGF0ZShkYXRlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkYXRlOiBkYXRlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkRhdGVDaGFuZ2UodGhpcy5wcm9wcy5pZCwgZGF0ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInd2LWRhdGUtc2VsZWN0b3Itd2lkZ2V0XCI+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW4gc3RhcnREYXRlPXtuZXcgRGF0ZSgyMDAwKX1cbiAgICAgICAgICB0b2RheT17bmV3IERhdGUoKX1cbiAgICAgICAgICBkYXRlPXt0aGlzLnN0YXRlLmRhdGV9XG4gICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZGF0ZS5nZXRVVENGdWxsWWVhcigpfVxuICAgICAgICAgIHR5cGU9XCJ5ZWFyXCJcbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLndpZHRofVxuICAgICAgICAgIHVwZGF0ZURhdGU9e3RoaXMudXBkYXRlRGF0ZS5iaW5kKHRoaXMpfVxuICAgICAgICAgIHRhYkluZGV4PXsxfVxuICAgICAgICAgIGZvY3VzZWQ9eyh0aGlzLnN0YXRlLnRhYiA9PSAxKX1cbiAgICAgICAgICBuZXh0VGFiPXt0aGlzLm5leHRUYWIuYmluZCh0aGlzKX1cbiAgICAgICAgICBtYXhEYXRlPXt0aGlzLnByb3BzLm1heERhdGV9XG4gICAgICAgICAgbWluRGF0ZT17dGhpcy5wcm9wcy5taW5EYXRlfVxuICAgICAgICAgIGJsdXI9e3RoaXMuYmx1ci5iaW5kKHRoaXMpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDxEYXRlSW5wdXRDb2x1bW5cbiAgICAgICAgICBzdGFydERhdGU9e25ldyBEYXRlKDIwMDApfVxuICAgICAgICAgIHRvZGF5PXtuZXcgRGF0ZSgpfSBkYXRlPXt0aGlzLnN0YXRlLmRhdGV9XG4gICAgICAgICAgdHlwZT1cIm1vbnRoXCIgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy53aWR0aH1cbiAgICAgICAgICB1cGRhdGVEYXRlPXt0aGlzLnVwZGF0ZURhdGUuYmluZCh0aGlzKX1cbiAgICAgICAgICB2YWx1ZT17dXRpbC5tb250aFN0cmluZ0FycmF5W3RoaXMuc3RhdGUuZGF0ZS5nZXRVVENNb250aCgpXX1cbiAgICAgICAgICB0YWJJbmRleD17Mn1cbiAgICAgICAgICBmb2N1c2VkPXsodGhpcy5zdGF0ZS50YWIgPT0gMil9XG4gICAgICAgICAgbmV4dFRhYj17dGhpcy5uZXh0VGFiLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAgIG1pbkRhdGU9e3RoaXMucHJvcHMubWluRGF0ZX1cbiAgICAgICAgICBibHVyPXt0aGlzLmJsdXIuYmluZCh0aGlzKX1cbiAgICAgICAgLz5cbiAgICAgICAgPERhdGVJbnB1dENvbHVtblxuICAgICAgICAgIHN0YXJ0RGF0ZT17bmV3IERhdGUoMjAwMCl9XG4gICAgICAgICAgdG9kYXk9e25ldyBEYXRlKCl9XG4gICAgICAgICAgZGF0ZT17dGhpcy5zdGF0ZS5kYXRlfVxuICAgICAgICAgIHR5cGU9XCJkYXlcIlxuICAgICAgICAgIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgdXBkYXRlRGF0ZT17dGhpcy51cGRhdGVEYXRlLmJpbmQodGhpcyl9XG4gICAgICAgICAgdmFsdWU9e3V0aWwucGFkKHRoaXMuc3RhdGUuZGF0ZS5nZXRVVENEYXRlKCksIDIsICcwJyl9XG4gICAgICAgICAgdGFiSW5kZXg9ezN9XG4gICAgICAgICAgZm9jdXNlZD17KHRoaXMuc3RhdGUudGFiID09IDMpfVxuICAgICAgICAgIG5leHRUYWI9e3RoaXMubmV4dFRhYi5iaW5kKHRoaXMpfVxuICAgICAgICAgIG1heERhdGU9e3RoaXMucHJvcHMubWF4RGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgYmx1cj17dGhpcy5ibHVyLmJpbmQodGhpcyl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ3JlYWN0LWRyYWdnYWJsZSc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cFxuICpcbiAqIEBjbGFzcyBUaW1lbGluZURyYWdnZXJcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZURyYWdnZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cbiAgY2hlY2tWaXNpYmlsaXR5KCkge1xuICAgIHZhciB2aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGlmKHRoaXMucHJvcHMucG9zaXRpb24gPCAwIHx8IHRoaXMucHJvcHMucG9zaXRpb24gPiB0aGlzLnByb3BzLm1heCkge1xuICAgICAgdmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eVxuICAgIH07XG4gIH1cbiAgLypcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gcGFzc2VzIHRoZSBpZFxuICAgKiBhbmQgY2hhbmdlLWluLXggb2YgdGhlIGRyYWdcbiAgICogdG8gb25EcmFnIGNhbGxiYWNrXG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRHJhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgaGFuZGxlRHJhZyhlLCBkKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLnByb3BzLm9uRHJhZyhkLmRlbHRhWCwgdGhpcy5wcm9wcy5pZCk7XG4gIH1cblxuICAvKlxuICAgKiBAbWV0aG9kIHJlbmRlclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY2hlY2tWaXNpYmlsaXR5KCk7XG4gICAgcmV0dXJuKFxuICAgICAgPERyYWdnYWJsZVxuICAgICAgICBvbkRyYWc9e3RoaXMuaGFuZGxlRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICBwb3NpdGlvbj17e3g6dGhpcy5wcm9wcy5wb3NpdGlvbiwgeTowfX1cbiAgICAgICAgb25TdG9wPXt0aGlzLnByb3BzLm9uU3RvcH1cbiAgICAgICAgYXhpcz1cInhcIlxuICAgICAgPlxuICAgICAgICA8Zz5cbiAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMud2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZmlsbDp0aGlzLnByb3BzLmNvbG9yLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLnN0YXRlLnZpc2liaWxpdHlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIHRoaXMgcG9seWdvbiBlbGVtZW50IGJ1aWxkcyBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAqIGJhc2VkIG9uIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZVxuICAgICAgICAgICAgKiByZWN0YW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICB9XG4gICAgICAgICAgPHBvbHlnb25cbiAgICAgICAgICAgIHBvaW50cz17JzAsMCwnICsgdGhpcy5wcm9wcy5oZWlnaHQgLyAxLjUgKyAnLDAgJyArIHRoaXMucHJvcHMuaGVpZ2h0IC8gMyArICcsICcgK3RoaXMucHJvcHMuaGVpZ2h0IC8gMS41IH1cbiAgICAgICAgICAgIHRyYW5zZm9ybT17J3RyYW5zbGF0ZSgnICsgKC0odGhpcy5wcm9wcy53aWR0aCAqIDIuNDUpKSArICcsICcgKyAoLSh0aGlzLnByb3BzLmhlaWdodCAvIDIpKSArJyknfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZmlsbDogdGhpcy5wcm9wcy50cmlhbmdsZUNvbG9yLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLnN0YXRlLnZpc2liaWxpdHksXG4gICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L0RyYWdnYWJsZT5cbiAgICApO1xuICB9XG59XG5UaW1lbGluZURyYWdnZXIuZGVmYXVsdFByb3BzID0ge1xuICB2aXNpYmxlOiB0cnVlXG59OyIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiByZWN0IGVsZW1lbnRcbiAqXG4gKiBAY2xhc3MgVGltZWxpbmVEcmFnZ2VyUmFuZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmVEcmFnZ2VyUmFuZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5vcGFjaXR5ID0ge1xuICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcHMub3BhY2l0eVxuICAgIH07XG4gIH1cbiAgY2hlY2tXaWR0aCgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnByb3BzLnN0YXJ0TG9jYXRpb247XG4gICAgdmFyIGVuZCA9IHRoaXMucHJvcHMuZW5kTG9jYXRpb247XG4gICAgdmFyIG1heCA9IHRoaXMucHJvcHMubWF4O1xuICAgIHZhciB3aWR0aDtcblxuICAgIGlmKHN0YXJ0IDwgMCl7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmKGVuZCA+IG1heCl7XG4gICAgICBlbmQgPSBtYXg7XG4gICAgfVxuICAgIHdpZHRoID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYod2lkdGggPCAwKSB7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBzdGFydExvY2F0aW9uOiBzdGFydFxuICAgIH07XG4gIH1cbiAgLypcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gcGFzc2VzIHRoZSBpZFxuICAgKiBhbmQgY2hhbmdlIGluIHggb2YgdGhlIGRyYWdcbiAgICogdG8gb25EcmFnIHByb3BlcnR5XG4gICAqXG4gICAqIEBtZXRob2QgaGFuZGxlRHJhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgaGFuZGxlRHJhZyhlLCBkKXtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMucHJvcHMub25EcmFnKGQuZGVsdGFYKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBtZXRob2QgcmVuZGVyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jaGVja1dpZHRoKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxyZWN0XG4gICAgICAgIHg9e3RoaXMuc3RhdGUuc3RhcnRMb2NhdGlvbn1cbiAgICAgICAgZmlsbD17dGhpcy5wcm9wcy5jb2xvcn1cbiAgICAgICAgd2lkdGg9e3RoaXMuc3RhdGUud2lkdGh9XG4gICAgICAgIHN0eWxlPXt0aGlzLm9wYWNpdHl9XG4gICAgICAgIGhlaWdodD17dGhpcy5wcm9wcy5oZWlnaHR9XG4gICAgICAgIGNsYXNzTmFtZT0nZHJhZ2dlci1yYW5nZSdcbiAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE5BU0EgT3BlbiBTb3VyY2UgQWdyZWVtZW50LCBWZXJzaW9uIDEuM1xuICogaHR0cDovL29wZW5zb3VyY2UuZ3NmYy5uYXNhLmdvdi9ub3NhLnBocFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRHJhZ2dlciBmcm9tICcuL3d2LnRpbWVsaW5lLmRyYWdnZXIuanMnO1xuaW1wb3J0IERyYWdnZXJSYW5nZSBmcm9tICcuL3d2LnRpbWVsaW5lLmRyYWdnZXJyYW5nZS5qcyc7XG5cbi8qXG4gKiBBIHJlYWN0IGNvbXBvbmVudCwgaXMgYSBkcmFnZ2FibGUgc3ZnXG4gKiBncm91cC4gSXQgaXMgYSBwYXJlbnQgY29tcG9uZW50IHRoYXRcbiAqIHJlcmVuZGVycyB3aGVuIGNoaWxkIGVsZW1lbnRzIGFyZSBkcmFnZ2VkXG4gKlxuICogQGNsYXNzIFRpbWVsaW5lUmFuZ2VTZWxlY3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZVJhbmdlU2VsZWN0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9ICB7XG4gICAgICBzdGFydExvY2F0aW9uOiBwcm9wcy5zdGFydExvY2F0aW9uLFxuICAgICAgZW5kTG9jYXRpb246IHByb3BzLmVuZExvY2F0aW9uLFxuICAgICAgbWF4OiBwcm9wcy5tYXgsXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydExvY2F0aW9uOiBwcm9wcy5zdGFydExvY2F0aW9uLFxuICAgICAgZW5kTG9jYXRpb246IHByb3BzLmVuZExvY2F0aW9uLFxuICAgICAgbWF4OiBwcm9wcy5tYXhcbiAgICB9KTtcbiAgfVxuICAvKlxuICAgKiBXaGVuIGEgY2hpbGQgY29tcG9uZW50IGlzIGRyYWdnZWQsXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGRldGVybWluZVxuICAgKiB0aGUgY29ycmVjdCBsb2NhdGlvbiBmb3IgZWFjaCBvZiB0aGVcbiAgICogY2hpbGQgZWxlbWVudHMgYWZ0ZXIgdGhlIGRyYWdcbiAgICpcbiAgICogQG1ldGhvZCBoYW5kbGVEcmFnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggLSBjaGFuZ2UgaW4geFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBJZGVudGlmaWVyIHVzZWQgdG9cbiAgICogIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGNoaWxkIGVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBvbkl0ZW1EcmFnKGRlbHRhWCwgaWQpIHtcbiAgICB2YXIgc3RhcnRYO1xuICAgIHZhciBlbmRYO1xuXG4gICAgaWYoaWQgPT09ICdzdGFydCcpIHtcbiAgICAgIHN0YXJ0WCA9IGRlbHRhWCArIHRoaXMuc3RhdGUuc3RhcnRMb2NhdGlvbjtcbiAgICAgIGVuZFggPSB0aGlzLnN0YXRlLmVuZExvY2F0aW9uO1xuICAgICAgaWYoc3RhcnRYIDwgMCB8fCBzdGFydFggPiBlbmRYKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHN0YXJ0WCArICgyICogdGhpcy5wcm9wcy5waW5XaWR0aCkgPj0gZW5kWCkge1xuICAgICAgICBlbmRYID0gc3RhcnRYICsgdGhpcy5wcm9wcy5waW5XaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoaWQgPT09ICdlbmQnKSB7XG4gICAgICBzdGFydFggPSB0aGlzLnN0YXRlLnN0YXJ0TG9jYXRpb247XG4gICAgICBlbmRYID0gZGVsdGFYICsgdGhpcy5zdGF0ZS5lbmRMb2NhdGlvbjtcbiAgICAgIGlmKGVuZFggPiB0aGlzLnN0YXRlLm1heCB8fCBzdGFydFggPiBlbmRYKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmKHN0YXJ0WCArICgyICogdGhpcy5wcm9wcy5waW5XaWR0aCkgPj0gZW5kWCkge1xuICAgICAgICBzdGFydFggPSBlbmRYIC0gdGhpcy5wcm9wcy5waW5XaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRYID0gZGVsdGFYICsgdGhpcy5zdGF0ZS5zdGFydExvY2F0aW9uIDtcbiAgICAgIGVuZFggPSBkZWx0YVggKyB0aGlzLnN0YXRlLmVuZExvY2F0aW9uO1xuICAgICAgaWYoZW5kWCA+PSB0aGlzLnN0YXRlLm1heCB8fCBzdGFydFggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbkRyYWcoc3RhcnRYLCBlbmRYKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RhcnRMb2NhdGlvbjogc3RhcnRYLFxuICAgICAgZW5kTG9jYXRpb246IGVuZFhcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIFNlbmQgY2FsbGJhY2sgd2l0aCBuZXcgbG9jYXRpb25zIG9uXG4gICAqIERyYWcgU3RvcFxuICAgKlxuICAgKiBAbWV0aG9kIG9uRHJhZ1N0b3BcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIG9uRHJhZ1N0b3AoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkRyYWcodGhpcy5zdGF0ZS5zdGFydExvY2F0aW9uLCB0aGlzLnN0YXRlLmVuZExvY2F0aW9uKTtcbiAgfVxuICBvblJhbmdlQ2xpY2soZCkge1xuICAgIHRoaXMucHJvcHMub25SYW5nZUNsaWNrKGQubmF0aXZlRXZlbnQpO1xuICB9XG4gIC8qXG4gICAqIEBtZXRob2QgcmVuZGVyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuKFxuICAgICAgPHN2ZyBpZD1cInd2LXRpbWVsaW5lLXJhbmdlLXNlbGVjdG9yXCIgY2xhc3NOYW1lPVwid3YtdGltZWxpbmUtcmFuZ2Utc2VsZWN0b3JcIj5cbiAgICAgICAgPERyYWdnZXJSYW5nZVxuICAgICAgICAgIHdpZHRoPXt0aGlzLnByb3BzLnBpbldpZHRofVxuICAgICAgICAgIGVuZExvY2F0aW9uPXt0aGlzLnN0YXRlLmVuZExvY2F0aW9ufVxuICAgICAgICAgIG9wYWNpdHk9e3RoaXMucHJvcHMucmFuZ2VPcGFjaXR5fVxuICAgICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnJhbmdlQ29sb3J9XG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICBzdGFydExvY2F0aW9uPXt0aGlzLnN0YXRlLnN0YXJ0TG9jYXRpb24gKyB0aGlzLnByb3BzLnBpbldpZHRofVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25SYW5nZUNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICBpZD0ncmFuZ2UnLz5cbiAgICAgICAgPERyYWdnZXJcbiAgICAgICAgICBwb3NpdGlvbj17dGhpcy5zdGF0ZS5zdGFydExvY2F0aW9ufVxuICAgICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLnN0YXJ0Q29sb3J9XG4gICAgICAgICAgd2lkdGg9e3RoaXMucHJvcHMucGluV2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXt0aGlzLnByb3BzLmhlaWdodH1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMub25JdGVtRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5vbkRyYWdTdG9wLmJpbmQodGhpcyl9XG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICB0cmlhbmdsZUNvbG9yPXt0aGlzLnByb3BzLnN0YXJ0VHJpYW5nbGVDb2xvcn1cbiAgICAgICAgICBmaXJzdD17dHJ1ZX1cbiAgICAgICAgICBpZD0nc3RhcnQnIC8+XG4gICAgICAgIDxEcmFnZ2VyXG4gICAgICAgICAgbWF4PXt0aGlzLnN0YXRlLm1heH1cbiAgICAgICAgICBwb3NpdGlvbj17dGhpcy5zdGF0ZS5lbmRMb2NhdGlvbn1cbiAgICAgICAgICBjb2xvcj17dGhpcy5wcm9wcy5lbmRDb2xvcn1cbiAgICAgICAgICB3aWR0aD17dGhpcy5wcm9wcy5waW5XaWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e3RoaXMucHJvcHMuaGVpZ2h0fVxuICAgICAgICAgIGZpcnN0PXtmYWxzZX1cbiAgICAgICAgICBvbkRyYWc9e3RoaXMub25JdGVtRHJhZy5iaW5kKHRoaXMpfVxuICAgICAgICAgIG9uU3RvcD17dGhpcy5vbkRyYWdTdG9wLmJpbmQodGhpcyl9XG4gICAgICAgICAgdHJpYW5nbGVDb2xvcj17dGhpcy5wcm9wcy5lbmRUcmlhbmdsZUNvbG9yfVxuICAgICAgICAgIGlkPSdlbmQnLz5cbiAgICAgIDwvc3ZnPlxuICAgICk7XG4gIH1cblxufSIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLypcbiAqIEEgcmVhY3QgY29tcG9uZW50LCBCdWlsZHMgYSByYXRoZXIgc3BlY2lmaWNcbiAqIGludGVyYWN0aXZlIHdpZGdldFxuICpcbiAqIEBjbGFzcyBBbmltYXRpb25XaWRnZXRcbiAqIEBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sdGlwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhvdmVyZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBtb3VzZU92ZXIoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbW91c2VPdXQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIG9uQ2xpY2soc3RyKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKHN0cik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybihcbiAgICAgIDxkaXZcbiAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5tb3VzZU92ZXIuYmluZCh0aGlzKX1cbiAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5tb3VzZU91dC5iaW5kKHRoaXMpfVxuICAgICAgY2xhc3NOYW1lPVwid3YtdG9vbHRpcC1jYXNlXCI+XG4gICAgICAgIDxzcGFuPnt0aGlzLnByb3BzLnRleHR9PC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInd2LXRvb2x0aXBcIiBzdHlsZT17KHRoaXMuc3RhdGUuaG92ZXJlZCkgPyB7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSA6IHt9fSA+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuZGF0YUFycmF5Lm1hcCgoZGF0YUVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiA8bGkga2V5PXsndG9vbHRpcC0nK2RhdGFFbCArICctJyArIGl9IGlkPXtkYXRhRWx9IG9uQ2xpY2s9e3RoaXMub25DbGljay5iaW5kKHRoaXMsIGRhdGFFbCl9PntkYXRhRWx9PC9saT47XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE2IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuLyogZ2xvYmFsIGdhOnRydWUgKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBHQSB0cmFja2luZyBpZiB0cmFja2luZ1xuICAgKiBjb2RlIGlzIHByZXNlbnRcbiAgICpcbiAgICogQGZ1bmMgaW5pdFxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBwYXJhbSBDYXRlZ29yeSB7aWR9IEdBIHRyYWNraW5nIGNvZGVcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGluaXQoaWQpIHtcbiAgICBpZihpZCkge1xuICAgICAgKGZ1bmN0aW9uKGksIHMsIG8sIGcsIHIsIGEsIG0pIHtcbiAgICAgICAgaVsnR29vZ2xlQW5hbHl0aWNzT2JqZWN0J109cjtcbiAgICAgICAgaVtyXT1pW3JdfHxmdW5jdGlvbigpIHtcbiAgICAgICAgICAoaVtyXS5xPWlbcl0ucXx8W10pLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaVtyXS5sPTEqbmV3IERhdGUoKTtcbiAgICAgICAgYT1zLmNyZWF0ZUVsZW1lbnQobyksXG4gICAgICAgIG09cy5nZXRFbGVtZW50c0J5VGFnTmFtZShvKVswXTtcbiAgICAgICAgYS5hc3luYz0xO1xuICAgICAgICBhLnNyYz1nO1xuICAgICAgICBtLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsIG0pO1xuICAgICAgfSkod2luZG93LCBkb2N1bWVudCwgJ3NjcmlwdCcsICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCAnZ2EnKTtcbiAgICAgIGdhKCdjcmVhdGUnLCBpZCwgJ2F1dG8nKTtcbiAgICAgIGdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XG4gICAgfVxuICB9LFxuXHQvKipcblx0ICogQGZ1bmMgVHJhY2tFdmVudEdBXG5cdCAqIEBzdGF0aWNcblx0ICpcblx0ICogQHBhcmFtIENhdGVnb3J5IHtzdHJpbmd9IEV2ZW50IGdyb3VwIG5hbWVcblx0ICogQHBhcmFtIEFjdGlvbiB7c3RyaW5nfSBUeXBlIG9mIHVzZXIgaW50ZXJhY3Rpb25cblx0ICogQHBhcmFtIExhYmVsIHtzdHJpbmd9IE9wdGlvbmFsIHN0cmluZyBmb3IgYmV0dGVyXG5cdCAqICAgICB2ZXJpZmljYXRpb24gb2YgdGhlIGV2ZW50XG5cdCAqIEBwYXJhbSBWYWx1ZSB7bnVtYmVyfSBPcHRpb25hbCBudW1iZXIgdG8gYXNzb2NpYXRlXG5cdCAqICAgICB3aXRoIGV2ZW50XG5cdCAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG5cdCAqL1xuICBldmVudChjYXRlZ29yeSwgYWN0aW9uLCBsYWJlbCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIChnYSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgY2F0ZWdvcnksIGFjdGlvbiwgbGFiZWwsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbiIsIi8qXG4gKiBOQVNBIFdvcmxkdmlld1xuICpcbiAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSBkZXZlbG9wZWQgYXQgTkFTQS9Hb2RkYXJkIFNwYWNlIEZsaWdodCBDZW50ZXIgZm9yXG4gKiB0aGUgRWFydGggU2NpZW5jZSBEYXRhIGFuZCBJbmZvcm1hdGlvbiBTeXN0ZW0gKEVTRElTKSBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxMyAtIDIwMTYgVW5pdGVkIFN0YXRlcyBHb3Zlcm5tZW50IGFzIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogQWRtaW5pc3RyYXRvciBvZiB0aGUgTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTkFTQSBPcGVuIFNvdXJjZSBBZ3JlZW1lbnQsIFZlcnNpb24gMS4zXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5nc2ZjLm5hc2EuZ292L25vc2EucGhwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbHMge1xuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9udGhTdHJpbmdBcnJheT0gWyBcIkpBTlwiLCBcIkZFQlwiLCBcIk1BUlwiLCBcIkFQUlwiLCBcIk1BWVwiLCBcIkpVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkpVTFwiLCBcIkFVR1wiLCBcIlNFUFwiLCBcIk9DVFwiLCBcIk5PVlwiLCBcIkRFQ1wiIF07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgZGF5LiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHRoZSBEYXRlIG1ldGhvZHMgdG8gYWxsb3dcbiAgICogZGVidWdnaW5nIGFsdGVybmF0ZSBcIm5vd1wiIHRpbWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIHRvZGF5XG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RGF0ZX0gVGhlIGN1cnJlbnQgdGltZSB3aXRoIHRoZSBVVEMgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzXG4gICAqIGZpZWxkcyBzZXQgdG8gemVybyBvciBhbiBvdmVycmlkZW4gdmFsdWUuXG4gICAqL1xuICB0b2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhclRpbWVVVEModGhpcy5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGRhdGUgdG8gVVRDIG1pZG5pZ2h0LlxuICAgKlxuICAgKiBAbWV0aG9kIGNsZWFyVGltZVVUQ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSBkYXRlIHtEYXRlfSBkYXRlIHRvIHNldCB0aGUgVVRDIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kc1xuICAgKiB0byB6ZXJvLlxuICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZSBvYmplY3RcbiAgICovXG4gIGNsZWFyVGltZVVUQyhkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwKTtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCk7XG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKDApO1xuICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsIDwgbWluKSB7IHJldHVybiBtaW47IH1cbiAgICBpZiAodmFsID4gbWF4KSB7IHJldHVybiBtYXg7IH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGRheXNJbk1vbnRoKGQpIHtcbiAgICB2YXIgeTtcbiAgICB2YXIgbTtcbiAgICBpZihkLmdldFVUQ0Z1bGxZZWFyKSB7XG4gICAgICB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgbSA9IGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IGQueWVhcjtcbiAgICAgIG0gPSBkLm1vbnRoO1xuICAgIH1cbiAgICB2YXIgbGFzdERheSA9IG5ldyBEYXRlKERhdGUuVVRDKHksIG0gKyAxLCAwKSk7XG4gICAgcmV0dXJuIGxhc3REYXkuZ2V0VVRDRGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUuIFVzZSB0aGlzIGluc3RlYWQgb2YgdGhlIERhdGUgbWV0aG9kcyB0byBhbGxvd1xuICAgKiBkZWJ1Z2dpbmcgYWx0ZXJuYXRlIFwibm93XCIgdGltZXMuXG4gICAqXG4gICAqIEBtZXRob2Qgbm93XG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RGF0ZX0gVGhlIGN1cnJlbnQgdGltZSBvciBhbiBvdmVycmlkZW4gdmFsdWUuXG4gICAqL1xuICBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgc3RyaW5nSW5BcnJheShhcnJhLCB2YWx1ZSkge1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFycmEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmKGFycmFbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWluRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTAwMCwgMCwgMSkpO1xuICB9XG5cbiAgbWF4RGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMzAwMCwgMTEsIDMxKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFVUQyBJU08gODYwMSBkYXRlLlxuICAgKlxuICAgKiBAbWV0aG9kIHBhcnNlRGF0ZVVUQ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSBzdHIge3N0cmluZ30gRGF0ZSB0byBwYXJzZSBpbiB0aGUgZm9ybSBvZiBgYFlZWVktTU0tRERgYC5cbiAgICogQHJldHVybiB7RGF0ZX0gY29udmVydGVkIHN0cmluZyBhcyBhIGRhdGUgb2JqZWN0LCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmXG4gICAqIHRoZSBzdHJpbmcgaXMgaW52YWxpZFxuICAgKi9cbiAgICAvLyBOT1RFOiBPbGRlciBTYWZhcmkgZG9lc24ndCBsaWtlIERhdGUucGFyc2VcbiAgcGFyc2VEYXRlVVRDKGRhdGVBc1N0cmluZykge1xuICAgIHZhciBkYXRlVGltZUFyciA9IGRhdGVBc1N0cmluZy5zcGxpdCgvVC8pO1xuICAgIHZhciB5eXl5bW1kZCA9IGRhdGVUaW1lQXJyWzBdLnNwbGl0KCctJyk7XG5cbiAgICAvLyBQYXJzZSBlbGVtZW50cyBvZiBkYXRlIGFuZCB0aW1lXG4gICAgdmFyIHllYXIgPSB5eXl5bW1kZFswXTtcbiAgICB2YXIgbW9udGggPSB5eXl5bW1kZFsxXSAtIDE7XG4gICAgdmFyIGRheSA9IHl5eXltbWRkWzJdO1xuXG4gICAgdmFyIGhvdXIgPSAwO1xuICAgIHZhciBtaW51dGUgPSAwO1xuICAgIHZhciBzZWNvbmQgPSAwO1xuICAgIHZhciBtaWxsaXNlY29uZCA9IDA7XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBvZiBtaWRuaWdodCBpZiB0aW1lIGlzIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAoZGF0ZVRpbWVBcnIubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGhobW1zcyA9IGRhdGVUaW1lQXJyWzFdLnNwbGl0KC9bOlxcLlpdLyk7XG4gICAgICBob3VyID0gaGhtbXNzWzBdIHx8IDA7XG4gICAgICBtaW51dGUgPSBoaG1tc3NbMV0gfHwgMDtcbiAgICAgIHNlY29uZCA9IGhobW1zc1syXSB8fCAwO1xuICAgICAgbWlsbGlzZWNvbmQgPSBoaG1tc3NbM10gfHwgMDtcbiAgICB9XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKTtcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0ZTogJyArIGRhdGVBc1N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJlcGVhdCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcm9sbCh2YWwsIG1pbiwgbWF4KSB7XG4gICAgaWYodmFsIDwgbWluKSB7cmV0dXJuIG1heCAtIChtaW4gLSB2YWwpICsgMTt9XG4gICAgaWYodmFsID4gbWF4KSB7cmV0dXJuIG1pbiArICh2YWwgLSBtYXgpIC0gMTt9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByb2xsUmFuZ2UoZGF0ZSwgaW50ZXJ2YWwsIG1pbkRhdGUsIG1heERhdGUpIHtcbiAgICB2YXIgeSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB2YXIgbSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICB2YXIgZmlyc3QsIGxhc3Q7XG4gICAgc3dpdGNoIChpbnRlcnZhbCkge1xuICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICB2YXIgZmlyc3REYXkgPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCBtLCAxKSk7XG4gICAgICAgIHZhciBsYXN0RGF5ID0gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgdGhpcy5kYXlzSW5Nb250aChkYXRlKSkpO1xuICAgICAgICBmaXJzdCA9IG5ldyBEYXRlKE1hdGgubWF4KGZpcnN0RGF5LCBtaW5EYXRlKSkuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICBsYXN0ID0gbmV3IERhdGUoTWF0aC5taW4obGFzdERheSwgbWF4RGF0ZSkpLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgdmFyIGZpcnN0TW9udGggPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCAwLCAxKSk7XG4gICAgICAgIHZhciBsYXN0TW9udGggPSBuZXcgRGF0ZShEYXRlLlVUQyh5LCAxMSwgMzEpKTtcbiAgICAgICAgZmlyc3QgPSBuZXcgRGF0ZShNYXRoLm1heChmaXJzdE1vbnRoLCBtaW5EYXRlKSkuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgbGFzdCA9IG5ldyBEYXRlKE1hdGgubWluKGxhc3RNb250aCwgbWF4RGF0ZSkpLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgdmFyIGZpcnN0WWVhciA9IHRoaXMubWluRGF0ZSgpO1xuICAgICAgICB2YXIgbGFzdFllYXIgPSB0aGlzLm1heERhdGUoKTtcbiAgICAgICAgZmlyc3QgPSBuZXcgRGF0ZShNYXRoLm1heChmaXJzdFllYXIsIG1pbkRhdGUpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBsYXN0ID0gbmV3IERhdGUoTWF0aC5taW4obGFzdFllYXIsIG1heERhdGUpKS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBsYXN0IH07XG4gIH1cbiAgcm9sbERhdGUoZGF0ZSwgaW50ZXJ2YWwsIGFtb3VudCwgbWluRGF0ZSwgbWF4RGF0ZSkge1xuICAgIG1pbkRhdGUgPSBtaW5EYXRlIHx8IHRoaXMubWluRGF0ZSgpO1xuICAgIG1heERhdGUgPSBtYXhEYXRlIHx8IHRoaXMubWF4RGF0ZSgpO1xuICAgIHZhciByYW5nZSA9IHRoaXMucm9sbFJhbmdlKGRhdGUsIGludGVydmFsLCBtaW5EYXRlLCBtYXhEYXRlKTtcbiAgICB2YXIgbWluID0gcmFuZ2UuZmlyc3Q7XG4gICAgdmFyIG1heCA9IHJhbmdlLmxhc3Q7XG4gICAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICBzd2l0Y2ggKGludGVydmFsKSB7XG4gICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgIGRheSA9IHRoaXMucm9sbChkYXkgKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgbW9udGggPSB0aGlzLnJvbGwobW9udGggKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICB5ZWFyID0gdGhpcy5yb2xsKHllYXIgKyBhbW91bnQsIG1pbiwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbcm9sbERhdGVdIEludmFsaWQgaW50ZXJ2YWw6IFwiICsgaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB2YXIgZGF5c0luTW9udGggPSB0aGlzLmRheXNJbk1vbnRoKHt5ZWFyOiB5ZWFyLCBtb250aDogbW9udGh9KTtcbiAgICBpZihkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgZGF5ID0gZGF5c0luTW9udGg7XG4gICAgfVxuICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmNsYW1wKG5ld0RhdGUsIG1pbkRhdGUsIG1heERhdGUpKTtcbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuICBwYWQodmFsdWUsIHdpZHRoLCBwYWRkaW5nKSB7XG4gICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgaWYodmFsdWUubGVuZ3RoIDwgd2lkdGgpIHtcbiAgICAgIHZhciBhZGQgPSB3aWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgICAgIHZhbHVlID0gdGhpcy5yZXBlYXQocGFkZGluZywgYWRkKSArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0iLCIvKlxuICogTkFTQSBXb3JsZHZpZXdcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgZGV2ZWxvcGVkIGF0IE5BU0EvR29kZGFyZCBTcGFjZSBGbGlnaHQgQ2VudGVyIGZvclxuICogdGhlIEVhcnRoIFNjaWVuY2UgRGF0YSBhbmQgSW5mb3JtYXRpb24gU3lzdGVtIChFU0RJUykgcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMgLSAyMDE0IFVuaXRlZCBTdGF0ZXMgR292ZXJubWVudCBhcyByZXByZXNlbnRlZCBieSB0aGVcbiAqIEFkbWluaXN0cmF0b3Igb2YgdGhlIE5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbi5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIEFuaW1hdGlvbldpZGdldH0gZnJvbSAnLi9jb21wb25lbnRzL2FuaW1hdGlvbndpZGdldC93di5hbmltYXRpb24ud2lkZ2V0LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSYW5nZVNlbGVjdG9yfSBmcm9tICcuL2NvbXBvbmVudHMvcmFuZ2VzZWxlY3Rpb24vd3YudGltZWxpbmUucmFuZ2VzZWxlY3Rpb24uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERhdGVTZWxlY3Rvcn0gZnJvbSAnLi9jb21wb25lbnRzL2RhdGVTZWxlY3Rvci93di5kYXRlU2VsZWN0b3IuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRvb2xUaXB9IGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwL3d2LnRvb2x0aXAuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFV0aWxzfSBmcm9tICcuL2NvbXBvbmVudHMvdXRpbC93di51dGlscy5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgR0F9IGZyb20gJy4vY29tcG9uZW50cy91dGlsL3d2Lmdvb2dsZUFuYWx5dGljcy5qcyc7XG4iXX0=